// Copyright (c) 2016 Mumba. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "GenShims.h"

#include <memory>

#include "base/command_line.h"
#include "base/at_exit.h"
#include "base/process/launch.h"
#include "base/threading/thread.h"
#include "base/files/file_util.h"
#include "base/files/file.h"
#include "base/files/file_path.h"
#include "base/files/file_util.h"
#include "base/task_scheduler/task_scheduler.h"
#include "base/strings/string_number_conversions.h"
#include "base/strings/string_util.h"
#include "base/strings/utf_string_conversions.h"
#include "base/synchronization/waitable_event.h"
#include "base/hash.h"
#include "base/atomicops.h"
#include "base/bind.h"
#include "base/strings/stringprintf.h"
#include "base/timer/elapsed_timer.h"
#include "base/synchronization/waitable_event.h"
#include "build/build_config.h"
#include "gen/build_settings.h"
#include "gen/commands.h"
#include "gen/ninja_target_writer.h"
#include "gen/ninja_writer.h"
#include "gen/runtime_deps.h"
#include "gen/scheduler.h"
#include "gen/setup.h"
#include "gen/standard_out.h"
#include "gen/switches.h"
#include "gen/target.h"
#include "gen/eclipse_writer.h"
#include "gen/json_project_writer.h"
#include "gen/qt_creator_writer.h"
#include "gen/runtime_deps.h"
#include "gen/visual_studio_writer.h"
#include "gen/xcode_writer.h"
#include "gen/swift_output_map_writer.h"
#include "crypto/secure_hash.h"
#include "crypto/sha2.h"

// Collects Ninja rules for each toolchain. The lock protectes the rules.
struct TargetWriteInfo {
  base::Lock lock;
  NinjaWriter::PerToolchainRules rules;
};

// Called on worker thread to write the ninja file.
void BackgroundDoWrite(
  TargetWriteInfo* write_info,
  scoped_refptr<Target> target) {
 
  if (target->is_swift_target()) {
    if (!SwiftOutputMapWriter::WriteFile(target)) {
      DLOG(ERROR) << "failed to create the swift output map file for target";
      return;
    }
  }

  std::string rule = NinjaTargetWriter::RunAndWriteFile(target);
  DCHECK(!rule.empty());

  {
    base::AutoLock lock(write_info->lock);
    write_info->rules[target->toolchain().get()].emplace_back(
        target.get(), std::move(rule));
  }
}

// Called on the main thread.
void ItemResolvedAndGeneratedCallback(TargetWriteInfo* write_info,
                                      const BuilderRecord* record) {
  scoped_refptr<Item> item = record->item();
  scoped_refptr<Target> target = item->AsTarget();
  if (target) {
    g_scheduler->ScheduleWork(base::Bind(&BackgroundDoWrite,
                                         write_info, target));
  }
}

// Returns a pointer to the target with the given file as an output, or null
// if no targets generate the file. This is brute force since this is an
// error condition and performance shouldn't matter.
scoped_refptr<Target> FindTargetThatGeneratesFile(const Builder& builder,
                                                  const SourceFile& file) {
  std::vector<Target*> targets = builder.GetAllResolvedTargets();
  if (targets.empty())
    return nullptr;

  OutputFile output_file(targets[0]->settings()->build_settings(), file);
  for (Target* target : targets) {
    for (const auto& cur_output : target->computed_outputs()) {
      if (cur_output == output_file)
        return scoped_refptr<Target>(target);
    }
  }
  return nullptr;
}

// Prints an error that the given file was present as a source or input in
// the given target(s) but was not generated by any of its dependencies.
void PrintInvalidGeneratedInput(const Builder& builder,
                                const SourceFile& file,
                                const std::vector<Target*>& targets) {
  std::string err;

  // Only show the toolchain labels (which can be confusing) if something
  // isn't the default.
  bool show_toolchains = false;
  const Label& default_toolchain =
      targets[0]->settings()->default_toolchain_label();
  for (const Target* target : targets) {
    if (target->settings()->toolchain_label() != default_toolchain) {
      show_toolchains = true;
      break;
    }
  }

  scoped_refptr<Target> generator = FindTargetThatGeneratesFile(builder, file);
  if (generator &&
      generator->settings()->toolchain_label() != default_toolchain)
    show_toolchains = true;

  const std::string target_str = targets.size() > 1 ? "targets" : "target";
  err += "The file:\n";
  err += "  " + file.value() + "\n";
  err += "is listed as an input or source for the " + target_str + ":\n";
  for (const Target* target : targets)
    err += "  " + target->label().GetUserVisibleName(show_toolchains) + "\n";

  if (generator) {
    err += "but this file was not generated by any dependencies of the " +
           target_str + ". The target\nthat generates the file is:\n  ";
    err += generator->label().GetUserVisibleName(show_toolchains);
  } else {
    err += "but no targets in the build generate that file.";
  }

  Err(Location(), "Input to " + target_str + " not generated by a dependency.",
      err).PrintToStdout();
}

bool CheckForInvalidGeneratedInputs(Setup* setup) {
  std::multimap<SourceFile, Target*> unknown_inputs =
      g_scheduler->GetUnknownGeneratedInputs();
  if (unknown_inputs.empty())
    return true;  // No bad files.

  int errors_found = 0;
  auto cur = unknown_inputs.begin();
  while (cur != unknown_inputs.end()) {
    errors_found++;
    auto end_of_range = unknown_inputs.upper_bound(cur->first);

    // Package the values more conveniently for printing.
    SourceFile bad_input = cur->first;
    std::vector<Target*> targets;
    while (cur != end_of_range)
      targets.push_back((cur++)->second);

    PrintInvalidGeneratedInput(setup->builder(), bad_input, targets);
    OutputString("\n");
  }

  OutputString(
      "If you have generated inputs, there needs to be a dependency path "
      "between the\ntwo targets in addition to just listing the files. For "
      "indirect dependencies,\nthe intermediate ones must be public_deps. "
      "data_deps don't count since they're\nonly runtime dependencies. If "
      "you think a dependency chain exists, it might be\nbecause the chain "
      "is private. Try \"gn path\" to analyze.\n");

  if (errors_found > 1) {
    OutputString(base::StringPrintf("\n%d generated input errors found.\n",
                                    errors_found), DECORATION_YELLOW);
  }
  return false;
}

bool RunIdeWriter(const std::string& ide,
                  const BuildSettings* build_settings,
                  const Builder& builder,
                  Err* err) {
  //const base::CommandLine* command_line =
   //   base::CommandLine::ForCurrentProcess();
  //bool quiet = command_line->HasSwitch(switches::kQuiet);
  base::ElapsedTimer timer;

  // if (ide == kSwitchIdeValueEclipse) {
  //   bool res = EclipseWriter::RunAndWriteFile(build_settings, builder, err);
  //   if (res && !quiet) {
  //     OutputString("Generating Eclipse settings took " +
  //                  base::Int64ToString(timer.Elapsed().InMilliseconds()) +
  //                  "ms\n");
  //   }
  //   return res;
  // } else if (ide == kSwitchIdeValueVs || ide == kSwitchIdeValueVs2013 ||
  //            ide == kSwitchIdeValueVs2015 || ide == kSwitchIdeValueVs2017) {
  //   VisualStudioWriter::Version version = VisualStudioWriter::Version::Vs2017;
  //   if (ide == kSwitchIdeValueVs2013)
  //     version = VisualStudioWriter::Version::Vs2013;
  //   else if (ide == kSwitchIdeValueVs2015)
  //     version = VisualStudioWriter::Version::Vs2015;

  //   std::string sln_name;
  //   if (command_line->HasSwitch(kSwitchSln))
  //     sln_name = command_line->GetSwitchValueASCII(kSwitchSln);
  //   std::string filters;
  //   if (command_line->HasSwitch(kSwitchFilters))
  //     filters = command_line->GetSwitchValueASCII(kSwitchFilters);
  //   std::string win_kit;
  //   if (command_line->HasSwitch(kSwitchIdeValueWinSdk))
  //     win_kit = command_line->GetSwitchValueASCII(kSwitchIdeValueWinSdk);
  //   std::string ninja_extra_args;
  //   if (command_line->HasSwitch(kSwitchNinjaExtraArgs))
  //     ninja_extra_args =
  //         command_line->GetSwitchValueASCII(kSwitchNinjaExtraArgs);
  //   bool no_deps = command_line->HasSwitch(kSwitchNoDeps);
  //   bool res = VisualStudioWriter::RunAndWriteFiles(
  //       build_settings, builder, version, sln_name, filters, win_kit,
  //       ninja_extra_args, no_deps, err);
  //   if (res && !quiet) {
  //     OutputString("Generating Visual Studio projects took " +
  //                  base::Int64ToString(timer.Elapsed().InMilliseconds()) +
  //                  "ms\n");
  //   }
  //   return res;
  // } else if (ide == kSwitchIdeValueXcode) {
  //   bool res = XcodeWriter::RunAndWriteFiles(
  //       command_line->GetSwitchValueASCII(kSwitchWorkspace),
  //       command_line->GetSwitchValueASCII(kSwitchRootTarget),
  //       command_line->GetSwitchValueASCII(kSwitchNinjaExtraArgs),
  //       command_line->GetSwitchValueASCII(kSwitchFilters), build_settings,
  //       builder, err);
  //   if (res && !quiet) {
  //     OutputString("Generating Xcode projects took " +
  //                  base::Int64ToString(timer.Elapsed().InMilliseconds()) +
  //                  "ms\n");
  //   }
  //   return res;
  // } else if (ide == kSwitchIdeValueQtCreator) {
  //   std::string root_target;
  //   if (command_line->HasSwitch(kSwitchRootTarget))
  //     root_target = command_line->GetSwitchValueASCII(kSwitchRootTarget);
  //   bool res = QtCreatorWriter::RunAndWriteFile(build_settings, builder, err,
  //                                               root_target);
  //   if (res && !quiet) {
  //     OutputString("Generating QtCreator projects took " +
  //                  base::Int64ToString(timer.Elapsed().InMilliseconds()) +
  //                  "ms\n");
  //   }
  //   return res;
  // } else if (ide == kSwitchIdeValueJson) {
  //   std::string file_name =
  //       command_line->GetSwitchValueASCII(kSwitchJsonFileName);
  //   if (file_name.empty())
  //     file_name = "project.json";
  //   std::string exec_script =
  //       command_line->GetSwitchValueASCII(kSwitchJsonIdeScript);
  //   std::string exec_script_extra_args =
  //       command_line->GetSwitchValueASCII(kSwitchJsonIdeScriptArgs);
  //   std::string filters = command_line->GetSwitchValueASCII(kSwitchFilters);

  //   bool res = JSONProjectWriter::RunAndWriteFiles(
  //       build_settings, builder, file_name, exec_script, exec_script_extra_args,
  //       filters, quiet, err);
  //   if (res && !quiet) {
  //     OutputString("Generating JSON projects took " +
  //                  base::Int64ToString(timer.Elapsed().InMilliseconds()) +
  //                  "ms\n");
  //   }
  //   return res;
  // }

  *err = Err(Location(), "Unknown IDE: " + ide);
  return false;
}


void PrintHelp() {
  const char kHELP_STR[] = "usage: [path]\n";
  printf(kHELP_STR);
}

int _mumba_gen_main(int argc, char** argv) {
  base::AtExitManager at_exit;
  base::ElapsedTimer timer;
//  base::WaitableEvent setup_done(base::WaitableEvent::ResetPolicy::AUTOMATIC, base::WaitableEvent::InitialState::NOT_SIGNALED);

  base::CommandLine::Init(argc, argv);

  base::CommandLine* cmd = base::CommandLine::ForCurrentProcess();
  auto args = cmd->GetArgs();

  base::FilePath current_dir;
  base::FilePath out_dir;

  if (args.size() < 1) {
    if (!base::GetCurrentDirectory(&current_dir)) {
      printf("could not get the current directory\n");
      return 1;
    }
    out_dir = current_dir.AppendASCII("out");
  } else {
#if defined(OS_WIN)
    base::string16 path = args[0];
    if (path == L"gen") {
#elif defined(OS_POSIX)
    std::string path = args[0];
    if (path == "gen") {
#endif
      path = args[1];
    }
    out_dir = base::FilePath(path);
  }

  if (!base::DirectoryExists(out_dir)) {
    if (!base::CreateDirectory(out_dir)) {
#if defined(OS_WIN)
      printf("could not create output directory %Ls\n", out_dir.value().c_str());
#else
      printf("could not create output directory %s\n", out_dir.value().c_str());
#endif
      return 1;
    }
  }

  std::unique_ptr<base::MessageLoop> message_loop(new base::MessageLoop());

  base::TaskScheduler::CreateAndStartWithDefaultParams("gen_task_scheduler");

  std::unique_ptr<Setup> setup(new Setup());//new Setup(std::move(message_loop)));

#if defined(OS_WIN)
  if (!setup->DoSetup(base::UTF16ToASCII(out_dir.value()), true)) {
    return 1;
  }
#elif defined(OS_POSIX)
  if (!setup->DoSetup(out_dir.value(), true)) {
    return 1;
  }
#endif  

   // Cause the load to also generate the ninja files for each target.
  TargetWriteInfo write_info;
  setup->builder().set_resolved_and_generated_callback(
      base::Bind(&ItemResolvedAndGeneratedCallback, &write_info));

  if (!setup->Run())
    return 1;

  Err err;
  
  // Sort the targets in each toolchain according to their label. This makes
  // the ninja files have deterministic content.
  for (auto& cur_toolchain : write_info.rules) {
    std::sort(cur_toolchain.second.begin(), cur_toolchain.second.end(),
              [](const NinjaWriter::TargetRulePair& a,
                 const NinjaWriter::TargetRulePair& b) {
                return a.first->label() < b.first->label();
              });
  }
 
  // Write the root ninja files.
  if (!NinjaWriter::RunAndWriteFiles(&setup->build_settings(),
                                     setup->builder(),
                                     write_info.rules,
                                     &err)) {
    if (err.has_error())
      err.PrintToStdout();
    return 1;
  }

  if (!WriteRuntimeDepsFilesIfNecessary(setup->builder(), &err)) {
    if (err.has_error())
      err.PrintToStdout();
    return 1;
  }

  if (!CheckForInvalidGeneratedInputs(setup.get()))
    return 1;

  base::TimeDelta elapsed_time = timer.Elapsed();

  //if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kQuiet)) {
   OutputString("Done. ", DECORATION_GREEN);

  size_t targets_collected = 0;
   for (const auto& rules : write_info.rules)
    targets_collected += rules.second.size();

  std::string stats = "Wrote " +
      base::NumberToString(targets_collected) +
      " targets from " +
      base::IntToString(
          setup->scheduler().input_file_manager()->GetInputFileCount()) +
      " files in " +
      base::Int64ToString(elapsed_time.InMilliseconds()) + "ms\n";

   OutputString(stats);

  base::TaskScheduler::GetInstance()->Shutdown(); 
  //}

  return 0;
}