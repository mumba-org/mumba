// Copyright (c) 2016 Mumba. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "WebShims.h"

#include "CompositorStructsPrivate.h"
#include "WebStructsPrivate.h"

namespace {

// bool _IsBackForwardLoadType(blink::FrameLoadType type) {
//   return type == blink::kFrameLoadTypeBackForward ||
//          type == blink::kFrameLoadTypeInitialHistoryLoad;
// }

// bool _IsReloadLoadType(blink::FrameLoadType type) {
//   return type == blink::kFrameLoadTypeReload ||
//          type == blink::kFrameLoadTypeReloadBypassingCache;
// }

// blink::NavigationType DetermineNavigationType(blink::FrameLoadType frame_load_type,
//                                               bool is_form_submission,
//                                               bool have_event) {
//   bool is_reload = _IsReloadLoadType(frame_load_type);
//   bool is_back_forward = _IsBackForwardLoadType(frame_load_type);
//   if (is_form_submission) {
//     return (is_reload || is_back_forward) ? blink::kNavigationTypeFormResubmitted
//                                           : blink::kNavigationTypeFormSubmitted;
//   }
//   if (have_event)
//     return blink::kNavigationTypeLinkClicked;
//   if (is_reload)
//     return blink::kNavigationTypeReload;
//   if (is_back_forward)
//     return blink::kNavigationTypeBackForward;
//   return blink::kNavigationTypeOther;
// }

const char kLTRString[] = "ltr";
//const char kRTLString[] = "rtl";


static const blink::WebString GenerateStyleSheetKey() {
  static unsigned counter = 0;
  return String::Number(++counter);
}

void SetStandardFontFamilyWrapper(blink::WebSettings* settings,
                                  const base::string16& font,
                                  UScriptCode script) {
  settings->SetStandardFontFamily(WebString::FromUTF16(font), script);
}

void SetFixedFontFamilyWrapper(blink::WebSettings* settings,
                               const base::string16& font,
                               UScriptCode script) {
  settings->SetFixedFontFamily(WebString::FromUTF16(font), script);
}

void SetSerifFontFamilyWrapper(blink::WebSettings* settings,
                               const base::string16& font,
                               UScriptCode script) {
  settings->SetSerifFontFamily(WebString::FromUTF16(font), script);
}

void SetSansSerifFontFamilyWrapper(blink::WebSettings* settings,
                                   const base::string16& font,
                                   UScriptCode script) {
  settings->SetSansSerifFontFamily(WebString::FromUTF16(font), script);
}

void SetCursiveFontFamilyWrapper(blink::WebSettings* settings,
                                 const base::string16& font,
                                 UScriptCode script) {
  settings->SetCursiveFontFamily(WebString::FromUTF16(font), script);
}

void SetFantasyFontFamilyWrapper(blink::WebSettings* settings,
                                 const base::string16& font,
                                 UScriptCode script) {
  settings->SetFantasyFontFamily(WebString::FromUTF16(font), script);
}

void SetPictographFontFamilyWrapper(blink::WebSettings* settings,
                                    const base::string16& font,
                                    UScriptCode script) {
  settings->SetPictographFontFamily(WebString::FromUTF16(font), script);
}

UScriptCode GetScriptForWebSettings(UScriptCode scriptCode) {
  switch (scriptCode) {
    case USCRIPT_HIRAGANA:
    case USCRIPT_KATAKANA:
    case USCRIPT_JAPANESE:
      return USCRIPT_KATAKANA_OR_HIRAGANA;
    case USCRIPT_KOREAN:
      return USCRIPT_HANGUL;
    default:
      return scriptCode;
  }
}

void ApplyFontsFromMap(const ScriptFontFamilyMap& map,
                       SetFontFamilyWrapper setter,
                       blink::WebSettings* settings) {
  for (ScriptFontFamilyMap::const_iterator it = map.begin(); it != map.end();
       ++it) {
    int32_t script = u_getPropertyValueEnum(UCHAR_SCRIPT, (it->first).c_str());
    if (script >= 0 && script < USCRIPT_CODE_LIMIT) {
      UScriptCode code = static_cast<UScriptCode>(script);
      (*setter)(settings, it->second, GetScriptForWebSettings(code));
    }
  }
}

String ScriptTypeToString(int script_type) {
  switch (script_type) {
    case 0:
      return String::FromUTF8("classic");
    case 1:
      return String::FromUTF8("module");
    case 2:
      return String::FromUTF8("native");
  }
  return String::FromUTF8("classic");
}

std::map<std::string, std::string> defaultMap = {
  {"webkit.webprefs.fonts.standard.Zyyy","Times New Roman"},
  {"webkit.webprefs.fonts.fixed.Zyyy", "Monospace"},
  {"webkit.webprefs.fonts.serif.Zyyy", "Arial"},
  {"webkit.webprefs.fonts.sansserif.Zyyy", "Times New Roman"},
  {"webkit.webprefs.fonts.cursive.Zyyy", "Comic Sans MS"},
  {"webkit.webprefs.fonts.fantasy.Zyyy", "Impact"},
  {"webkit.webprefs.fonts.pictograph.Zyyy", "Times New Roman"},
};

base::string16 FetchFont(const char* script,
                         const char* map_name) {
  std::string font_name = base::StringPrintf("%s.%s", map_name, script);
  std::string font = defaultMap[font_name];
  base::string16 font16 = base::UTF8ToUTF16(font);
  return font16;
}

void FillFontFamilyMap(const char* map_name,
                       ScriptFontFamilyMap* map) {
  for (size_t i = 0; i < kWebKitScriptsForFontFamilyMapsLength; ++i) {
    const char* script = kWebKitScriptsForFontFamilyMaps[i];
    base::string16 result = FetchFont(script, map_name);
    if (!result.empty())
      (*map)[script] = result;
  }
}

/*
Default = 0
Text = 1
JSON = 2
Document = 3
Blob = 4
ArrayBuffer = 5
*/

const char* XMLHttpRequestGetResponseTypeString(int type) {
  switch (type) {
    case 0:
     return "";
    case 1:
     return "text";
    case 2:
     return "json";
    case 3:
     return "document";
    case 4:
     return "blob";
    case 5:
     return "arraybuffer";  
  }
  return "";
}

// "GET", "POST", "DELETE", "HEAD", "OPTIONS", "PUT"
    
const char* XMLHttpRequestMethodToString(int method) {
  switch (method) {
    case 0:
     return "GET";
    case 1:
     return "POST";
    case 2:
     return "DELETE";
    case 3:
     return "HEAD";
    case 4:
     return "OPTIONS";
    case 5:
     return "PUT";  
  }
  return "GET";
}



String CanvasColorSpaceToString(int color_space) {
  switch(color_space) {
    case 0: // srgb
     return String::FromUTF8("srgb");
     break;
    case 1: // rec2020
     return String::FromUTF8("rec2020");
     break;
    case 2: // p3
     return String::FromUTF8("p3");
     break; 
  }
  return String::FromUTF8("srgb");
}

String CanvasStorageFormatToString(int format) {
  switch(format) {
    case 0: // uint8
     return String::FromUTF8("uint8");
     break;
    case 1: // uint16
     return String::FromUTF8("uint16");
     break;
    case 2: // float32
     return String::FromUTF8("float32");
     break; 
  }
  return String::FromUTF8("uint8");
}

/*
static const ScrollAlignment kAlignCenterIfNeeded;
static const ScrollAlignment kAlignToEdgeIfNeeded;
static const ScrollAlignment kAlignCenterAlways;
static const ScrollAlignment kAlignTopAlways;
static const ScrollAlignment kAlignBottomAlways;
static const ScrollAlignment kAlignLeftAlways;
static const ScrollAlignment kAlignRightAlways;
*/

blink::ScrollAlignment GetScrollAligment(int code) {
  switch (code) {
    case 0:
      return blink::ScrollAlignment::kAlignCenterIfNeeded;
    case 1:
      return blink::ScrollAlignment::kAlignToEdgeIfNeeded;
    case 2:
      return blink::ScrollAlignment::kAlignCenterAlways;
    case 3:
      return blink::ScrollAlignment::kAlignTopAlways;
    case 4:
      return blink::ScrollAlignment::kAlignBottomAlways;
    case 5:
      return blink::ScrollAlignment::kAlignLeftAlways;
    case 6:
      return blink::ScrollAlignment::kAlignRightAlways;
  }
  return blink::ScrollAlignment::kAlignCenterIfNeeded;
}

char* StringifyV8Value(v8::Isolate* isolate, v8::Local<v8::Value> value, int* len) {
  v8::HandleScope handleScope(isolate);

  if (value.IsEmpty() || !value->IsString()) {
    return nullptr;
  }
  v8::Local<v8::String> v8_string = value.As<v8::String>();
  v8::String::Utf8Value str_value(isolate, v8_string);
  char* result = reinterpret_cast<char *>(malloc(str_value.length()));
  memcpy(result, *str_value, str_value.length());
  *len = str_value.length();
  return result;
}

} // namespace

static void JavascriptFunctionCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  JavascriptFunctionHandler* handler = static_cast<JavascriptFunctionHandler*>(
    info.Data().As<v8::External>()->Value());
  //DCHECK(handler);
  //DCHECK(handler->callback_);
  
  // call function
  handler->callback_(handler->state_);
  if (handler->promise) {
    handler->promise->handled = true;
    if (handler->promise->should_be_deleted) {
      //DLOG(INFO) << "JavascriptFunctionCallback: deleting promise " << handler->promise;
      delete handler->promise;
      handler->promise = nullptr;
    }
  }
}

static void JavascriptFunctionResponseCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(info.Length() > 0);
  v8::Isolate* isolate = info.GetIsolate();
  v8::HandleScope scope(isolate);

  blink::Response* r = nullptr;

  JavascriptFunctionHandler* handler = static_cast<JavascriptFunctionHandler*>(
    info.Data().As<v8::External>()->Value());
  v8::Local<v8::Value> v8value = info[0];
  
  if (blink::V8Response::hasInstance(v8value, isolate)) {
    r = blink::V8Response::ToImpl(v8::Local<v8::Object>::Cast(v8value));
  }
  
  // call function
  handler->callback1_(handler->state_, r);
}

static void JavascriptFunctionCallback2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  DCHECK(info.Length() > 0);
  v8::Isolate* isolate = info.GetIsolate();
  v8::HandleScope scope(isolate);

  JavascriptFunctionHandler* handler = static_cast<JavascriptFunctionHandler*>(
    info.Data().As<v8::External>()->Value());
  v8::Local<v8::Value> arg0 = info[0];
  v8::Local<v8::Context> v8context = isolate->GetCurrentContext();
  // in this case we will need to allocate
  mumba::V8Context* context_wrapper = new mumba::V8Context(isolate, v8context);
 
  mumba::V8Value value_wrapper(isolate, arg0);
  //DCHECK(handler);
  //DCHECK(handler->callback2_);
  
  // call function
  handler->callback2_(handler->state_, context_wrapper, &value_wrapper);
  if (handler->promise) {
    handler->promise->handled = true;
    if (handler->promise->should_be_deleted) {
      delete handler->promise;
      handler->promise = nullptr;
    }
  }
}

static void WebWorkerPostTaskCallback(void* state, void(*cb)(void*)) {
  cb(state);
}

// Canvas helpers
cc::PaintRecorder* GetPaintRecorder(blink::CanvasRenderingContext2D* context) {
  blink::HTMLCanvasElement* canvas_element = static_cast<blink::HTMLCanvasElement*>(context->Host());
  blink::Canvas2DLayerBridge* canvas_layer_bridge = canvas_element->GetOrCreateCanvas2DLayerBridge();
  cc::PaintRecorder* paint_recorder = canvas_layer_bridge->GetPaintRecorder();
  return paint_recorder;
}

cc::PaintCanvas* GetCanvas(blink::CanvasRenderingContext2D* context) {
  blink::HTMLCanvasElement* canvas_element = static_cast<blink::HTMLCanvasElement*>(context->Host());
  blink::Canvas2DLayerBridge* canvas_layer_bridge = canvas_element->GetOrCreateCanvas2DLayerBridge();
  return canvas_layer_bridge->Canvas();
}

// Canvas helpers
cc::PaintRecorder* GetPaintRecorderFromPaint(blink::PaintRenderingContext2D* context) {
  return context->GetPaintRecorder();
}

cc::PaintCanvas* GetCanvasFromPaint(blink::PaintRenderingContext2D* context) {
  return context->DrawingCanvas();
}

cc::PaintRecorder* GetOffscreenPaintRecorder(blink::OffscreenCanvasRenderingContext2D* context) {
  cc::PaintRecorder* paint_recorder = context->GetPaintRecorder();
  return paint_recorder;
}

cc::PaintCanvas* GetOffscreenCanvas(blink::OffscreenCanvasRenderingContext2D* context) {
  return context->DrawingCanvas();
}

// CHECK: if a "parent" were deleted, and the reference
// of a cached value are still being managed in the swift size
// this will break!

// So we need to check if lifetime semantics for this are sound


void _WebNodeRetain(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->retain();
}

void _WebNodeRelease(WebNodeRef handle) {
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 // we just delete if it is the "parent" node
 // in this case it will release the cached nodes
 // TODO: see if this works as expected, specially in cases
 // where there are multi-level relationships

 // TODO: define when a node is a "parent" node
 // in a deterministic way so we can be sure this will
 // be correctly triggered, and things wont just leak
 if (!ref->is_cached() && ref->refcount() == 0 && !ref->is_stack_allocated()) {
   delete ref;
 }

 if (ref->refcount() > 0) {
  ref->release();
 }

}

int _WebNodeHasEditableStyle(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return blink::HasEditableStyle(*ref->constUnwrap<blink::Node>()) ? 1 : 0;
}
 
int _WebNodeGetType(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->getNodeType();
}

WebNodeRef _WebNodeGetParentNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->parent()) {
    auto* parent = new WebNodeWrapper(const_cast<blink::ContainerNode *>(ref->constUnwrap<blink::Node>()->parentNode()), true);
    ref->set_parent(parent);
  }
  return ref->parent();
}

const char* _WebNodeGetNodeValue(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String value = ref->constUnwrap<blink::Node>()->nodeValue();
  return reinterpret_cast<const char*>(value.Characters8());
}

const char* _WebNodeGetNodeName(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String value = ref->constUnwrap<blink::Node>()->nodeName(); 
  return reinterpret_cast<const char*>(value.Characters8());
}

WebNodeRef _WebNodeGetDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->document()) {
    // TODO: this doesnt smell good, and will probably make the ref count break somewhere
    auto* document = new WebNodeWrapper(&ref->constUnwrap<blink::Node>()->GetDocument(), true);
    ref->set_document(document);
  }
  return ref->document();
}

WebNodeRef _WebNodeFirstChild(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->first_child()) {
    auto* first_child = new WebNodeWrapper(ref->constUnwrap<blink::Node>()->firstChild(), true);
    ref->set_first_child(first_child);
  }
  return ref->first_child();
}

WebNodeRef _WebNodeLastChild(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->last_child()) {
    auto* last_child = new WebNodeWrapper(ref->constUnwrap<blink::Node>()->lastChild(), true);
    ref->set_last_child(last_child);
  }
  return ref->last_child();
}

WebNodeRef _WebNodePreviousSibling(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->previous_sibling()) {
    auto* previous_sibling = new WebNodeWrapper(ref->constUnwrap<blink::Node>()->previousSibling(), true);
    ref->set_previous_sibling(previous_sibling);
  }
  return ref->previous_sibling();
}

WebNodeRef _WebNodeNextSibling(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
   if (!ref->next_sibling()) {
    auto* next_sibling = new WebNodeWrapper(ref->constUnwrap<blink::Node>()->nextSibling(), true);
    ref->set_next_sibling(next_sibling);
  }
  return ref->next_sibling();
}

WebAXObjectRef _WebNodeGetAccessibilityObject(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::Document& doc = ref->constUnwrap<blink::Node>()->GetDocument();
  blink::AXObjectCacheImpl* cache = blink::ToAXObjectCacheImpl(doc.ExistingAXObjectCache());
  //blink::Node* node = ref->unwrap<blink::Node>();
  return cache != nullptr ? new WebAXObjectWrapper() : nullptr;
}

int _WebNodeHasChildNodes(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->hasChildren() ? 1 : 0;
}

int _WebNodeIsLink(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsLink() ? 1 : 0;
}

int _WebNodeIsDocumentNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsDocumentNode() ? 1 : 0;
}

int _WebNodeIsCommentNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->getNodeType() == blink::Node::kCommentNode ? 1 : 0;
}

int _WebNodeIsTextNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsTextNode() ? 1 : 0;
}

int _WebNodeIsFocusable(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (!ref->constUnwrap<blink::Node>()->IsElementNode()) {
    return 0;
  }
  
  ref->constUnwrap<blink::Node>()->GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();
  return ref->constUnwrap<blink::Element>()->IsFocusable() ? 1 : 0;
}

// int _WebNodeIsContentEditable(WebNodeRef handle) {
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   return ref->constUnwrap<blink::Node>()->IsContentEditable() ? 1 : 0;
// }

int _WebNodeIsElementNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsElementNode() ? 1 : 0;
}

int _WebNodeIsInsideFocusableElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return blink::AXObjectCacheBase::IsInsideFocusableElementOrARIAWidget(*ref->constUnwrap<blink::Node>());  
}

int _WebNodeIsEqual(WebNodeRef handle, WebNodeRef other) {
  WebNodeWrapper* left = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* right = reinterpret_cast<WebNodeWrapper *>(other);
  return left->equals(right) ? 1 : 0;
}

int _WebNodeLessThan(WebNodeRef handle, WebNodeRef other) {
  WebNodeWrapper* left = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* right = reinterpret_cast<WebNodeWrapper *>(other);
  return left->less_than(right) ? 1 : 0;
}

void _WebNodeDispatchEvent(WebNodeRef handle, WebEventRef event) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  //ref->dispatchEvent(reinterpret_cast<blink::Event *>(event));
  ref->unwrap<blink::Node>()->DispatchScopedEvent(reinterpret_cast<blink::Event *>(event));
}

HTMLCollectionRef _WebNodeGetElementsByTagName(WebNodeRef handle, const char* tag) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (ref->constUnwrap<blink::Node>()->IsContainerNode()) {
    blink::HTMLCollection* collection = ref->unwrap<blink::ContainerNode>()->getElementsByTagNameNS(blink::HTMLNames::xhtmlNamespaceURI, tag);
    if (!collection) {
      return nullptr; 
    }
    return new HTMLCollectionWrapper(collection);
  }
  return nullptr;
}

WebNodeRef _WebNodeQuerySelector(WebNodeRef handle, const char* selector) {  
  int code = 0;
  return _WebNodeQuerySelectorException(handle, selector, &code);
}

WebNodeRef _WebNodeQuerySelectorException(WebNodeRef handle, const char* selector, int* code) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 if (!ref->constUnwrap<blink::Node>()->IsContainerNode())
  return nullptr;
 
 blink::NonThrowableExceptionState exceptionState;
 blink::Element* element = ref->unwrap<blink::ContainerNode>()->QuerySelector(selector, exceptionState);
 *code = exceptionState.Code();

 if (!element)
  return nullptr;

 return new WebNodeWrapper(element);
}

WebElementArrayRef _WebNodeQuerySelectorAll(WebNodeRef handle, const char* selector) {  
  int code = 0;
  return _WebNodeQuerySelectorAllException(handle, selector, &code);
}

WebElementArrayRef _WebNodeQuerySelectorAllException(WebNodeRef handle, const char* selector, int* code) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->constUnwrap<blink::Node>()->IsContainerNode()) {
    return nullptr;
  }
  blink::NonThrowableExceptionState exceptionState;
  blink::StaticElementList* elements = ref->unwrap<blink::ContainerNode>()->QuerySelectorAll(selector, exceptionState);
  *code = exceptionState.Code();
  if (exceptionState.HadException()) {
   return nullptr;
  }
  
  return new WebElementArrayWrapper(elements);
}

int _WebNodeIsEditingText(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsEditingText() ? 1 : 0;
}

int _WebNodeIsContainerNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsContainerNode() ? 1 : 0;
}

int _WebNodeIsHTMLElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsHTMLElement() ? 1 : 0;
}

int _WebNodeIsSVGElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsSVGElement() ? 1 : 0;
}

int _WebNodeIsCustomElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsCustomElement() ? 1 : 0;
}

int _WebNodeIsStyledElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsStyledElement() ? 1 : 0;
}

int _WebNodeIsDocumentFragment(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsDocumentFragment() ? 1 : 0;
}

int _WebNodeIsShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsShadowRoot() ? 1 : 0;
}

int _WebNodeIsFocused(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsFocused() ? 1 : 0;
}

void _WebNodeSetFocused(WebNodeRef handle, int focused) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::Node>()->SetFocused(focused != 0, blink::kWebFocusTypeNone);
}

int _WebNodeHasFocusWithin(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->HasFocusWithin() ? 1 : 0;
}

void _WebNodeSetHasFocusWithin(WebNodeRef handle, int focused) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::Node>()->SetHasFocusWithin(focused != 0);
}

int _WebNodeWasFocusedByMouse(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->WasFocusedByMouse() ? 1 : 0;
}

void _WebNodeSetWasFocusedByMouse(WebNodeRef handle, int focused) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::Node>()->SetWasFocusedByMouse(focused != 0);
}

int _WebNodeIsActive(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsActive() ? 1 : 0;
}

void _WebNodeSetActive(WebNodeRef handle, int active) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Node>()->SetActive(active != 0);
}

int _WebNodeInActiveChain(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->InActiveChain() ? 1 : 0;
}

int _WebNodeIsDragged(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsDragged() ? 1 : 0;
}

void _WebNodeSetDragged(WebNodeRef handle, int dragged) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Node>()->SetDragged(dragged != 0);
}

int _WebNodeIsHovered(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsHovered() ? 1 : 0;
}

void _WebNodeSetHovered(WebNodeRef handle, int hovered) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Node>()->SetHovered(hovered != 0);
}

int _WebNodeIsInert(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsInert() ? 1 : 0;
}

WebNodeRef _WebNodeOwnerShadowHost(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* host = ref->constUnwrap<blink::Node>()->OwnerShadowHost();
  if (!host) {
    return nullptr;
  }
  return new WebNodeWrapper(host);
}

WebNodeRef _WebNodeContainingShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::ShadowRoot* root = ref->constUnwrap<blink::Node>()->ContainingShadowRoot();
  if (!root) {
    return nullptr;
  }
  return new WebNodeWrapper(root);
}

WebNodeRef _WebNodeShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::ShadowRoot* root = ref->constUnwrap<blink::Node>()->GetShadowRoot();
  if (!root) {
    return nullptr;
  }
  return new WebNodeWrapper(root);
}

void _WebNodeGetTextContent(WebNodeRef handle, void* peer, void(*cb)(void*, const char*, size_t)) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String text = ref->constUnwrap<blink::Node>()->textContent();
  cb(peer, reinterpret_cast<const char *>(text.Characters8()), text.length());
}

void _WebNodeSetTextContent(WebNodeRef handle, const char* text) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Node>()->setTextContent(String::FromUTF8(text));
}

void _WebNodeGetBoundingBox(WebNodeRef handle, int* x, int* y, int* width, int* height) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::IntRect rect = ref->constUnwrap<blink::Node>()->PixelSnappedBoundingBox();
  *x = rect.X();
  *y = rect.Y();
  *width = rect.Width();
  *height = rect.Height();
}

LayerRef _WebNodeGetContentsLayer(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::LayoutObject* layout = ref->constUnwrap<blink::Node>()->GetLayoutObject();
  //DLOG(INFO) << "LayoutObject ? " << layout;
  if (!layout) {
    return nullptr;
  }
  blink::PaintLayer* p_layer = layout->PaintingLayer();
  //DLOG(INFO) << "PaintLayer ? " << p_layer;
  if (!p_layer) {
    return nullptr;
  }
  // p_layer = p_layer->EnclosingLayerForPaintInvalidation();
  // //DLOG(INFO) << "PaintLayer(EnclosingLayerForPaintInvalidation) ? " << p_layer;
  // if (!p_layer) {
  //   return nullptr;
  // } 
  blink::GraphicsLayer* gr_layer = p_layer->GraphicsLayerBacking();
  //DLOG(INFO) << "GraphicsLayer ? " << gr_layer;
  if (!gr_layer) {
    return nullptr;
  }
  blink::WebLayer* web_layer = gr_layer->PlatformLayer();
  //DLOG(INFO) << "WebLayer ? " << web_layer;
  if (!web_layer) {
    return nullptr;
  }
  return web_layer->CcLayer() ? new _Layer(web_layer->CcLayer()) : nullptr;
}

WebNodeRef _WebNodeInsertBefore(WebNodeRef handle, WebNodeRef node, WebNodeRef anchor) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Node* res = ref->unwrap<blink::Node>()->insertBefore(
    reinterpret_cast<WebNodeWrapper *>(node)->unwrap<blink::Node>(),
    reinterpret_cast<WebNodeWrapper *>(anchor)->unwrap<blink::Node>());
  return new WebNodeWrapper(res);
}

WebNodeRef _WebNodeReplaceChild(WebNodeRef handle, WebNodeRef newChild, WebNodeRef old) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Node* res = ref->unwrap<blink::Node>()->replaceChild(
    reinterpret_cast<WebNodeWrapper *>(newChild)->unwrap<blink::Node>(),
    reinterpret_cast<WebNodeWrapper *>(old)->unwrap<blink::Node>());
  return new WebNodeWrapper(res);
}

WebNodeRef _WebNodeRemoveChild(WebNodeRef handle, WebNodeRef child) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Node* res = ref->unwrap<blink::Node>()->removeChild(
    reinterpret_cast<WebNodeWrapper *>(child)->unwrap<blink::Node>());
  return new WebNodeWrapper(res);
}

WebNodeRef _WebNodeAppendChild(WebNodeRef handle, WebNodeRef child) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Node* res = ref->unwrap<blink::Node>()->appendChild(
    reinterpret_cast<WebNodeWrapper *>(child)->unwrap<blink::Node>());
  return new WebNodeWrapper(res);
}

WebNodeRef _WebNodeClone(WebNodeRef handle, int deep) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Node* res = ref->unwrap<blink::Node>()->cloneNode(deep != 0);
  return new WebNodeWrapper(res);
}

int _WebNodeIsDescendantOf(WebNodeRef handle, WebNodeRef other) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->IsDescendantOf(
    reinterpret_cast<WebNodeWrapper *>(other)->constUnwrap<blink::Node>()) ? 1 : 0;
}

int _WebNodeContains(WebNodeRef handle, WebNodeRef other) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Node>()->contains(
    reinterpret_cast<WebNodeWrapper *>(other)->constUnwrap<blink::Node>()) ? 1 : 0;
}

int _WebNodeAddEventListener(WebNodeRef handle, const char* event_type, void* state, void(*on_event)(void*,void*)) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  AtomicString event_type_str = AtomicString::FromUTF8(event_type);
  //DLOG(INFO) << "WebNodeAddEventListener: state = " << state << " on_event =" << on_event;
  //application::ApplicationThread* app_thread = application::ApplicationThread::current();
  //DCHECK(app_thread);
  //scoped_refptr<base::SingleThreadTaskRunner> task_runner = app_thread->main_thread_runner();//base::ThreadTaskRunnerHandle::Get();
  // the event listener should be Gc'ed by oilpan
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);//std::move(task_runner), state, on_event);
  bool ok = ref->unwrap<blink::Node>()->addEventListener(event_type_str, listener);
  if (ok) {
    ref->AddListener(event_type, listener);
  }
  return ok ? 1 : 0;
}

int _WebNodeRemoveEventListener(WebNodeRef handle, const char* event_type, void* state) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebEventListenerImpl* listener = ref->RemoveListener(event_type);
  if (!listener) {
    return 0;
  }
  return ref->unwrap<blink::Node>()->removeEventListener(AtomicString::FromUTF8(event_type), listener) ? 1 : 0;
}

void _WebNodeRemoveAllEventListeners(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Node>()->RemoveAllEventListeners();
}

// WebDocument
const char* _WebDocumentTypeGetName(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char*>(ref->constUnwrap<blink::DocumentType>()->name().Characters8());
}

const char* _WebDocumentGetURL(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->Url().GetString().Characters8());
}

const char* _WebDocumentGetEncoding(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->EncodingName().Characters8());
}

const char* _WebDocumentGetContentLanguage(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->ContentLanguage().Characters8());
}

const char* _WebDocumentGetReferrer(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->referrer().Characters8());
}

WebLocalDomWindowRef _WebDocumentGetDomWindow(WebNodeRef handle) {
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return ref->constUnwrap<blink::Document>()->domWindow();
}

void _WebDocumentGetThemeColor(WebNodeRef handle, uint8_t* a, uint8_t* r, uint8_t* g, uint8_t* b) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::RGBA32 color = ref->constUnwrap<blink::Document>()->ThemeColor().Rgb();
  *a = static_cast<uint8_t>(blink::AlphaChannel(color));
  *r = static_cast<uint8_t>(blink::RedChannel(color));
  *g = static_cast<uint8_t>(blink::GreenChannel(color));
  *b = static_cast<uint8_t>(blink::BlueChannel(color));
}

const char* _WebDocumentOpenSearchDescriptionURL(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char*>(ref->unwrap<blink::Document>()->OpenSearchDescriptionURL().GetString().Characters8());
}

WebFrameRef _WebDocumentGetFrame(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 blink::LocalFrame* frame = ref->constUnwrap<blink::Document>()->GetFrame();
 // TODO: check if its refcounted, and if we need a propper wrapper to it
 return frame;
}

int _WebDocumentIsHTMLDocument(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsHTMLDocument() ? 1 : 0;
}

int _WebDocumentIsXHTMLDocument(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsXHTMLDocument() ? 1 : 0;
}

int _WebDocumentIsPluginDocument(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsPluginDocument() ? 1 : 0;
}

int _WebDocumentIsXMLDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsXMLDocument() ? 1 : 0;
}

int _WebDocumentIsImageDocument(WebNodeRef handle){
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsImageDocument() ? 1 : 0;
}

int _WebDocumentIsSVGDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsSVGDocument() ? 1 : 0;
}

int _WebDocumentIsMediaDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsMediaDocument() ? 1 : 0;
}

int _WebDocumentIsSrcdocDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsSrcdocDocument() ? 1 : 0;
}

int _WebDocumentIsMobileDocument(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Document>()->IsMobileDocument() ? 1 : 0;
}

const char* _WebDocumentGetBaseURL(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->BaseURL().GetString().Characters8());
}

WebNodeRef _WebDocumentGetDocumentElement(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->constUnwrap<blink::Document>()->documentElement();
  if (!element) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

WebNodeRef _WebDocumentGetBody(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLElement* element = ref->constUnwrap<blink::Document>()->body();
  if (!element) {
    return nullptr;
  }
  WebNodeWrapper* result = new WebNodeWrapper(element);
  result->set_is_html_element(true);
  return result;
}

WebNodeRef _WebDocumentGetHead(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLHeadElement* element = ref->constUnwrap<blink::Document>()->head();
  if (!element) {
    return nullptr;
  }
  WebNodeWrapper* result = new WebNodeWrapper(element);
  result->set_is_html_element(true);
  return result;
}

WebNodeRef _WebDocumentCreateElement(WebNodeRef handle, const char* tag_name) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(tag_name);
  blink::Element* element = ref->unwrap<blink::Document>()->CreateRawElement(blink::QualifiedName(g_null_atom, local_name, namespace_uri));
  if (!element) {
    return nullptr;
  }
  WebNodeWrapper* result = new WebNodeWrapper(element);
  return result;
}

const char* _WebDocumentGetTitle(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->title().Characters8());
}

HTMLCollectionRef _WebDocumentGetAll(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLAllCollection* elements = ref->unwrap<blink::Document>()->all();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetImages(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->images();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetEmbeds(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->embeds();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetApplets(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->applets();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetLinks(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->links();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetForms(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->forms();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetAnchors(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->anchors();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetScripts(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->scripts();
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements);
}

HTMLCollectionRef _WebDocumentGetElementsByTagName(WebNodeRef handle, const char* tag) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* elements = ref->unwrap<blink::Document>()->getElementsByTagName(tag);
  if (!elements) {
    return nullptr;
  }
  return new HTMLCollectionWrapper(elements); 
}

const char* _WebDocumentGetManifestURL(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLLinkElement* linkElement = ref->constUnwrap<blink::Document>()->LinkManifest();
  if (!linkElement) {
    return nullptr;
  }
  return reinterpret_cast<const char*>(linkElement->Href().GetString().Characters8());
}

int _WebDocumentManifestUseCredentials(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLLinkElement* linkElement = ref->constUnwrap<blink::Document>()->LinkManifest();
  if (!linkElement) {
    return 0;
  }
  return EqualIgnoringASCIICase(linkElement->FastGetAttribute(blink::HTMLNames::crossoriginAttr), "use-credentials") ? 1 : 0;  
} 

// const char*  _WebDocumentGetFirstPartyForCookies(WebNodeRef handle) {  
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   return reinterpret_cast<const char*>(ref->constUnwrap<blink::Document>()->FirstPartyForCookies().GetString().Characters8());
// }

WebNodeRef _WebDocumentGetFocusedElement(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->constUnwrap<blink::Document>()->FocusedElement();
  if(!element) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

WebNodeRef _WebDocumentGetDoctype(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return new WebNodeWrapper(ref->constUnwrap<blink::Document>()->doctype());
}

WebNodeRef _WebDocumentGetFullscreenElement(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* fullscreenElement = 0;
  
  blink::Fullscreen* fullscreen = blink::Fullscreen::FromIfExists(*ref->unwrap<blink::Document>());

  if (fullscreen) {
    fullscreenElement = fullscreen->FullscreenElement();
  }
  
  if (!fullscreenElement)
    return nullptr;

  return new WebNodeWrapper(fullscreenElement);
}

const char* _WebDocumentOutgoingReferrer(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char *>(ref->unwrap<blink::Document>()->OutgoingReferrer().Characters8());
}

WebNodeRef _WebDocumentGetAccessibilityObject(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::AXObjectCacheImpl* cache = blink::ToAXObjectCacheImpl(ref->unwrap<blink::Document>()->GetOrCreateAXObjectCache());
  return cache ? (new WebAXObjectWrapper(cache->GetOrCreate(ref->unwrap<blink::Document>()->GetLayoutView()))) : nullptr;
}

int _WebDocumentIsSecureContext(WebNodeRef handle, const char* cstr) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::Document* document = ref->constUnwrap<blink::Document>();
  if (!document) {
    return 0;
  }

  String message = String::FromUTF8(cstr);
  bool result = document->IsSecureContext(message);
  //errorMessage = message;
  return result ? 1 : 0;
}

WebNodeRef _WebDocumentForms(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCollection* forms = const_cast<blink::Document *>(ref->constUnwrap<blink::Document>())->forms();
  return new HTMLCollectionWrapper(forms);
}

const char* _WebDocumentCompleteURL(WebNodeRef handle, const char* cstr) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char *>(ref->constUnwrap<blink::Document>()->CompleteURL(cstr).GetString().Characters8());
}

WebNodeRef _WebDocumentGetElementById(WebNodeRef handle, const char* id) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 String str_id = String::FromUTF8(id);
 blink::Element* element = ref->constUnwrap<blink::Document>()->getElementById(id);
 if (element) {
   return new WebNodeWrapper(element);
 }
 return nullptr;
}

void _WebDocumentCancelFullScreen(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 blink::Fullscreen::FullyExitFullscreen(*ref->unwrap<blink::Document>());
}

WebAXObjectRef _WebDocumentAccessibilityObjectFromID(WebNodeRef handle, int id) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::Document* document = ref->constUnwrap<blink::Document>();
  blink::AXObjectCacheImpl* cache = blink::ToAXObjectCacheImpl(document->GetOrCreateAXObjectCache());
  return (cache != nullptr) ? (new WebAXObjectWrapper(cache->ObjectFromAXID(id))) : nullptr;
}

void _WebDocumentInsertStyleSheet(WebNodeRef handle, const char* keycstr, const char* cstr) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::WebString key = blink::WebString::FromUTF8(keycstr);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::CSSParserContext* parser_context = blink::CSSParserContext::Create(*document);
  blink::StyleSheetContents* parsedSheet = blink::StyleSheetContents::Create(parser_context);
  parsedSheet->ParseString(cstr);
  const blink::WebString& injection_key =
   !key.IsNull() ? key : GenerateStyleSheetKey();

  document->GetStyleEngine().InjectSheet(injection_key, parsedSheet, blink::WebDocument::kAuthorOrigin);
  // TODO: figure it out a way to pass the generated key to the caller
  // if he hasnt provided one
}

void _WebDocumentWatchCSSSelectors(WebNodeRef handle, const char* selectors[], int len) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::CSSSelectorWatch* watch = blink::CSSSelectorWatch::FromIfExists(*document);
  if (!watch && len == 0) {
   return;
  }
  Vector<String> webSelectors;
  for (int i = 0; i < len; ++i) {
    webSelectors[i] = selectors[i]; 
  }
  blink::CSSSelectorWatch::From(*document).WatchCSSSelectors(webSelectors);
}

JavascriptDataRef _WebDocumentRegisterEmbedderCustomElement(WebNodeRef handle, const char* name, JavascriptDataRef options, int* exception) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::NonThrowableExceptionState exceptionState;
  blink::ElementRegistrationOptions registrationOptions;
  v8::Local<v8::Value> v8options = reinterpret_cast<mumba::V8Value *>(handle)->GetLocal(isolate);
  blink::V8ElementRegistrationOptions::ToImpl(isolate, v8options, registrationOptions, exceptionState);
  if (exceptionState.HadException()) {
    return nullptr;
  }
  blink::ScriptValue constructor = document->registerElement(blink::ScriptState::Current(isolate), name, registrationOptions, exceptionState, blink::V0CustomElement::kEmbedderNames);
  *exception = exceptionState.Code();
  if (exceptionState.HadException()) {
      return nullptr;
  }
  return new mumba::V8Value(isolate, constructor.V8Value());
}

void _WebDocumentUpdateStyleAndLayoutTree(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  document->UpdateStyleAndLayoutTree();
}

void _WebDocumentUpdateStyleAndLayoutTreeIgnorePendingStylesheets(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  document->UpdateStyleAndLayoutTreeIgnorePendingStylesheets();
}

void _WebDocumentUpdateStyleAndLayoutTreeForNode(WebNodeRef handle, WebNodeRef node) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  blink::Document* document = ref->unwrap<blink::Document>();
  document->UpdateStyleAndLayoutTreeForNode(node_ref->unwrap<blink::Node>());
}

void _WebDocumentUpdateStyleAndLayout(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  document->UpdateStyleAndLayout();
}

WebSelectorQueryRef _WebDocumentQuerySelector(WebNodeRef handle, const char* query) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::CSSSelectorList selector_list = blink::CSSParser::ParseSelector(
      blink::CSSParserContext::Create(*document, blink::NullURL(), blink::kReferrerPolicyDefault,
                               WTF::TextEncoding(),
                               blink::CSSParserContext::kSnapshotProfile),
      nullptr, String::FromUTF8(query));
  std::unique_ptr<blink::SelectorQuery> sel_query = blink::SelectorQuery::Adopt(std::move(selector_list));
  return sel_query.release();
}

WebNodeRef _WebDocumentCreateTextNode(WebNodeRef handle, const char* text) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  return new WebNodeWrapper(document->createTextNode(String::FromUTF8(text))); 
}

WebRangeRef _WebDocumentGetCaretRangeFromPoint(WebNodeRef handle, int x, int y) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::Range* range = document->caretRangeFromPoint(x, y);
  return range ? new WebRangeWrapper(range) : nullptr;
}

WebNodeRef _WebDocumentGetScrollingElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::Element* element = document->ScrollingElementNoLayout();
  return element ? new WebNodeWrapper(element) : nullptr;
}

LocationRef _WebDocumentGetLocation(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  return document->location();
}

void _WebSelectorQueryDestroy(WebSelectorQueryRef handle) {
  delete reinterpret_cast<blink::SelectorQuery*>(handle);
}

WebNodeRef _WebSelectorQueryFirst(WebSelectorQueryRef handle, WebNodeRef container) {
  blink::SelectorQuery* query = reinterpret_cast<blink::SelectorQuery*>(handle);
  WebNodeWrapper* container_ref = reinterpret_cast<WebNodeWrapper *>(container);
  blink::ContainerNode* container_node = container_ref->unwrap<blink::ContainerNode>();
  blink::Element* elem = query->QueryFirst(*container_node);
  if (!elem) {
    return nullptr;
  }
  return new WebNodeWrapper(elem);
}

WebNodeRef _WebDocumentFragmentCreate(WebNodeRef document) {
  WebNodeWrapper* document_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::Document* document_node = document_ref->unwrap<blink::Document>();
  blink::DocumentFragment* fragment = blink::DocumentFragment::Create(*document_node);
  return new WebNodeWrapper(fragment);
}

int _WebDocumentFragmentIsTemplateContent(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::DocumentFragment* fragment = ref->unwrap<blink::DocumentFragment>();
  return fragment->IsTemplateContent() ? 1 : 0;
}

void _WebDocumentFragmentParseHTML(WebNodeRef handle, const char* html, WebNodeRef context) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* context_ref = reinterpret_cast<WebNodeWrapper *>(context);
  
  blink::DocumentFragment* fragment = ref->unwrap<blink::DocumentFragment>();
  fragment->ParseHTML(String::FromUTF8(html), context_ref->unwrap<blink::Element>());
}

int _WebDocumentFragmentParseXML(WebNodeRef handle, const char* xml, WebNodeRef context) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* context_ref = reinterpret_cast<WebNodeWrapper *>(context);
  
  blink::DocumentFragment* fragment = ref->unwrap<blink::DocumentFragment>();
  return fragment->ParseXML(String::FromUTF8(xml), context_ref->unwrap<blink::Element>()) ? 1 : 0;   
}

// WebDocumentLoader
WebURLRequestRef _WebDocumentLoaderGetRequest(WebDocumentLoaderRef handle) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  return new WebURLRequestWrapper(loader->GetRequest());
}

WebURLResponseRef _WebDocumentLoaderGetResponse(WebDocumentLoaderRef handle) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  return const_cast<blink::WebURLResponse *>(&loader->GetResponse()); 
}

int _WebDocumentLoaderHasUnreachableUrl(WebDocumentLoaderRef handle) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  return loader->HasUnreachableURL() ? 1 : 0;
}

char* _WebDocumentLoaderGetUrl(WebDocumentLoaderRef handle, int* len) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  const auto& url = loader->GetRequest().Url();
  char* result = (char*)malloc(url.GetString().Utf8().length());
  memcpy(result, url.GetString().Utf8().c_str(), url.GetString().Utf8().length());
  *len = url.GetString().Utf8().length();
  return result;
}

void _WebDocumentLoaderResetSourceLocation(WebDocumentLoaderRef handle) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  loader->ResetSourceLocation();
}

void _WebDocumentLoaderSetUserActivated(WebDocumentLoaderRef handle) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  loader->SetUserActivated();
}

void _WebDocumentLoaderSetServiceWorkerNetworkProvider(WebDocumentLoaderRef handle, WebServiceWorkerNetworkProviderRef provider) {
  DCHECK(provider);
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  WebServiceWorkerNetworkProviderImpl* network_provider = reinterpret_cast<WebServiceWorkerNetworkProviderImpl *>(provider);  
  std::unique_ptr<WebServiceWorkerNetworkProviderImpl> owned_provider(network_provider);
    // ServiceWorkerNetworkProvider::CreateForNavigation(
    //       routing_id_, navigation_state->request_params(), frame_,
    //       content_initiated, std::move(controller_service_worker_info_),
    //       std::move(fallback_factory))
  // int provider_id = request_params.service_worker_provider_id;
  // auto provider = base::WrapUnique(new ServiceWorkerNetworkProvider(
  //     route_id, blink::mojom::ServiceWorkerProviderType::kForWindow,
  //     provider_id, is_parent_frame_secure, std::move(controller_info),
  //     std::move(default_loader_factory)));
  owned_provider->set_owned(false);
  loader->SetServiceWorkerNetworkProvider(std::move(owned_provider));
}

void _WebDocumentLoaderSetNavigationStartTime(WebDocumentLoaderRef handle, int64_t microseconds) {
  blink::WebDocumentLoader* loader = reinterpret_cast<blink::WebDocumentLoader *>(handle);
  loader->SetNavigationStartTime(base::TimeTicks::FromInternalValue(microseconds));
}

// WebElement

int _WebElementIsFormControlElement(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return ref->constUnwrap<blink::Element>()->IsFormControlElement();
}

int _WebElementIsTextControlElement(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return ref->constUnwrap<blink::Element>()->IsTextControl();
}

int _WebElementIsEditable(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::Element* element = ref->constUnwrap<blink::Element>();
  
  element->GetDocument().UpdateStyleAndLayoutTree();
  if (blink::HasEditableStyle(*element))
    return true;

  if (auto* text_control = blink::ToTextControlOrNull(element)) {
    if (!text_control->IsDisabledOrReadOnly())
      return true;
  }

  return EqualIgnoringASCIICase(element->getAttribute(blink::HTMLNames::roleAttr), "textbox") ? 1 : 0;
}

int _WebElementIsHTMLElement(WebNodeRef handle) {
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 // internal
 return ref->is_html_element() ? 1 : 0;
}

const char* _WebElementGetTagName(WebNodeRef handle) {  
 WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
 return reinterpret_cast<const char *>(ref->constUnwrap<blink::Element>()->tagName().Characters8());
}

const char* _WebElementGetTextContext(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char *>(ref->constUnwrap<blink::Element>()->textContent().Characters8());
}

ImageRef _WebElementGetImageContents(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Image* image = ref->unwrap<blink::Element>()->ImageContents();
  if (image->IsNull()) {
    return nullptr;
  }
  blink::PaintImage paint_image = image->PaintImageForCurrentFrame();
  if (!paint_image)
    return nullptr;
 
  if (image->IsBitmapImage()) {
    blink::ImageOrientation orientation = blink::ToBitmapImage(image)->CurrentFrameOrientation();
    paint_image = blink::DragImage::ResizeAndOrientImage(paint_image, orientation);
    if (!paint_image)
      return nullptr;
  }

  sk_sp<SkImage> sk_image = paint_image.GetSkImage();
  if (!sk_image)
    return nullptr;

  return new SkiaImage(std::move(sk_image));
}

void _WebElementGetBoundsInViewportSpace(WebNodeRef handle, int* x, int* y, int* w, int* h) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::IntRect rect = ref->unwrap<blink::Element>()->BoundsInViewport();
  *x = rect.X();
  *y = rect.Y();
  *w = rect.Width();
  *h = rect.Height();
}

int _WebElementGetAttributeCount(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (!ref->constUnwrap<blink::Element>()->hasAttributes()) {
    return 0;
  }
  return ref->constUnwrap<blink::Element>()->Attributes().size();
}

int _WebElementHasNonEmptyLayoutSize(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::Element>()->HasNonEmptyLayoutSize();
}

int _WebElementHasTagName(WebNodeRef handle, const char* tagname) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::Element* element = ref->constUnwrap<blink::Element>();
  return blink::HTMLNames::xhtmlNamespaceURI == element->namespaceURI() && element->localName() == String(tagname).DeprecatedLower() ? 1 : 0;
}

int _WebElementHasAttribute(WebNodeRef handle, const char* attrname) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::Element>()->hasAttribute(attrname) ? 1 : 0;
}

void _WebElementRemoveAttribute(WebNodeRef handle, const char* attrname) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::Element>()->removeAttribute(attrname);
}

const char* _WebElementGetAttribute(WebNodeRef handle, const char* attrname) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return reinterpret_cast<const char *>(ref->constUnwrap<blink::Element>()->getAttribute(attrname).Characters8());
}

int _WebElementSetAttribute(WebNodeRef handle, const char* attrName, const char* attrValue) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::V0CustomElementProcessingStack::CallbackDeliveryScope deliver_custom_element_callbacks;
  blink::NonThrowableExceptionState exceptionState;
  ref->unwrap<blink::Element>()->setAttribute(attrName, attrValue, exceptionState);
  return !exceptionState.HadException(); 
}

int _WebElementGetIntegralAttribute(WebNodeRef handle, const char* name) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  return ref->unwrap<blink::Element>()->GetIntegralAttribute(qname);
}

void _WebElementSetIntegralAttribute(WebNodeRef handle, const char* name, int value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  ref->unwrap<blink::Element>()->SetIntegralAttribute(qname, value);
}

void _WebElementSetUnsignedIntegralAttribute(WebNodeRef handle, const char* name, unsigned value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  ref->unwrap<blink::Element>()->SetUnsignedIntegralAttribute(qname, value);
}

void _WebElementRequestFullscreen(WebNodeRef handle) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  blink::Fullscreen::RequestFullscreen(*element);
}

const char* _WebElementAttributeLocalName(WebNodeRef handle, int index) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  int count = _WebElementGetAttributeCount(handle);
  if (index >= count) {
    return nullptr;
  }
  return reinterpret_cast<const char *>(ref->constUnwrap<blink::Element>()->Attributes().at(index).LocalName().Characters8());
}

const char* _WebElementAttributeValue(WebNodeRef handle, int index) {  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  int count = _WebElementGetAttributeCount(handle);
  if (index >= count) {
    return nullptr;
  }
  return reinterpret_cast<const char *>(ref->constUnwrap<blink::Element>()->Attributes().at(index).Value().Characters8());
}

const char* _WebElementGetOuterHtml(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  return reinterpret_cast<const char *>(element->OuterHTMLAsString().Characters8());
}

void _WebElementSetOuterHtml(WebNodeRef handle, const char* html, int html_size) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exception_state(isolate, blink::ExceptionState::kSetterContext,
                                 "Element", "outerHTML");
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  String strValue = String::FromUTF8(html, html_size);
  element->SetOuterHTMLFromString(strValue, exception_state);
}

char* _WebElementGetInnerHtml(WebNodeRef handle, const char* cmp, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  String html = element->InnerHTMLAsString();
  if (html.length() == 0) {
    return nullptr;
  }
  // dont allocate/copy anything if they are the same
  if (strcmp(cmp, html.Utf8().data()) == 0) {
    return nullptr;
  }
  char* result = reinterpret_cast<char *>(malloc(html.length()));
  memcpy(result, html.Utf8().data(), html.length());
  *len = html.length();
  return result;
}

void _WebElementSetInnerHtml(WebNodeRef handle, const char* html, int html_size) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  String strValue = String::FromUTF8(html, html_size);
  element->SetInnerHTMLFromString(strValue);
}

WebNodeRef _WebElementGetShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  blink::Node* shadow_root = element->GetShadowRoot();
  if (shadow_root) {
    return new WebNodeWrapper(shadow_root);
  }
  return nullptr;
}

void _WebElementSetInlineStylePropertyDouble(WebNodeRef handle, const char* property, double value, int type) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  element->SetInlineStyleProperty(blink::cssPropertyID(String::FromUTF8(property)),
                                  value,
                                  static_cast<blink::CSSPrimitiveValue::UnitType>(type));
}

void _WebElementSetInlineStylePropertyString(WebNodeRef handle, const char* property, const char* value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  element->SetInlineStyleProperty(blink::cssPropertyID(String::FromUTF8(property)),
                                  String::FromUTF8(value));
}

int _WebElementRemoveInlineStyleProperty(WebNodeRef handle, const char* property) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  return element->RemoveInlineStyleProperty(AtomicString::FromUTF8(property)) ? 1 : 0;
}

void _WebElementRemoveAllInlineStyleProperties(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::Element* element = ref->unwrap<blink::Element>();
  element->RemoveAllInlineStyleProperties();
}

WebNodeRef _WebContainerNodeAppendChild(WebNodeRef handle, WebNodeRef child) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* child_ref = reinterpret_cast<WebNodeWrapper *>(child);
  blink::ContainerNode* node = ref->unwrap<blink::ContainerNode>();
  blink::Node* child_node = child_ref->unwrap<blink::Node>();
  blink::Node* result_node = node->AppendChild(child_node);
  if (result_node == child_node) {
    return child;
  }
  return new WebNodeWrapper(result_node);
}

WebNodeRef _WebContainerNodeRemoveChild(WebNodeRef handle, WebNodeRef child) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  WebNodeWrapper* child_ref = reinterpret_cast<WebNodeWrapper *>(child);
  blink::ContainerNode* node = ref->unwrap<blink::ContainerNode>();
  blink::Node* child_node = child_ref->unwrap<blink::Node>();
  blink::Node* result_node = node->RemoveChild(child_node);
  if (result_node == child_node) {
    return child;
  }
  return new WebNodeWrapper(result_node);
}

int _HTMLCollectionLenght(HTMLCollectionRef handle) {  
  HTMLCollectionWrapper* ref = reinterpret_cast<HTMLCollectionWrapper *>(handle);
  return ref->constUnwrap()->length();
}

int _HTMLCollectionIsEmpty(HTMLCollectionRef handle) {  
  HTMLCollectionWrapper* ref = reinterpret_cast<HTMLCollectionWrapper *>(handle);
  return ref->constUnwrap()->IsEmpty();
}

WebNodeRef _HTMLCollectionGetNextItem(HTMLCollectionRef handle) {  
  HTMLCollectionWrapper* ref = reinterpret_cast<HTMLCollectionWrapper *>(handle);
  blink::Element* element = ref->iterateNext();
  if (!element) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLCollectionGetFirstItem(HTMLCollectionRef handle) {  
  HTMLCollectionWrapper* ref = reinterpret_cast<HTMLCollectionWrapper *>(handle);
  blink::Element* element = ref->iterateFirst();
  if (!element) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLCollectionGetLastItem(HTMLCollectionRef handle) {  
  HTMLCollectionWrapper* ref = reinterpret_cast<HTMLCollectionWrapper *>(handle);
  blink::Element* element = ref->iterateLast();
  if (!element) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

void _HTMLCollectionDestroy(HTMLCollectionRef handle) {
 delete reinterpret_cast<HTMLCollectionWrapper *>(handle);
}

void _WebElementArrayDestroy(WebElementArrayRef handle) {
 delete reinterpret_cast<WebElementArrayWrapper *>(handle);
}

int _WebElementArrayLenght(WebElementArrayRef handle) {
  WebElementArrayWrapper* array = reinterpret_cast<WebElementArrayWrapper *>(handle);
  return array->constUnwrap()->length();
}

WebNodeRef _WebElementArrayGetElementAt(WebElementArrayRef handle, int index) {
  WebElementArrayWrapper* array = reinterpret_cast<WebElementArrayWrapper *>(handle);
  blink::Element* element = array->constUnwrap()->item(index);
  if (element == nullptr) {
    return nullptr;
  }
  return new WebNodeWrapper(element);
}

CSSStyleSheetListRef _WebShadowRootGetStyleSheetList(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::StyleSheetList& list = ref->unwrap<blink::ShadowRoot>()->StyleSheets();
  return &list;
}

void _WebShadowRootSetStyleSheetList(WebNodeRef handle, CSSStyleSheetListRef list) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::ShadowRoot>()->SetStyleSheets(reinterpret_cast<blink::StyleSheetList*>(list));
}

const char* _WebShadowRootGetInnerHtml(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String inner_html = ref->constUnwrap<blink::ShadowRoot>()->InnerHTMLAsString();
  // We have a lifetime problem here, and unless the inner buffer is borrowed
  // it will go away as soon this method returns
  return inner_html.Utf8().data();
}

void _WebShadowRootSetInnerHtml(WebNodeRef handle, const char* value, int size) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String inner_html = String::FromUTF8(value, size);
  ref->unwrap<blink::ShadowRoot>()->SetInnerHTMLFromString(inner_html);
}

WebNodeRef _WebElementCreateShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  //DLOG(INFO) << "_WebElementCreateShadowRoot: CreateShadowRootInternal() ..";
  blink::ShadowRoot& shadow_root = ref->unwrap<blink::Element>()->CreateShadowRootInternal();
  //DLOG(INFO) << "_WebElementCreateShadowRoot: returning ShadowRoot";
  return new WebNodeWrapper(&shadow_root);
}

WebNodeRef _WebElementCreateUserAgentShadowRoot(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::ShadowRoot& shadow_root = ref->unwrap<blink::Element>()->CreateUserAgentShadowRoot();
  return new WebNodeWrapper(&shadow_root);
}

void _WebElementAttachShadowRoot(WebNodeRef handle, int type) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::Element>()->AttachShadowRootInternal(static_cast<blink::ShadowRootType>(type));
}

const char* _WebFormElementGetAction(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormElement>()->action().Utf8().data();
}

const char* _WebFormElementGetName(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormElement>()->GetName().Utf8().data();
}

const char* _WebFormElementGetMethod(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormElement>()->method().Utf8().data();
}

// int _WebFormElementWasUserSubmitted(WebNodeRef handle) {
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   return ref->constUnwrap<blink::HTMLFormElement>()->WasUserSubmitted() ? 1 : 0;
// }

int _WebFormElementShouldAutoComplete(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormElement>()->ShouldAutocomplete();
}

void _WebFormElementGetNamedElements(WebNodeRef handle, const char* name, WebNodeRef* elementsOut, int* elemLen) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HeapVector<blink::Member<blink::Element>> nodes;
  
  ref->unwrap<blink::HTMLFormElement>()->GetNamedElements(blink::WebString::FromUTF8(name), nodes);
  
  *elemLen = nodes.size();

  for (size_t i = 0; i < nodes.size(); i++) {
    elementsOut[i] = new WebNodeWrapper(nodes[i]);
  }

}

// void _WebFormElementGetFormControlElements(WebNodeRef handle, WebNodeRef* elementsOut, int* elemLen) {
//   //Vector<blink::HTMLFormControlElement> nodes;
//   size_t count = 0;

//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
//   const blink::HTMLFormElement* form = ref->constUnwrap<blink::HTMLFormElement>();
  
//   const blink::FormAssociatedElement::List& associatedElements = form->AssociatedElements();
//   for (blink::FormAssociatedElement::List::const_iterator it = associatedElements.begin(); it != associatedElements.end(); ++it) {
//     if ((*it)->IsFormControlElement()) {
//      elementsOut[count] = new WebNodeWrapper((*it)->form());
//      count++;
//     }
//   }
 
//   *elemLen = count;
// }

int _WebFormElementCheckValidity(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->unwrap<blink::HTMLFormElement>()->checkValidity() ? 1 : 0; 
}

// void _WebFormElementFinishRequestAutocomplete(WebNodeRef handle, int autocomplete) {
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   ref->unwrap<blink::HTMLFormElement>()->FinishRequestAutocomplete(static_cast<blink::HTMLFormElement::AutocompleteResult>(autocomplete));
// }

int _WebFormControlElementIsEnabled(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return !ref->constUnwrap<blink::HTMLFormControlElement>()->IsDisabledFormControl() ? 1 : 0;
}

int _WebFormControlElementIsReadonly(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormControlElement>()->IsReadOnly() ? 1 : 0;
}

const char* _WebFormControlElementGetFormControlName(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormControlElement>()->GetName().Utf8().data();
}

const char* _WebFormControlElementGetFormControlType(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormControlElement>()->type().Utf8().data();
}

int _WebFormControlElementIsAutofilled(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormControlElement>()->IsAutofilled() ? 1 : 0;
}

void _WebFormControlElementSetIsAutofilled(WebNodeRef handle, int autofilled) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  ref->unwrap<blink::HTMLFormControlElement>()->SetAutofilled(autofilled == 0 ? false : true);
}

int _WebFormControlElementShouldAutocomplete(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  if (blink::IsHTMLInputElement(*ref)) {
      return ref->constUnwrap<blink::HTMLInputElement>()->ShouldAutocomplete() ? 1 : 0;
  }
  if (blink::IsHTMLTextAreaElement(*ref)) {
      return ref->constUnwrap<blink::HTMLTextAreaElement>()->ShouldAutocomplete() ? 1 : 0;
  }
  return 0;
}

const char* _WebFormControlElementGetValue(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (blink::IsHTMLInputElement(*ref)) {
      return ref->constUnwrap<blink::HTMLInputElement>()->value().Utf8().data();
  }
  if (blink::IsHTMLTextAreaElement(*ref)) {
      return ref->constUnwrap<blink::HTMLTextAreaElement>()->value().Utf8().data();
  }
  if (blink::IsHTMLSelectElement(*ref)) {
      return ref->constUnwrap<blink::HTMLSelectElement>()->value().Utf8().data();
  }
  
  return nullptr;
}

void _WebFormControlElementSetValue(WebNodeRef handle, const char* value) {
  bool sendEvents = false;
  
  String strValue = String::FromUTF8(value);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (blink::IsHTMLInputElement(*ref)) {
      ref->unwrap<blink::HTMLInputElement>()->setValue(strValue, sendEvents ? blink::kDispatchInputAndChangeEvent : blink::kDispatchNoEvent);
  } else if (blink::IsHTMLTextAreaElement(*ref)) {
      ref->unwrap<blink::HTMLTextAreaElement>()->setValue(strValue, sendEvents ? blink::kDispatchInputAndChangeEvent : blink::kDispatchNoEvent);
  } else if (blink::IsHTMLSelectElement(*ref)) {
      ref->unwrap<blink::HTMLSelectElement>()->setValue(strValue, sendEvents);
  }
}

const char* _WebFormControlElementGetSuggestedValue(WebNodeRef handle) {
  
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);

  if (blink::IsHTMLInputElement(*ref)) {
    return ref->constUnwrap<blink::HTMLInputElement>()->SuggestedValue().Utf8().data();
  }
  
  if (blink::IsHTMLTextAreaElement(*ref)) {
    return ref->constUnwrap<blink::HTMLTextAreaElement>()->SuggestedValue().Utf8().data();
  }
  
  if (blink::IsHTMLSelectElement(*ref)) {
    return ref->constUnwrap<blink::HTMLSelectElement>()->SuggestedValue().Utf8().data();
  }
  
  return nullptr;
}

void _WebFormControlElementSetSuggestedValue(WebNodeRef handle, const char* value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  String strValue = String::FromUTF8(value);

  if (blink::IsHTMLInputElement(*ref)) {
      ref->unwrap<blink::HTMLInputElement>()->SetSuggestedValue(strValue);
  } else if (blink::IsHTMLTextAreaElement(*ref)) {
      ref->unwrap<blink::HTMLTextAreaElement>()->SetSuggestedValue(strValue);
  } else if (blink::IsHTMLSelectElement(*ref)) {
      ref->unwrap<blink::HTMLSelectElement>()->SetSuggestedValue(strValue);
  }

}

const char* _WebFormControlElementGetEditingValue(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (blink::IsHTMLInputElement(*ref)) {
    return ref->constUnwrap<blink::HTMLInputElement>()->InnerEditorValue().Utf8().data();
  } 
  
  if (blink::IsHTMLTextAreaElement(*ref)) {
    return ref->constUnwrap<blink::HTMLTextAreaElement>()->InnerEditorValue().Utf8().data();
  }

  return nullptr;
}

int _WebFormControlElementGetSelectionStart(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  
  if (blink::IsHTMLInputElement(*ref)) {
    return ref->constUnwrap<blink::HTMLInputElement>()->selectionStart();
  }
  
  if (blink::IsHTMLTextAreaElement(*ref)) {
    return ref->constUnwrap<blink::HTMLTextAreaElement>()->selectionStart();
  }

  return 0;
}

int _WebFormControlElementGetSelectionEnd(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);

  if (blink::IsHTMLInputElement(*ref)) {
    return ref->constUnwrap<blink::HTMLInputElement>()->selectionEnd();
  }
  
  if (blink::IsHTMLTextAreaElement(*ref)) {
    return ref->constUnwrap<blink::HTMLTextAreaElement>()->selectionEnd();
  }

  return 0;
}

const char* _WebFormControlElementGetDirectionForFormData(WebNodeRef handle) {
  // GetComputedStyle() is inlined, so we dont have access here
  // when is a shared dll build
  
  // we may use a conditional macro here

  //WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  //if (const blink::ComputedStyle* style =
  //        ref->constUnwrap<blink::HTMLFormControlElement>()->GetComputedStyle()) {
  //  return style->IsLeftToRightDirection() ? kLTRString
  //                                         : kRTLString;
  //}
  return kLTRString;
}

const char* _WebFormControlElementGetNameForAutofill(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFormControlElement>()->NameForAutofill().Utf8().data();
}

WebNodeRef _WebFormControlElementGetForm(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return new WebNodeWrapper(ref->constUnwrap<blink::HTMLFormControlElement>()->Form());
}

void _WebFormControlElementSetSelectionRange(WebNodeRef handle, int start, int end) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);

  if (blink::IsHTMLInputElement(*ref)) {
      ref->unwrap<blink::HTMLInputElement>()->SetSelectionRange(start, end);
  } else if (blink::IsHTMLTextAreaElement(*ref)) {
      ref->unwrap<blink::HTMLTextAreaElement>()->SetSelectionRange(start, end);
  }

}

WebNodeRef _HTMLAnchorElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLAnchorElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLAreaElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLAreaElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLAudioElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLAudioElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLBaseElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLBaseElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLBodyElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLBodyElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLBrElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLBRElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLContentElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLContentElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLDataElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLDataElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLDetailsElementCreate(WebNodeRef document) {
//    WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//    auto* element = blink::HTMLDetailsElement::Create(*doc_ref->unwrap<blink::Document>());
//    return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLDialogElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLDialogElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLDirectoryElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLDirectoryElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLDlistElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLDListElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

//WebNodeRef _HTMLDocumentCreate(WebNodeRef document) {
//  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//  auto* element = blink::HTMLDocument::Create(*doc_ref->unwrap<blink::Document>());
//  return new WebNodeWrapper(element);
//}

WebNodeRef _HTMLEmbedElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLEmbedElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLFontElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLFontElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLFrameOwnerElementCreate(const char* name, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName owner_name(g_null_atom, local_name, namespace_uri);
  auto* element = blink::HTMLFrameOwnerElement::Create(owner_name, *doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLFrameSetElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLFrameSetElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLHeadElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLHeadElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLHeadingElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLHeadingElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLHrElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLHRElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLHtmlElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLHtmlElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLIFrameElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLIFrameElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLLiElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLLIElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLLinkElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  CreateElementFlags flags;
  auto* element = blink::HTMLLinkElement::Create(*doc_ref->unwrap<blink::Document>(), flags);
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLMapElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLMapElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLMarqueeElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLMarqueeElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLMediaElementCreate(const char* name, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  auto* element = blink::HTMLMediaElement::Create(qname, *doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLMenuElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLMenuElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLMetaElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLMetaElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLMeterElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLMeterElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLModElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLModElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLNoEmbedElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLNoEmbedElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLNoScriptElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLNoScriptElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLObjectElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  CreateElementFlags flags;
  auto* element = blink::HTMLObjectElement::Create(*doc_ref->unwrap<blink::Document>(), flags);
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLOlistElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLOListElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLParagraphElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLParagraphElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLParamElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLParamElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLPictureElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLPictureElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLPluginElementCreate(const char* name, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  auto* element = blink::HTMLPlugInElement::Create(qname, *doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLPreElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLPreElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLProgressElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLProgressElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLQuoteElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLQuoteElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLRtElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLRTElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLRubyElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLRubyElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLScriptElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  CreateElementFlags flags;
  auto* element = blink::HTMLScriptElement::Create(*doc_ref->unwrap<blink::Document>(), flags);
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLShadowElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLShadowElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLSlotElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLSlotElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLSourceElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLSourceElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLSpanElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLSpanElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLStyleElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  CreateElementFlags flags;
  auto* element = blink::HTMLStyleElement::Create(*doc_ref->unwrap<blink::Document>(), flags);
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLSummaryElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLSummaryElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLTableCaptionElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLTableCaptionElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLTableCellElementCreate(const char* name, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  auto* element = blink::HTMLTableCellElement::Create(qname, *doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLTableColElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLTableColElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLTableElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLTableElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLTablePartElementCreate(const char* name, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
  AtomicString local_name = AtomicString::FromUTF8(name);
  blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
  auto* element = blink::HTMLTablePartElement::Create(qname, *doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

WebNodeRef _HTMLTableRowElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLTableRowElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

//WebNodeRef _HTMLTableRowsCollectionCreate(WebNodeRef document) {
//  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//  auto* element = blink::HTMLTableRowsCollection::Create(*doc_ref->unwrap<blink::Document>());
//  return new WebNodeWrapper(element);
//}

// WebNodeRef _HTMLTableSectionElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLTableSectionElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

//WebNodeRef _HTMLTagCollectionCreate(WebNodeRef document) {
//  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//  auto* element = blink::HTMLTagCollection::Create(*doc_ref->unwrap<blink::Document>());
//  return new WebNodeWrapper(element);
//}

WebNodeRef _HTMLTimeElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLTimeElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

// WebNodeRef _HTMLTitleElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLTitleElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLUlistElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLUListElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

// WebNodeRef _HTMLUnknownElementCreate(const char* name, WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   AtomicString namespace_uri = blink::HTMLNames::xhtmlNamespaceURI;
//   AtomicString local_name = AtomicString::FromUTF8(name);
//   blink::QualifiedName qname(g_null_atom, local_name, namespace_uri);
//   auto* element = blink::HTMLUnknownElement::Create(qname, *doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLVideoElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  auto* element = blink::HTMLVideoElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(element);
}

int _HTMLVideoElementGetVideoWidth(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->videoWidth();
}

int _HTMLVideoElementGetVideoHeight(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->videoHeight();
}

void _HTMLVideoElementGetVisibleSize(WebNodeRef reference, int* w, int* h) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  blink::IntSize size = element->videoVisibleSize();
  *w = size.Width();
  *h = size.Height();
}

char* _HTMLVideoElementGetPoster(WebNodeRef reference, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  String str = element->GetURLAttribute(blink::HTMLNames::posterAttr);
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

void _HTMLVideoElementGetPlaybackQuality(WebNodeRef reference, double* creation, int* total, int* dropped, int* corrupted) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  blink::VideoPlaybackQuality* quality = blink::HTMLVideoElementMediaSource::getVideoPlaybackQuality(*element);
  if (!quality) {
    //DLOG(ERROR) << "HTMLVideoElementGetPlaybackQuality: warning: no video playback quality. cancelling";
    return;
  }
  *creation = quality->creationTime();
  *total = quality->totalVideoFrames();
  *dropped = quality->droppedVideoFrames();
  *corrupted = quality->corruptedVideoFrames();
}

int _HTMLVideoElementSupportsFullscreen(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->webkitSupportsFullscreen();
}

int _HTMLVideoElementDisplayingFullscreen(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->webkitDisplayingFullscreen();
}

  // Statistics

uint64_t _HTMLVideoElementGetDecodedFrameCount(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->webkitDecodedFrameCount();
}

uint64_t _HTMLVideoElementGetDroppedFrameCount(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  return element->webkitDroppedFrameCount();
}

void _HTMLVideoElementEnterFullscreen(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  element->webkitEnterFullscreen();
}

void _HTMLVideoElementExitFullscreen(WebNodeRef reference) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  element->webkitExitFullscreen();
}

void _HTMLVideoElementPaintCurrentFrame(
  WebNodeRef reference, 
  CanvasRenderingContext2dRef canvas, 
  int rx,
  int ry,
  int rw,
  int rh,
  PaintFlagsRef paint) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(reference);
  blink::HTMLVideoElement* element = ref->unwrap<blink::HTMLVideoElement>();
  blink::PaintCanvas* web_canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(canvas));
  element->PaintCurrentFrame(
    web_canvas,
    blink::IntRect(rx, ry, rw, rh),
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr);
}

// WebNodeRef _HTMLWbrElementCreate(WebNodeRef document) {
//   WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
//   auto* element = blink::HTMLWBRElement::Create(*doc_ref->unwrap<blink::Document>());
//   return new WebNodeWrapper(element);
// }

WebNodeRef _HTMLFormElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLFormElement* form_element = blink::HTMLFormElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(form_element);
}

WebNodeRef _HTMLTemplateElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLTemplateElement* canvas_element = blink::HTMLTemplateElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(canvas_element);
}

WebNodeRef _HTMLTemplateElementGetContent(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::DocumentFragment* fragment = ref->unwrap<blink::HTMLTemplateElement>()->content();
  return new WebNodeWrapper(fragment);
}

int _HTMLFrameElementGetHasFrameBorder(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFrameElement>()->HasFrameBorder() ? 1 : 0;
}

int _HTMLFrameElementGetNoResize(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  return ref->constUnwrap<blink::HTMLFrameElement>()->NoResize() ? 1 : 0;
}

WebNodeRef _HTMLCanvasElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLCanvasElement* canvas_element = blink::HTMLCanvasElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(canvas_element);
}

void _HTMLCanvasElementGetSize(WebNodeRef handle, int* width, int* height) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  const blink::IntSize& size = ref->constUnwrap<blink::HTMLCanvasElement>()->Size();
  *width = size.Width(); 
  *height = size.Height();
}

void _HTMLCanvasElementSetSize(WebNodeRef handle, int width, int height) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  canvas_element->SetSize(blink::IntSize(width, height));
}

LayerRef _HTMLCanvasElementGetLayer(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::WebLayer* web_layer = ref->unwrap<blink::HTMLCanvasElement>()->GetOrCreateCanvas2DLayerBridge()->Layer();
  if (!web_layer) {
    //DLOG(INFO) << "BAD. no web layer found on canvas";
    return nullptr;
  }
  DCHECK(web_layer->CcLayer());
  return new _Layer(web_layer->CcLayer());
}

CanvasRenderingContext2dRef _HTMLCanvasElementCreateContext(WebNodeRef handle, const char* type) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::CanvasContextCreationAttributesCore attr;
  blink::CanvasRenderingContext* context = canvas_element->GetCanvasRenderingContext(
    String::FromUTF8(type),
    attr);
  return context;
}

OffscreenCanvasRef _HTMLCanvasElementTransferControlToOffscreen(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exception_state(isolate, blink::ExceptionState::kGetterContext, "HTMLCanvasElement", "TransferControlToOffscreen");
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::OffscreenCanvas* canvas = blink::HTMLCanvasElementModule::transferControlToOffscreen(*canvas_element, exception_state);
  //canvas->setWidth(canvas_element->width());
  //canvas->setHeight(canvas_element->height());
  return new OffscreenCanvasWrapper(canvas);
}

WebNodeRef _HTMLFrameElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLFrameElement* frame_element = blink::HTMLFrameElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(frame_element);
}

WebNodeRef _HTMLDivElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLDivElement* div_element = blink::HTMLDivElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(div_element);
}

WebNodeRef _HTMLImageElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::HTMLImageElement* image_element = blink::HTMLImageElement::Create(*doc_ref->unwrap<blink::Document>());
  return new WebNodeWrapper(image_element);
}

int _HTMLImageElementGetX(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->x();
}

int _HTMLImageElementGetY(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->y();
}

int _HTMLImageElementGetWidth(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->width();
}

void _HTMLImageElementSetWidth(WebNodeRef handle, int width) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  image_element->setWidth(width);
}

int _HTMLImageElementGetHeight(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->height();
}

void _HTMLImageElementSetHeight(WebNodeRef handle, int height) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->setHeight(height);
}

int _HTMLImageElementGetNaturalWidth(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->naturalWidth();
}

int _HTMLImageElementGetNaturalHeight(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->naturalHeight();
}

int _HTMLImageElementGetLayoutBoxWidth(WebNodeRef handle) { 
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->LayoutBoxWidth();
}

int _HTMLImageElementGetLayoutBoxHeight(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->LayoutBoxHeight();
}

char* _HTMLImageElementGetCurrentSrc(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  const String& str = image_element->currentSrc();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

int _HTMLImageElementIsServerMap(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->IsServerMap();
}

char* _HTMLImageElementGetAltText(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  String str = image_element->AltText();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

ImageRef _HTMLImageElementGetImage(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  if (!image_element->complete()) {
    //DLOG(INFO) << "_HTMLImageElementGetImage: not complete. returning null";
    return nullptr;
  }
  blink::Image* blink_image = image_element->CachedImage()->GetImage();
  if (blink_image->IsNull()) {
    //DLOG(INFO) << "_HTMLImageElementGetImage: CachedImage()->GetImage()->IsNull() = true. returning null";
    return nullptr;
  }
  blink::PaintImage paint_image = blink_image->PaintImageForCurrentFrame();
  if (!paint_image) {
    //DLOG(INFO) << "_HTMLImageElementGetImage: image->PaintImageForCurrentFrame() is null. returning null";
    return nullptr;
  }
 
  if (blink_image->IsBitmapImage()) {
    blink::ImageOrientation orientation = blink::ToBitmapImage(blink_image)->CurrentFrameOrientation();
    paint_image = blink::DragImage::ResizeAndOrientImage(paint_image, orientation);
    if (!paint_image) {
      //DLOG(INFO) << "_HTMLImageElementGetImage: blink::DragImage::ResizeAndOrientImage() return null. returning null";
      return nullptr;
    }
  }

  sk_sp<SkImage> sk_image = paint_image.GetSkImage();
  if (!sk_image) {
    //DLOG(INFO) << "_HTMLImageElementGetImage: paint_image.GetSkImage() is null. returning null";
    return nullptr;
  }

  return new SkiaImage(std::move(sk_image));
}

void _HTMLImageElementSetImage(WebNodeRef handle, ImageRef image) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  sk_sp<SkImage> sk_image = reinterpret_cast<SkiaImage*>(image)->ref();
  blink::ImageResourceContent* image_content =
      blink::ImageResourceContent::CreateLoaded(
          blink::StaticBitmapImage::Create(sk_image).get());
  image_element->SetImageForTest(image_content);
}

int _HTMLImageElementIsLoaded(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::ImageResourceContent* image_resource = image_element->CachedImage();
  if (!image_resource) {
    return 0;
  }
  return image_resource->IsLoaded();
}

int _HTMLImageElementIsLoading(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::ImageResourceContent* image_resource = image_element->CachedImage();
  if (!image_resource) {
    return 0;
  }
  return image_resource->IsLoading();
}

int _HTMLImageElementErrorOccurred(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::ImageResourceContent* image_resource = image_element->CachedImage();
  if (!image_resource) {
    return 0;
  }
  return image_resource->ErrorOccurred();
}

int _HTMLImageElementLoadFailedOrCancelled(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::ImageResourceContent* image_resource = image_element->CachedImage();
  if (!image_resource) {
    return 0;
  }
  return image_resource->LoadFailedOrCanceled();
}

char* _HTMLImageElementGetSrc(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  String str = image_element->getAttribute(blink::HTMLNames::srcAttr);
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

void _HTMLImageElementSetSrc(WebNodeRef handle, const char* src) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  image_element->SetSrc(String::FromUTF8(src));
}

int _HTMLImageIsComplete(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->complete() ? 1 : 0;
}

int _HTMLImageHasPendingActivity(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->HasPendingActivity() ? 1 : 0;
}

int _HTMLImageCanContainRangeEndPoint(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->CanContainRangeEndPoint() ? 1 : 0;
}

int _HTMLImageIsCollapsed(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return image_element->IsCollapsed() ? 1 : 0;
}

WebNodeRef _HTMLImageElementGetFormOwner(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::HTMLFormElement* form_element = image_element->formOwner();
  if (!form_element) {
    return nullptr;
  }
  return new WebNodeWrapper(form_element); 
}

void _HTMLImageSetIsFallbackImage(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  image_element->SetIsFallbackImage();
}

void _HTMLImageForceReload(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  image_element->ForceReload();
}

double _HTMLMediaElementGetEffectiveMediaVolume(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->EffectiveMediaVolume();
}

int _HTMLMediaElementIsHtmlAudioElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->IsHTMLAudioElement() ? 1 : 0;
}

int _HTMLMediaElementIsHtmlVideoElement(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->IsHTMLVideoElement() ? 1 : 0;
}

int _HTMLMediaElementGetLoadType(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return static_cast<int>(element->GetLoadType());
}

int _HTMLMediaElementHasMediaSource(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->HasMediaSource() ? 1 : 0;
}

int _HTMLMediaElementHasVideo(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->HasVideo() ? 1 : 0;
}

int _HTMLMediaElementHasAudio(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->HasAudio() ? 1 : 0;
}

LayerRef _HTMLMediaElementGetWebLayer(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::WebLayer* layer = element->PlatformLayer();
  if (!layer) {
    return nullptr;
  }
  return new _Layer(layer->CcLayer());
}

int _HTMLMediaElementHasRemoteRoutes(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->HasRemoteRoutes() ? 1 : 0;
}

int _HTMLMediaElementIsPlayingRemotely(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->IsPlayingRemotely() ? 1 : 0;
}

int _HTMLMediaElementGetReadyState(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return static_cast<int>(element->getReadyState());
}

int _HTMLMediaElementIsSeeking(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->seeking() ? 1 : 0;
}

void _HTMLMediaElementGetPlayed(WebNodeRef handle, int* len, double** start, double** end) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::TimeRanges* ranges = element->played();
  if (!ranges) {
    *len = 0;
    return;
  }
  *len = ranges->length();
  if (ranges->length() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  blink::NonThrowableExceptionState exceptionState;
  for (unsigned i = 0; i < ranges->length(); i++) {
    *start[i] = ranges->start(i, exceptionState);
    *end[i] = ranges->end(i, exceptionState);
  }
}

void _HTMLMediaElementGetSeekable(WebNodeRef handle, int* len, double** start, double** end) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::TimeRanges* ranges = element->seekable();
  if (!ranges) {
    *len = 0;
    return;
  }
  *len = ranges->length();
  if (ranges->length() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  blink::NonThrowableExceptionState exceptionState;
  for (unsigned i = 0; i < ranges->length(); i++) {
    *start[i] = ranges->start(i, exceptionState);
    *end[i] = ranges->end(i, exceptionState);
  }
}

int _HTMLMediaElementEnded(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->ended() ? 1 : 0;
}

double _HTMLMediaElementGetCurrentTime(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->currentTime();
}

void _HTMLMediaElementSetCurrentTime(WebNodeRef handle, double value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->setCurrentTime(value);
}

double _HTMLMediaElementGetDuration(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->duration();
}

int _HTMLMediaElementIsPaused(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->paused() ? 1 : 0;
}

double _HTMLMediaElementGetDefaultPlaybackRate(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->defaultPlaybackRate();
}

void _HTMLMediaElementSetDefaultPlaybackRate(WebNodeRef handle, double value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->setDefaultPlaybackRate(value);
}

double _HTMLMediaElementGetPlaybackRate(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->playbackRate();
}

void _HTMLMediaElementSetPlaybackRate(WebNodeRef handle, double value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->setPlaybackRate(value);
}

void* _HTMLMediaElementGetError(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->error();
}

char* _HTMLMediaElementGetSrc(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  const String& str = element->currentSrc().GetString();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

void _HTMLMediaElementSetSrc(WebNodeRef handle, const char* src) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->SetSrc(AtomicString::FromUTF8(src));
}

void* _HTMLMediaElementGetSrcObject(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->GetSrcObject();
}

void _HTMLMediaElementSetSrcObject(WebNodeRef handle, WebMediaStreamDescriptorRef src) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->SetSrcObject(reinterpret_cast<blink::MediaStreamDescriptor*>(src));
}

int _HTMLMediaElementGetNetworkState(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->getNetworkState();
}

char* _HTMLMediaElementGetPreload(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  const String& str = element->currentSrc().GetString();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

void _HTMLMediaElementSetPreload(WebNodeRef handle, const char* value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->setPreload(AtomicString::FromUTF8(value));
}

int _HTMLMediaElementGetPreloadType(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->PreloadType();
}

char* _HTMLMediaElementGetEffectivePreload(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  String str = element->EffectivePreload();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

int _HTMLMediaElementGetEffectivePreloadType(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return static_cast<int>(element->EffectivePreloadType());
}

void _HTMLMediaElementGetBuffered(WebNodeRef handle, int* len, double** start, double** end) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::TimeRanges* ranges = element->buffered();
  if (!ranges) {
    *len = 0;
    return;
  }
  *len = ranges->length();
  if (ranges->length() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  blink::NonThrowableExceptionState exceptionState;
  for (unsigned i = 0; i < ranges->length(); i++) {
    *start[i] = ranges->start(i, exceptionState);
    *end[i] = ranges->end(i, exceptionState);
  }
}

int _HTMLMediaElementAutoplay(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->Autoplay() ? 1 : 0;
}

// int _HTMLMediaElementShouldAutoplay(WebNodeRef handle) {
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
//   return element->ShouldAutoplay() ? 1 : 0;
// }

int _HTMLMediaElementGetLoop(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->Loop() ? 1 : 0;
}

void _HTMLMediaElementSetLoop(WebNodeRef handle, int value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->SetLoop(value != 0);
}

int _HTMLMediaElementGetAudioDecodedByteCount(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->webkitAudioDecodedByteCount();
}

int _HTMLMediaElementGetVideoDecodedByteCount(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->webkitVideoDecodedByteCount();
}

int _HTMLMediaElementIsInCrossOriginFrame(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->IsInCrossOriginFrame();
}

double _HTMLMediaElementGetVolume(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->volume();
}

void _HTMLMediaElementSetVolume(WebNodeRef handle, double value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->setVolume(value);
}

int _HTMLMediaElementGetMuted(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->muted() ? 1 : 0;
}

void _HTMLMediaElementSetMuted(WebNodeRef handle, int value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->setMuted(value);
}

int _HTMLMediaElementIsFullscreen(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->IsFullscreen() ? 1 : 0;
}

int _HTMLMediaElementUsesOverlayFullscreenVideo(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->UsesOverlayFullscreenVideo() ? 1 : 0;
}

int _HTMLMediaElementHasClosedCaptions(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->HasClosedCaptions() ? 1 : 0;
}

int _HTMLMediaElementTextTracksVisible(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->TextTracksVisible() ? 1 : 0;
}

MediaControlsRef _HTMLMediaElementGetMediaControls(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->GetMediaControls();
}

MediaAudioSourceNodeRef _HTMLMediaElementGetAudioSourceNode(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->AudioSourceNode();
}

void _HTMLMediaElementSetAudioSourceNode(WebNodeRef handle, MediaAudioSourceNodeRef node) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->SetAudioSourceNode(reinterpret_cast<blink::AudioSourceProviderClient*>(node)); 
}

void* _HTMLMediaElementGetControlsList(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->controlsList();
}

int _HTMLMediaElementSupportsPictureInPicture(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->SupportsPictureInPicture();
}

double _HTMLMediaElementLastSeekTime(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->LastSeekTime();
}

AudioTrackRef* _HTMLMediaElementGetAudioTracks(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::AudioTrackList& tracks = element->audioTracks();
  *len = tracks.length();
  if (tracks.length() == 0) {
    return nullptr;
  }
  AudioTrackRef* result = reinterpret_cast<AudioTrackRef*>(malloc(sizeof(blink::AudioTrack) * tracks.length())); 
  for (unsigned i = 0; i < tracks.length(); ++i) {
    result[i] = tracks.AnonymousIndexedGetter(i);
  }
  return result;
}

VideoTrackRef* _HTMLMediaElementGetVideoTracks(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::VideoTrackList& tracks = element->videoTracks();
  *len = tracks.length();
  if (tracks.length() == 0) {
    return nullptr;
  }
  VideoTrackRef* result = reinterpret_cast<VideoTrackRef*>(malloc(sizeof(blink::VideoTrack) * tracks.length())); 
  for (unsigned i = 0; i < tracks.length(); ++i) {
    result[i] = tracks.AnonymousIndexedGetter(i);
  }
  return result;
}

TextTrackRef* _HTMLMediaElementGetTextTracks(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::TextTrackList* tracks = element->textTracks();
  if (!tracks) {
    *len = 0;
    return nullptr;
  }
  *len = tracks->length();
  if (tracks->length() == 0) {
    return nullptr;
  }
  TextTrackRef* result = reinterpret_cast<TextTrackRef*>(malloc(sizeof(blink::AudioTrack) * tracks->length())); 
  for (unsigned i = 0; i < tracks->length(); ++i) {
    result[i] = tracks->AnonymousIndexedGetter(i);
  }
  return result;
}

CueTimelineRef _HTMLMediaElementGetCueTimeline(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return &element->GetCueTimeline();
}

int _HTMLMediaElementTextTracksAreReady(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->TextTracksAreReady() ? 1 : 0;
}

int _HTMLMediaElementShouldShowControls(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  return element->ShouldShowControls() ? 1 : 0;
}

void _HTMLMediaElementScheduleTextTrackResourceLoad(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->ScheduleTextTrackResourceLoad();
}

void _HTMLMediaElementLoad(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->load();
}

char* _HTMLMediaElementCanPlayType(WebNodeRef handle, const char* mime, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  String str = element->canPlayType(String::FromUTF8(mime));
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  *len = str.length();
  return result;
}

void _HTMLMediaElementUpdatePlaybackRate(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->UpdatePlaybackRate();
}

void _HTMLMediaElementPlay(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->Play();
}

void _HTMLMediaElementPause(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->Pause();
}

void _HTMLMediaElementRequestRemotePlayback(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->RequestRemotePlayback();
}

void _HTMLMediaElementRequestRemotePlaybackControl(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->RequestRemotePlaybackControl();
}

void _HTMLMediaElementRequestRemotePlaybackStop(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->RequestRemotePlaybackStop();
}

void _HTMLMediaElementCloseMediaSource(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->CloseMediaSource();
}

void _HTMLMediaElementDurationChanged(WebNodeRef handle, double duration, double request_seek) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->DurationChanged(duration, request_seek);
}

void _HTMLMediaElementEnterPictureInPicture(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->enterPictureInPicture();
}

void _HTMLMediaElementExitPictureInPicture(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->exitPictureInPicture();
}

void _HTMLMediaElementTogglePlayState(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->TogglePlayState();
}

void _HTMLMediaElementAudioTrackChanged(WebNodeRef handle, void* audio_track) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->AudioTrackChanged(reinterpret_cast<blink::AudioTrack*>(audio_track));
}

void _HTMLMediaElementSelectedVideoTrackChanged(WebNodeRef handle, void* video_track) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->SelectedVideoTrackChanged(reinterpret_cast<blink::VideoTrack*>(video_track));
}

TextTrackRef _HTMLMediaElementAddTextTrackWithStrings(WebNodeRef handle, const char* kind, const char* label, const char* lang) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  blink::NonThrowableExceptionState exceptionState;
  return element->addTextTrack(AtomicString::FromUTF8(kind), AtomicString::FromUTF8(label), AtomicString::FromUTF8(lang), exceptionState);
}

// void _HTMLMediaElementAddTextTrack(WebNodeRef handle, void* text_track) {
//   WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//   blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
//   element->addTextTrack(reinterpret_cast<blink::TextTrack*>(text_track));
// }

//void _HTMLMediaElementRemoveTextTrack(WebNodeRef handle, void* text_track) {
//  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
//  element->RemoveTextTrack(reinterpret_cast<blink::TextTrack*>(text_track));
//}

//void _HTMLMediaElementTextTracksChanged(WebNodeRef handle) {
//  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
//  element->TextTracksChanged();
//}

//void _HTMLMediaElementNotifyMediaPlayerOfTextTrackChanges(WebNodeRef handle) {
//  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
//  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
//  element->NotifyMediaPlayerOfTextTrackChanges();
//}

void _HTMLMediaElementConfigureTextTrackDisplay(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->ConfigureTextTrackDisplay();
}

void _HTMLMediaElementUpdateTextTrackDisplay(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->UpdateTextTrackDisplay();
}

void _HTMLMediaElementTextTrackReadyStateChanged(WebNodeRef handle, void* text_track) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->TextTrackReadyStateChanged(reinterpret_cast<blink::TextTrack*>(text_track));
}

void _HTMLMediaElementTextTrackModeChanged(WebNodeRef handle, void* text_track) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->TextTrackModeChanged(reinterpret_cast<blink::TextTrack*>(text_track));
}

void _HTMLMediaElementDisableAutomaticTextTrackSelection(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->DisableAutomaticTextTrackSelection();
}

void _HTMLMediaElementAutomaticTrackSelectionForUpdatedUserPreference(WebNodeRef handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->AutomaticTrackSelectionForUpdatedUserPreference();
}

void _HTMLMediaElementScheduleEvent(WebNodeRef handle, WebEventRef event) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLMediaElement* element = ref->unwrap<blink::HTMLMediaElement>();
  element->ScheduleEvent(reinterpret_cast<blink::Event *>(event));
}

WebNodeRef _HTMLInputElementCreate(WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  CreateElementFlags flags;
  blink::HTMLInputElement* input_element = blink::HTMLInputElement::Create(*doc_ref->unwrap<blink::Document>(), flags);
  return new WebNodeWrapper(input_element);
}

char* _HTMLInputElementGetValue(WebNodeRef handle, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLInputElement* element = ref->unwrap<blink::HTMLInputElement>();
  String value = element->value();
  char* result = reinterpret_cast<char *>(malloc(value.length()));
  memcpy(result, value.Utf8().data(), value.length());
  *len = value.length();
  return result;
}

void _HTMLInputElementSetValue(WebNodeRef handle, const char* value) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(handle);
  blink::HTMLInputElement* element = ref->unwrap<blink::HTMLInputElement>();
  element->setValue(String::FromUTF8(value));
}

void _WebAXObjectDestroy(WebAXObjectRef handle) {
  delete reinterpret_cast<WebAXObjectWrapper *>(handle);
}

// WebFrame 

WebFrameRef _WebLocalFrameCreateMainFrame(void* peer, WebWidgetRef widget, WebFrameClientCbs callbacks, WebInterfaceRegistryRef registry) {
  return blink::WebLocalFrame::CreateMainFrame(
    reinterpret_cast<blink::WebView *>(widget),
    // isnt this leaking?? unfortunately, we will need a wrapper to own this
    new WebFrameClientImpl(peer, callbacks),
    reinterpret_cast<blink::InterfaceRegistry *>(registry));
}

void _WebLocalFrameDestroy(WebFrameRef handle) {
  //delete reinterpret_cast<blink::WebFrame *>(handle);
}

WebFrameRef _WebRemoteFrameCreate(void* peer, WebFrameClientCbs callbacks, int web_tree_scope_type) {
  blink::WebRemoteFrame* frame = blink::WebRemoteFrame::Create(
    web_tree_scope_type == 0 ? blink::WebTreeScopeType::kDocument : blink::WebTreeScopeType::kShadow,
    // The top-level frame must always be in a
    // document scope.
    //blink::WebTreeScopeType::kDocument,
    // isnt this leaking?? unfortunately, we will need a wrapper to own this
    new WebFrameClientImpl(peer, callbacks));//,
  DCHECK(frame);
  return frame;
}

void _WebRemoteFrameDestroy(WebFrameRef handle) {

}

void _WebRemoteFrameDidStartLoading(WebFrameRef handle) {
  reinterpret_cast<blink::WebRemoteFrame*>(handle)->DidStartLoading();
}

int _WebFrameSwap(WebFrameRef handle, WebFrameRef frame) {
  //DLOG(INFO) << "_WebFrameSwap: " << handle << ".swap(" <<  frame << ")";
  return reinterpret_cast<blink::WebFrame *>(handle)->Swap(reinterpret_cast<blink::WebFrame *>(frame)); 
}

void _WebFrameClose(WebFrameRef handle) {
  reinterpret_cast<blink::WebFrame *>(handle)->Close();
}

void _WebFrameDetach(WebFrameRef handle) {
  reinterpret_cast<blink::WebFrame *>(handle)->Detach();  
}

int _WebFrameIsEqual(WebFrameRef left, WebFrameRef right) {
  return left == right ? 1 : 0;
}

int _WebFrameInShadowTree(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->InShadowTree();
}

WebFrameRef _WebFrameGetParent(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->Parent();
}

WebFrameRef _WebFrameGetTop(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->Top();
}

WebFrameRef _WebFrameGetFirstChild(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->FirstChild();
}

WebFrameRef _WebFrameGetNextSibling(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->NextSibling();
}

WebFrameRef _WebFrameTraverseNext(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->TraverseNext();
}

JavascriptDataRef _WebFrameGetGlobalProxy(WebFrameRef handle) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  return new mumba::V8Value(isolate, reinterpret_cast<blink::WebFrame *>(handle)->GlobalProxy());
}

int _WebFrameScriptCanAccess(WebFrameRef handle) {
  return blink::WebFrame::ScriptCanAccess(reinterpret_cast<blink::WebFrame *>(handle));
}

WebFrameRef _WebFrameFromFrameOwnerElement(WebNodeRef element) {
  WebNodeWrapper* node = reinterpret_cast<WebNodeWrapper *>(element);
  blink::WebElement webElement(node->unwrap<blink::Element>()); 
  return blink::WebFrame::FromFrameOwnerElement(webElement);
}

int _WebFrameIsWebLocalFrame(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->IsWebLocalFrame();
}

int _WebFrameIsWebRemoteFrame(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->IsWebRemoteFrame(); 
}

WebWidgetRef _WebFrameView(WebFrameRef handle) {
 return reinterpret_cast<blink::WebFrame *>(handle)->View(); 
}

WebFrameRef _WebFrameGetOpener(WebFrameRef handle) {
  return reinterpret_cast<blink::WebFrame *>(handle)->Opener(); 
}

void _WebFrameSetOpener(WebFrameRef handle, WebFrameRef opener) {
  reinterpret_cast<blink::WebFrame *>(handle)->SetOpener(reinterpret_cast<blink::WebFrame *>(opener));
}

// limbo: this is suppose to work somehow?
void _WebLocalFrameSetRemoteWebLayer(WebFrameRef handle, LayerRef layer) {
    DCHECK(false);
  //reinterpret_cast<blink::WebFrame *>(handle)->setRemoteWebLayer(reinterpret_cast<blink::WebLayer *>(layer));
}


// WebLocalFrame
char* _WebLocalFrameAssignedName(WebFrameRef handle, int* len) {
  blink::WebString name = reinterpret_cast<blink::WebLocalFrame *>(handle)->AssignedName();
  char* result = (char*)malloc(name.length());
  memcpy(result, name.Utf8().c_str(), name.Utf8().length());
  *len = name.Utf8().length();
  return result;
}

void _WebLocalFrameSetName(WebFrameRef handle, const char* name) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetName(blink::WebString::FromUTF8(name)); 
}

WebFrameSelectionRef _WebLocalFrameGetSelection(WebFrameRef handle) {
  blink::LocalFrame* local_frame = static_cast<blink::LocalFrame *>(blink::WebFrame::ToCoreFrame(*reinterpret_cast<blink::WebLocalFrame *>(handle)));
  return &local_frame->Selection();
}

void _WebLocalFrameIconURLS(WebFrameRef handle, int iconTypesMask, const char** urls, int* urlslen) {
  blink::WebVector<blink::WebIconURL> iconUrls = reinterpret_cast<blink::WebLocalFrame *>(handle)->IconURLs(iconTypesMask);
  *urlslen = static_cast<int>(iconUrls.size());
  for (size_t i = 0; i < iconUrls.size(); i++) {
    urls[i] = iconUrls[i].GetIconURL().GetString().Utf8().c_str();
  }
}

void _WebLocalFrameSetSharedWorkerRepositoryClient(WebFrameRef handle, WebSharedWorkerRepositoryClientRef client) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetSharedWorkerRepositoryClient(reinterpret_cast<blink::WebSharedWorkerRepositoryClient *>(client));
}

void _WebLocalFrameSetCanHaveScrollbars(WebFrameRef handle, int can) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetCanHaveScrollbars(can == 0 ? false : true);
}

void _WebLocalFrameScrollOffset(WebFrameRef handle, int* width, int* height) {
  blink::WebSize size = reinterpret_cast<blink::WebLocalFrame *>(handle)->GetScrollOffset();
  
  *width = size.width; 
  *height = size.height;
}

void _WebLocalFrameSetScrollOffset(WebFrameRef handle, int width, int height) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetScrollOffset(blink::WebSize(width, height));
}

void _WebLocalFrameDocumentSize(WebFrameRef handle, int* width, int* height) {
  blink::WebSize size = reinterpret_cast<blink::WebLocalFrame *>(handle)->DocumentSize();
  *width = size.width; 
  *height = size.height; 
}

int _WebLocalFrameIsSelectionAnchorFirst(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsSelectionAnchorFirst() ? 1 : 0;
}

int _WebLocalFrameSelectionTextDirection(WebFrameRef handle, int* text_dir_start, int* text_dir_end) {
  blink::WebTextDirection start_dir = static_cast<blink::WebTextDirection>(*text_dir_start);
  blink::WebTextDirection end_dir = static_cast<blink::WebTextDirection>(*text_dir_end);
  bool result = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionTextDirection(start_dir, end_dir);
  *text_dir_start = static_cast<int>(start_dir);
  *text_dir_end = static_cast<int>(end_dir);
  return result;
}

WebWidgetRef _WebLocalFrameGetFrameWidget(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return frame->FrameWidget();
}

int _WebLocalFrameHasVisibleContent(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->HasVisibleContent();
}

void _WebLocalFrameVisibleContentRect(WebFrameRef handle, int* x, int* y, int* width, int* height) {
  blink::WebRect rect = reinterpret_cast<blink::WebLocalFrame *>(handle)->VisibleContentRect();
  *x = rect.x;
  *y = rect.y;
  *width = rect.width;
  *height = rect.height; 
}

WebSecurityOriginRef _WebLocalFrameGetSecurityOrigin(WebFrameRef handle) {
   //blink::WebSecurityOrigin webOrigin = reinterpret_cast<blink::WebLocalFrame *>(handle)->GetSecurityOrigin(); 
   blink::Frame* frame = blink::ToWebLocalFrameImpl(*reinterpret_cast<blink::WebLocalFrame *>(handle)).GetFrame();
   return new WebSecurityOriginWrapper(const_cast<blink::SecurityOrigin *>(frame->GetSecurityContext()->GetSecurityOrigin()));
}

WebNodeRef _WebLocalFrameDocument(WebFrameRef handle) {
  blink::WebDocument doc = reinterpret_cast<blink::WebLocalFrame *>(handle)->GetDocument();
  // TODO: with oilpan we actually dont need this
  // we can pass the 'WebDocumentRef' directly
  return new WebNodeWrapper(const_cast<blink::Document*>(doc.ConstUnwrap<blink::Document>()));
}

//web_PerformanceRef _WebFramePerformance(WebFrameRef handle) {
//}

int _WebLocalFrameDispatchBeforeUnloadEvent(WebFrameRef handle, int is_reload) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->DispatchBeforeUnloadEvent(is_reload == 1 ? true : false);
}

void _WebLocalFrameDispatchUnloadEvent(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->DispatchUnloadEvent();
}

// NPObjectRef _WebFrameWindowObject(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->WindowObject();
// }

// void _WebFrameBindToWindowObject(WebFrameRef handle, const char* name, NPObjectRef window) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->BindToWindowObject(blink::WebString::FromUTF8(name), reinterpret_cast<NPObject *>(window));
// }

// void _WebFrameBindToWindowObjectData(WebFrameRef handle, const char* name, NPObjectRef window, void* data) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->BindToWindowObject(blink::WebString::FromUTF8(name), reinterpret_cast<NPObject *>(window), data); 
// }

void _WebLocalFrameExecuteScript(WebFrameRef handle, const char* source) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteScript(blink::WebScriptSource(blink::WebString::FromUTF8(source)));
}

void _WebLocalFrameExecuteScriptInIsolatedWorld(WebFrameRef handle, int worldID, const char** sources, unsigned numSources) {
  std::vector<blink::WebScriptSource> scripts;
  for (unsigned i = 0; i < numSources; i++) {
    scripts[i] = blink::WebScriptSource(blink::WebString::FromUTF8(sources[i]));
  }
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteScriptInIsolatedWorld(worldID, &scripts[0], numSources);
}

void _WebLocalFrameSetIsolatedWorldSecurityOrigin(WebFrameRef handle, int worldID, WebSecurityOriginRef origin) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetIsolatedWorldSecurityOrigin(worldID, reinterpret_cast<WebSecurityOriginWrapper *>(origin)->asWebSecurityOrigin());
}

void _WebLocalFrameSetIsolatedWorldContentSecurityPolicy(WebFrameRef handle, int worldID, const char* str) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetIsolatedWorldContentSecurityPolicy(worldID, blink::WebString::FromUTF8(str));
}

void _WebLocalFrameAddMessageToConsole(WebFrameRef handle, WebConsoleMessageLevelEnum level, const char* message) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->AddMessageToConsole(blink::WebConsoleMessage(static_cast<blink::WebConsoleMessage::Level>(level), blink::WebString::FromUTF8(message)));
}

void _WebLocalFrameCollectGarbage(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->CollectGarbage();
}

// int _WebFrameCheckIfRunInsecureContent(WebFrameRef handle, const char* url) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->CheckIfRunInsecureContent(blink::KURL(blink::kParsedURLString, url));
// }

JavascriptDataRef _WebLocalFrameExecuteScriptAndReturnValue(WebFrameRef handle, const char* source) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::WebScriptSource script(blink::WebString::FromUTF8(source));
  
  v8::Local<v8::Value> result = reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteScriptAndReturnValue(script);

  if (result.IsEmpty()) {
    return nullptr;
  }

  return new mumba::V8Value(isolate, result);
}

void _WebLocalFrameExecuteScriptInIsolatedWorldValues(WebFrameRef handle, int worldID, const char** sources, unsigned numSources, JavascriptDataRef* results, int* resultCount) {
  std::vector<blink::WebScriptSource> scripts;
  blink::WebVector<v8::Local<v8::Value> > v8results;
  
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);

  for (unsigned i = 0; i < numSources; i++) {
    scripts[i] = blink::WebScriptSource(blink::WebString::FromUTF8(sources[i]));
  }
  
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteScriptInIsolatedWorld(worldID, &scripts[0], numSources, &v8results);
  *resultCount = v8results.size();

  // TODO: how to have a way for this to not leak?
  // FIXIT: THIS WILL PROBABLY LEAK ONCE CLIENT CODE USE IT
  // or client code can allocate before, using the numSources as reference
  // but we are not properly cleaning this
  *results = malloc(sizeof(mumba::V8Value) * v8results.size());
  for (size_t i = 0; i < v8results.size(); i++) {
    results[i] = new mumba::V8Value(isolate, v8results[i]);
  }

  ////DLOG(INFO) << "warning: leaking heap code called on _WebFrameExecuteScriptInIsolatedWorldValues. please fix"; 
}

JavascriptDataRef _WebLocalFrameCallFunctionEvenIfScriptDisabled(WebFrameRef handle, JavascriptDataRef func, JavascriptDataRef value, int argc, JavascriptDataRef* argv) {
  std::unique_ptr<v8::Local<v8::Value>[]> v8argv(new v8::Local<v8::Value>[argc]);

  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  
  v8::Local<v8::Value> v8func = reinterpret_cast<mumba::V8Value *>(func)->GetLocal(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(value)->GetLocal(isolate);

  for (int i = 0; i < argc; i++) {
     v8argv[i] = reinterpret_cast<mumba::V8Value *>(argv[i])->GetLocal(isolate);     
  }

  v8::MaybeLocal<v8::Value> v8result = reinterpret_cast<blink::WebLocalFrame *>(handle)->CallFunctionEvenIfScriptDisabled(v8func.As<v8::Function>(), v8value, argc, v8argv.get());
  if(v8result.IsEmpty()) {
    return nullptr;
  }
  return new mumba::V8Value(isolate, v8result.ToLocalChecked());
}

JavascriptContextRef _WebLocalFrameMainWorldScriptContext(WebFrameRef handle) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope scope(isolate);
  v8::Local<v8::Context> v8context = reinterpret_cast<blink::WebLocalFrame *>(handle)->MainWorldScriptContext();
  return new mumba::V8Context(isolate, v8context);
}

void _WebLocalFrameReload(WebFrameRef handle, WebFrameLoadEnum load_type) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->Reload(static_cast<blink::WebFrameLoadType>(load_type));
}

void _WebLocalFrameReloadWithOverrideURL(WebFrameRef handle, const char* overrideUrl, int ignoreCache) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ReloadWithOverrideURL(blink::KURL(blink::WebString::FromUTF8(overrideUrl)), 
    ignoreCache == 0 ? blink::WebFrameLoadType::kReload : blink::WebFrameLoadType::kReloadBypassingCache);
}

void _WebLocalFrameLoadRequest(WebFrameRef handle, WebURLRequestRef req) {
  WebURLRequestWrapper* urlRequest = reinterpret_cast<WebURLRequestWrapper *>(req);
  //DCHECK(urlRequest);
  reinterpret_cast<blink::WebLocalFrame *>(handle)->LoadRequest(urlRequest->get());
}

// void _WebFrameLoadHistoryItem(WebFrameRef handle, WebHistoryItemRef item, WebHistoryLoadTypeEnum type) {
//   blink::WebHistoryItem* historyItem = reinterpret_cast<blink::WebHistoryItem *>(item);
//   //DCHECK(historyItem);
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->LoadHistoryItem(*historyItem, static_cast<blink::WebHistoryLoadType>(type));
// }

void _WebLocalFrameLoadData(WebFrameRef handle, const char* data, size_t size, const char* mimeType, const char* textEncoding, const char* baseURL, const char* unreachableURL, int replace) {
  blink::WebData webdata(data, size);
  //DLOG(INFO) << "_WebLocalFrameLoadData: data: " << data << " size: " << size;
  reinterpret_cast<blink::WebLocalFrame *>(handle)->LoadData(
    webdata,
    blink::WebString::FromLatin1(mimeType),
    blink::WebString::FromLatin1(textEncoding),
    blink::KURL(blink::WebString::FromLatin1(baseURL)),
    unreachableURL ? blink::KURL(blink::WebString::FromLatin1(unreachableURL)) : blink::KURL(blink::WebString::FromLatin1("data:this")),
    replace == 0 ? false : true);
}

void _WebLocalFrameLoadHTMLString(WebFrameRef handle, const char* html, size_t html_size, const char* baseURL, const char* unreachableURL, int replace) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  //DLOG(INFO) << "_WebLocalFrameLoadHTMLString: frame = " << frame << " html: " << html << " size: " << html_size;
  DCHECK(html);
  blink::WebData htmldata(html, html_size);
  frame->LoadHTMLString(
      htmldata, 
      baseURL ? blink::KURL(blink::WebString::FromLatin1(baseURL)) : blink::KURL(blink::WebString::FromLatin1("data:hello")), 
      unreachableURL ? blink::KURL(blink::WebString::FromLatin1(unreachableURL)) : blink::KURL(blink::WebString::FromLatin1("unreachable://this")), 
      replace == 0 ? false : true);
}

void _WebLocalFrameStopLoading(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->StopLoading();  
}

// WebDataSourceRef _WebFrameProvisionalDataSource(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->ProvisionalDataSource();
// }

// WebDataSourceRef _WebFrameDataSource(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->DataSource();
// }

void _WebLocalFrameEnableViewSourceMode(WebFrameRef handle, int enable) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->EnableViewSourceMode(enable == 0 ? false : true);  
}

int _WebLocalFrameIsViewSourceModeEnabled(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsViewSourceModeEnabled() ? 1 : 0; 
}

void _WebLocalFrameSetReferrerForRequest(WebFrameRef handle, WebURLRequestRef req, const char* url) {
  WebURLRequestWrapper* urlRequest = reinterpret_cast<WebURLRequestWrapper *>(req);
  //DCHECK(urlRequest);
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetReferrerForRequest(urlRequest->get(), blink::KURL(blink::WebString::FromUTF8(url)));
}

// void _WebFrameDispatchWillSendRequest(WebFrameRef handle, WebURLRequestRef req) {
//   WebURLRequestWrapper* urlRequest = reinterpret_cast<WebURLRequestWrapper *>(req);
//   //DCHECK(urlRequest);
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->DispatchWillSendRequest(urlRequest->get());
// }

WebAssociatedURLLoaderRef _WebLocalFrameCreateAssociatedURLLoader(WebFrameRef handle,
    int /*bool*/ untrustedHTTP, 
    int /*bool*/ exposeAllResponseHeaders, 
    WebPreflightPolicyEnum preflightPolicy) {

  blink::WebAssociatedURLLoaderOptions options;

  options.untrusted_http = untrustedHTTP == 0 ? false : true; 
  options.expose_all_response_headers = exposeAllResponseHeaders == 0 ? false : true; 
  options.preflight_policy = static_cast<network::mojom::CORSPreflightPolicy>(preflightPolicy);
 
  blink::WebAssociatedURLLoader* urlLoader = 
    reinterpret_cast<blink::WebLocalFrame *>(handle)->CreateAssociatedURLLoader(options);
  return urlLoader;
}

// unsigned _WebFrameUnloadListenerCount(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->UnloadListenerCount();
// }

int _WebLocalFrameIsLoading(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsLoading() ? 1 : 0;
}

void _WebLocalFrameReplaceSelection(WebFrameRef handle, const char* text) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ReplaceSelection(blink::WebString::FromUTF8(text));
}

// void _WebFrameInsertText(WebFrameRef handle, const char* text) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->InsertText(blink::WebString::FromUTF8(text));
// }

void _WebLocalFrameSetMarkedText(WebFrameRef handle, const char* text, unsigned location, unsigned length) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetMarkedText(blink::WebString::FromUTF8(text), location, length);
}

void _WebLocalFrameUnmarkText(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->UnmarkText();
}

int _WebLocalFrameHasMarkedText(WebFrameRef handle) {
 return reinterpret_cast<blink::WebLocalFrame *>(handle)->HasMarkedText() ? 1 : 0;
}

void _WebLocalFrameMarkedRange(WebFrameRef handle, int* start, int* end ) {
 blink::WebRange range = reinterpret_cast<blink::WebLocalFrame *>(handle)->MarkedRange();
 *start = range.StartOffset();
 *end = range.EndOffset();
}

int _WebLocalFrameFirstRectForCharacterRange(WebFrameRef handle, unsigned location, unsigned length, int* x, int* y, int* width, int* height) {
 blink::WebRect rect;
 bool result = reinterpret_cast<blink::WebLocalFrame *>(handle)->FirstRectForCharacterRange(location, length, rect);
 *x = rect.x; 
 *y = rect.y; 
 *width = rect.width; 
 *height = rect.height;
 return result ? 1 : 0;
}

size_t _WebLocalFrameCharacterIndexForPoint(WebFrameRef handle, int px, int py) {
 blink::WebPoint pt(px, py);
 return reinterpret_cast<blink::WebLocalFrame *>(handle)->CharacterIndexForPoint(pt);
}

int _WebLocalFrameExecuteCommand(WebFrameRef handle, const char* str) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteCommand(blink::WebString::FromUTF8(str));
}

int _WebLocalFrameExecuteCommandValue(WebFrameRef handle, const char* string, const char* value) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->ExecuteCommand(blink::WebString::FromUTF8(string), blink::WebString::FromUTF8(value));
}

int _WebLocalFrameIsCommandEnabled(WebFrameRef handle, const char* string) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsCommandEnabled(blink::WebString::FromUTF8(string)) ? 1 : 0;
}

// void _WebFrameEnableContinuousSpellChecking(WebFrameRef handle, int enable) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->EnableContinuousSpellChecking(enable);  
// }

// int _WebFrameIsContinuousSpellCheckingEnabled(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsContinuousSpellCheckingEnabled() ? 1 : 0;
// }

// void _WebFrameRequestTextChecking(WebFrameRef handle, WebNodeRef element) {
//   WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(element);
//   blink::Node* node = *wrapper;
//   blink::WebNode webNode(node);
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->RequestTextChecking(webNode.ToConst<blink::WebElement>());
// }

void _WebLocalFrameReplaceMisspelledRange(WebFrameRef handle, const char* text) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ReplaceMisspelledRange(blink::WebString::FromUTF8(text));
}

void _WebLocalFrameRemoveSpellingMarkers(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->RemoveSpellingMarkers();
}

int _WebLocalFrameHasSelection(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->HasSelection() ? 1 : 0;
}

void _WebLocalFrameSelectionRange(WebFrameRef handle, int* start, int* end) {
  blink::WebRange range = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionRange();
  *start = range.StartOffset();
  *end = range.EndOffset();
}

char* _WebLocalFrameSelectionAsText(WebFrameRef handle, int* len) {
  blink::WebString text = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionAsText();
  char* result = (char*)malloc(text.length());
  memcpy(result, text.Utf8().c_str(), text.Utf8().length());
  *len = text.Utf8().length();
  return result;
}

char* _WebLocalFrameSelectionAsMarkup(WebFrameRef handle, int* len) {
  blink::WebString text = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionAsMarkup();
  char* result = (char*)malloc(text.length());
  memcpy(result, text.Utf8().c_str(), text.Utf8().length());
  *len = text.Utf8().length();
  return result;
}

int _WebLocalFrameSelectWordAroundCaret(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectWordAroundCaret() ? 1 : 0;
}

void _WebLocalFrameSelectRangeInt(WebFrameRef handle, int base_x, int base_y, int extent_x, int extent_y) {
  blink::WebPoint base(base_x, base_y);
  blink::WebPoint extent(extent_x, extent_y);

  reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectRange(base, extent);
}

void _WebLocalFrameSelectRange(WebFrameRef handle, int start, int end, int hide) {
//  WebRangeWrapper *r = reinterpret_cast<WebRangeWrapper *>(range);
  blink::WebRange range(start, end - start);
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectRange(range, 
    hide == 1 ? blink::WebLocalFrame::kHideSelectionHandle : blink::WebLocalFrame::kShowSelectionHandle,
    hide == 1 ? blink::mojom::SelectionMenuBehavior::kHide : blink::mojom::SelectionMenuBehavior::kShow);
}

void _WebLocalFrameMoveRangeSelection(WebFrameRef handle, 
  int base_x, 
  int base_y, 
  int extent_x, 
  int extent_y, 
  WebTextGranularityEnum granularity) {
  
  blink::WebPoint base(base_x, base_y);
  blink::WebPoint extent(extent_x, extent_y);

  reinterpret_cast<blink::WebLocalFrame *>(handle)->MoveRangeSelection(base, extent, static_cast<blink::WebFrame::TextGranularity>(granularity));
}

void _WebLocalFrameMoveCaretSelection(WebFrameRef handle, int x, int y) {
  blink::WebPoint pt(x, y);
  reinterpret_cast<blink::WebLocalFrame *>(handle)->MoveCaretSelection(pt);
}

int _WebLocalFrameSetEditableSelectionOffsets(WebFrameRef handle, int start, int end) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->SetEditableSelectionOffsets(start, end) ? 1 : 0;
}

int _WebLocalFrameSetCompositionFromExistingText(WebFrameRef handle, 
  int compositionStart, 
  int compositionEnd,
  int* spanType,
  int* spanStart,
  int* spanEnd,
  int* spanUcolor,
  int* spanThick,
  int* spanBgcolor,
  int spanLen) {

  blink::WebVector<blink::WebImeTextSpan> ime_text_spans;
  
  for(int i = 0; i < spanLen; i++) {
    ime_text_spans[i] = blink::WebImeTextSpan(
      static_cast<blink::WebImeTextSpan::Type>(spanType[i]), 
      spanStart[i], 
      spanEnd[i], 
      static_cast<ui::mojom::ImeTextSpanThickness>(spanThick[i]),
      blink::WebColor(spanBgcolor[i]),
      blink::WebColor(spanUcolor[i]));  
  }

  return reinterpret_cast<blink::WebLocalFrame *>(handle)->SetCompositionFromExistingText(compositionStart, compositionEnd, ime_text_spans) ? 1 : 0;
}

void _WebLocalFrameExtendSelectionAndDelete(WebFrameRef handle, int before, int after) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ExtendSelectionAndDelete(before, after);
}

void _WebLocalFrameSetCaretVisible(WebFrameRef handle, int visible) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetCaretVisible(visible ? 1 : 0);
}

int _WebLocalFramePrintBegin(WebFrameRef handle, 
  int contentAreaX, 
  int contentAreaY, 
  int contentAreaWidth, 
  int contentAreaHeight,
  int printableAreaX,
  int printableAreaY,
  int printableAreaWidth,
  int printableAreaHeight,
  int paperSizeWidth,
  int paperSizeHeight,
  int printerDPI,
  int rasterize_pdf,
  WebPrintScalingOptionEnum printScalingOption,
  int use_printing_layout,
  WebNodeRef constrainToNode) {
  
  blink::WebPrintParams params(blink::WebRect(contentAreaX, contentAreaY, contentAreaWidth, contentAreaHeight), blink::WebRect(printableAreaX, printableAreaY, printableAreaWidth, printableAreaHeight), blink::WebSize(paperSizeWidth, paperSizeHeight), printerDPI, static_cast<blink::WebPrintScalingOption>(printScalingOption), use_printing_layout ? true : false);
  if (rasterize_pdf != 0) {
    params.rasterize_pdf = true;
  }
  if (constrainToNode) {
    WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(constrainToNode);
    return reinterpret_cast<blink::WebLocalFrame *>(handle)->PrintBegin(params, blink::WebNode(*wrapper));
  } else {
    return reinterpret_cast<blink::WebLocalFrame *>(handle)->PrintBegin(params);
  }
}

float _WebLocalFrameGetPrintPageShrink(WebFrameRef handle, int page) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->GetPrintPageShrink(page);
}

float _WebLocalFramePrintPage(WebFrameRef handle, int pageToPrint, CanvasRef canvas) {
  cc::SkiaPaintCanvas paint_canvas(reinterpret_cast<SkiaCanvas *>(canvas)->handle());
  
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->PrintPage(pageToPrint, &paint_canvas);
}

void _WebLocalFramePrintEnd(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->PrintEnd();
}

int _WebLocalFrameIsPrintScalingDisabledForPlugin(WebFrameRef handle, WebNodeRef node) {
  if (node) {
    WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(node);
    return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsPrintScalingDisabledForPlugin(blink::WebNode(*wrapper));
  } else {
    return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsPrintScalingDisabledForPlugin();
  }
}

int _WebLocalFrameIsPageBoxVisible(WebFrameRef handle, int pageIndex) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->IsPageBoxVisible(pageIndex);
}

int _WebLocalFrameHasCustomPageSizeStyle(WebFrameRef handle, int pageIndex) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->HasCustomPageSizeStyle(pageIndex);
}

void _WebLocalFramePageSizeAndMarginsInPixels(WebFrameRef handle, 
  int pageIndex, 
  int width, 
  int height, 
  int* marginTop, 
  int* marginRight, 
  int* marginBottom, 
  int* marginLeft) {
   
  blink::WebDoubleSize size(width, height);

  int top; 
  int right; 
  int bottom; 
  int left;

  reinterpret_cast<blink::WebLocalFrame *>(handle)->PageSizeAndMarginsInPixels(
    pageIndex,
    size,
    top,
    right,
    bottom,
    left);

  *marginTop = top;
  *marginRight = right;
  *marginBottom = bottom; 
  *marginLeft = left; 
}

char* _WebLocalFramePageProperty(WebFrameRef handle, const char* propertyName, int pageIndex, int* len) {
  blink::WebString text = reinterpret_cast<blink::WebLocalFrame *>(handle)->PageProperty(blink::WebString::FromUTF8(propertyName), pageIndex);
  char* result = (char*)malloc(text.length());
  memcpy(result, text.Utf8().c_str(), text.Utf8().length());
  *len = text.Utf8().length();
  return result;
}

int _WebLocalFrameFind(WebFrameRef handle, 
    int identifier, 
    const char* searchText, 
    int /*bool*/ forward,
    int /*bool*/ matchCase,
    int /*bool*/ findNext,
    int /*bool*/ wordStart,
    int /*bool*/ medialCapitalAsWordStart, 
    int wrapWithinFrame,
    float* x, 
    float* y, 
    float* width, 
    float* height) {

  //blink::WebRect selectionRect;
  blink::WebFindOptions options;
  options.forward = forward; 
  options.match_case = matchCase; 
  options.find_next = findNext; 
  options.word_start = wordStart; 
  options.medial_capital_as_word_start = medialCapitalAsWordStart;

  bool result = reinterpret_cast<blink::WebLocalFrame *>(handle)->Find(
                        identifier,
                        blink::WebString::FromUTF8(searchText),
                        options,
                        wrapWithinFrame == 0 ? false : true);
  
  if (result) {
    blink::WebFloatRect selectionRect = reinterpret_cast<blink::WebLocalFrame *>(handle)->ActiveFindMatchRect();
    *x = selectionRect.x;
    *y = selectionRect.y;
    *width = selectionRect.width;
    *height = selectionRect.height;
  }

  return result;
}

void _WebLocalFrameRequestFind(WebFrameRef handle, 
    int32_t request_id, 
    const uint16_t* search_text, 
    int forward,
    int match_case,
    int find_next,
    int word_start,
    int medial_capital_as_word_start,
    int force) {
  
  blink::WebFindOptions options;
  options.forward = forward != 0;
  options.match_case = match_case != 0;
  options.find_next = find_next != 0;
  options.word_start = word_start != 0;
  options.medial_capital_as_word_start = medial_capital_as_word_start != 0;
  options.force = force != 0;

  reinterpret_cast<blink::WebLocalFrame *>(handle)->RequestFind(request_id, 
    blink::WebString::FromUTF16(base::string16(search_text)),
    options);
}

void _WebLocalFrameStopFinding(WebFrameRef handle, int action) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->StopFinding(static_cast<blink::WebLocalFrame::StopFindAction>(action));
}

void _WebLocalFrameClearActiveFindMatch(WebFrameRef handle) {
  reinterpret_cast<blink::WebLocalFrame *>(handle)->ClearActiveFindMatch(); 
}

// void _WebFrameScopeStringMatches(WebFrameRef handle, 
//     int identifier, 
//     const char* searchText,   
//     int /*bool*/ forward,
//     int /*bool*/ matchCase,
//     int /*bool*/ findNext,
//     int /*bool*/ wordStart,
//     int /*bool*/ medialCapitalAsWordStart, 
//     int reset) {

//   blink::WebFindOptions options;
//   options.forward = forward; 
//   options.matchCase = matchCase; 
//   options.findNext = findNext; 
//   options.wordStart = wordStart; 
//   options.medialCapitalAsWordStart = medialCapitalAsWordStart;

//   reinterpret_cast<blink::WebLocalFrame *>(handle)->ScopeStringMatches(
//     identifier,
//     blink::WebString::FromUTF8(searchText),
//     options,
//     reset);
// }

// void _WebFrameCancelPendingScopingEffort(WebFrameRef handle) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->CancelPendingScopingEffort();
// }

// void _WebFrameIncreaseMatchCount(WebFrameRef handle, int count, int identifier) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->IncreaseMatchCount(count, identifier);
// }

// void _WebFrameResetMatchCount(WebFrameRef handle) {
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->ResetMatchCount();
// }

int _WebLocalFrameFindMatchMarkersVersion(WebFrameRef handle) {
  return reinterpret_cast<blink::WebLocalFrame *>(handle)->FindMatchMarkersVersion();
}

void _WebLocalFrameActiveFindMatchRect(WebFrameRef handle, float* x, float* y, float* width, float* height) {
  blink::WebFloatRect rect = reinterpret_cast<blink::WebLocalFrame *>(handle)->ActiveFindMatchRect();
  *x = rect.x;
  *y = rect.y;
  *width = rect.width;
  *height = rect.height;  
}

void _WebLocalFrameFindMatchRects(WebFrameRef handle, float** x, float** y, float** w, float** h, int* lenght) {
  blink::WebVector<blink::WebFloatRect> rects;

  reinterpret_cast<blink::WebLocalFrame *>(handle)->FindMatchRects(rects);

  for (size_t i = 0; i < rects.size(); i++) {
    *x[i] = rects[i].x;
    *y[i] = rects[i].y;
    *w[i] = rects[i].width;
    *h[i] = rects[i].height;
  }

  *lenght = rects.size();
}

int _WebLocalFrameSelectNearestFindMatch(WebFrameRef handle, int px, int py, int* x, int* y, int* w, int* h) {
  blink::WebFloatPoint pt(static_cast<float>(px), static_cast<float>(py));
  blink::WebRect rect;
  
  bool result = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectNearestFindMatch(pt, &rect);
  
  *x = rect.x;
  *y = rect.y;
  *w = rect.width;
  *h = rect.height;
  
  return result ? 1 : 0;
}

void _WebLocalFrameSetTickmarks(WebFrameRef handle, int* x, int* y, int* w, int* h, int lenght) {
  blink::WebVector<blink::WebRect> rects(static_cast<size_t>(lenght));
  for (int i = 0; i < lenght; i++) {
    rects[i].x = x[i];
    rects[i].y = y[i];
    rects[i].width = w[i];
    rects[i].height = h[i];
  }
  reinterpret_cast<blink::WebLocalFrame *>(handle)->SetTickmarks(rects);
}

void _WebLocalFrameDispatchMessageEventWithOriginCheck(WebFrameRef handle, 
  WebSecurityOriginRef intendedTargetOrigin, 
  WebDOMEventRef event,
  int has_user_gesture) {

  reinterpret_cast<blink::WebLocalFrame *>(handle)->DispatchMessageEventWithOriginCheck(static_cast<WebSecurityOriginWrapper *>(intendedTargetOrigin)->asWebSecurityOrigin(), *reinterpret_cast<blink::WebDOMEvent *>(event), has_user_gesture == 1 ? true: false);
}

// const char* _WebFrameContentAsText(WebFrameRef handle, size_t maxChars) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->ContentAsText(maxChars).utf8().c_str();
// }

// const char* _WebFrameContentAsMarkup(WebFrameRef handle) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->ContentAsMarkup().utf8().c_str();
// }

// const char* _WebFrameLayoutTreeAsText(WebFrameRef handle, WebLayoutAsTextControls toShow) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->LayoutTreeAsText(toShow).utf8().c_str();
// }

// const char* _WebFrameMarkerTextForListItem(WebFrameRef handle, WebNodeRef element) {
//   WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(element);
//   blink::Node* node = *wrapper;
//   blink::WebNode webNode(node);
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->MarkerTextForListItem(webNode.ToConst<blink::WebElement>()).utf8().c_str();
// }

// void _WebFramePrintPagesWithBoundaries(WebFrameRef handle, CanvasRef canvas, int width, int height) {
//   SkCanvas* skcanvas = reinterpret_cast<SkiaCanvas *>(canvas)->handle().get();
//   blink::WebSize size(width, height);
//   reinterpret_cast<blink::WebLocalFrame *>(handle)->PrintPagesWithBoundaries(skcanvas, size);
// }

// void _WebFrameSelectionBoundsRect(WebFrameRef handle, int* x, int* y, int* width, int* height) {
//   blink::WebRect rect = reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionBoundsRect();
//   *x = rect.x;
//   *y = rect.y;
//   *width = rect.width;
//   *height = rect.height;
// }

// int _WebFrameSelectionStartHasSpellingMarkerFor(WebFrameRef handle, int from, int length) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->SelectionStartHasSpellingMarkerFor(from, length) ? 1 : 0;
// }

// const char* _WebFrameLayerTreeAsText(WebFrameRef handle, int showDebugInfo) {
//   return reinterpret_cast<blink::WebLocalFrame *>(handle)->LayerTreeAsText(showDebugInfo).utf8().c_str();
// }

// // WebLocalFrame
// WebFrameRef _WebFrameCreate(WebTreeScopeEnum type, WebFrameClientRef client) {
//   blink::WebLocalFrame* frame = blink::WebLocalFrame::Create(static_cast<blink::WebTreeScopeType>(type), static_cast<WebFrameClientImpl *>(client));
//   return static_cast<blink::WebFrame *>(frame);
// }

WebFrameRef _WebLocalFrameForCurrentContext() {
  blink::WebLocalFrame* frame = blink::WebLocalFrame::FrameForCurrentContext();
  return static_cast<blink::WebFrame *>(frame);
}

WebFrameRef _WebLocalFrameForContext(JavascriptContextRef context) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  
  v8::Local<v8::Context> v8context = reinterpret_cast<mumba::V8Context *>(context)->GetLocal();
  blink::WebLocalFrame* frame = blink::WebLocalFrame::FrameForContext(v8context);
  return static_cast<blink::WebFrame *>(frame);
}

// WebFrameRef _WebFrameFromFrameOwnerElement(WebNodeRef element) {
//   WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(element);
//   blink::Node* node = *wrapper;
//   blink::WebNode webNode(node);
//   blink::WebLocalFrame* frame = blink::WebLocalFrame::FromFrameOwnerElement(webNode.ToConst<blink::WebElement>());
//   return static_cast<blink::WebFrame *>(frame); 
// }

// void _WebFrameInitializeToReplaceRemoteFrame(WebFrameRef handle, 
//     WebFrameRef remoteframe, const char* name, 
//     WebSandboxFlagsEnum flags, 
//     WebScrollingModeEnum scrollingMode, 
//     int marginWidth,
//     int marginHeight,
//     int allow_fullscreen) {

//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   blink::WebRemoteFrame* remoteFrame = static_cast<blink::WebRemoteFrame *>(reinterpret_cast<blink::WebFrame *>(handle));

//   blink::WebFrameOwnerProperties properties;
//   properties.scrolling_mode = static_cast<blink::ScrollbarMode>(scrollingMode);
//   properties.margin_width = marginWidth;
//   properties.margin_height = marginHeight;
//   properties.allow_fullscreen = allow_fullscreen == 1 ? true : false;
  
//   frame->InitializeToReplaceRemoteFrame(
//     remoteFrame, 
//     blink::WebString::FromUTF8(name),
//     static_cast<blink::WebSandboxFlags>(flags),
//     properties);
// }

void _WebLocalFrameSetAutofillClient(WebFrameRef handle, WebAutofillClientRef client) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SetAutofillClient(reinterpret_cast<blink::WebAutofillClient *>(client));  
}

WebAutofillClientRef _WebLocalFrameAutofillClient(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return frame->AutofillClient(); 
}

// void _WebFrameSetDevToolsAgentClient(WebFrameRef handle, WebDevToolsAgentClientRef client) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   frame->SetDevToolsAgentClient(static_cast<blink::WebDevToolsAgentClient *>(client));
// }

// WebDevToolsAgentRef _WebFrameDevToolsAgent(WebFrameRef handle) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   return frame->DevToolsAgent();
// }

void _WebLocalFrameSetFrameOwnerProperties(WebFrameRef handle, 
    WebScrollingModeEnum scrollingMode, 
    int marginWidth,
    int marginHeight) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  
  blink::WebFrameOwnerProperties properties;
  properties.scrolling_mode = static_cast<blink::WebScrollbar::ScrollingMode>(scrollingMode);
  properties.margin_width = marginWidth;
  properties.margin_height = marginHeight;

  frame->SetFrameOwnerProperties(properties);
}

void _WebLocalFrameSendPings(WebFrameRef handle, const char* destinationURL) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  //WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(contextNode);
  //blink::WebNode webNode(*wrapper);
  
  frame->SendPings(blink::KURL(blink::WebString::FromUTF8(destinationURL)));
}

WebURLRequestRef _WebLocalFrameRequestFromHistoryItem(WebFrameRef handle, WebHistoryItemRef item, WebURLRequestCachePolicyEnum policy) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);

  return new WebURLRequestWrapper(frame->RequestFromHistoryItem(*reinterpret_cast<blink::WebHistoryItem *>(item), static_cast<blink::mojom::FetchCacheMode>(policy)));
}

WebURLRequestRef _WebLocalFrameRequestForReload(WebFrameRef handle, WebFrameLoadEnum type, const char* overrideURL) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return new WebURLRequestWrapper(frame->RequestForReload(static_cast<blink::WebFrameLoadType>(type), blink::KURL(blink::WebString::FromUTF8(overrideURL))));
}

void _WebLocalFrameLoad(WebFrameRef handle, 
  WebURLRequestRef req, 
  WebFrameLoadEnum floadType, 
  WebHistoryItemRef item, 
  WebHistoryLoadTypeEnum hloadType,
  int is_client_redirect) {
  
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  
  base::UnguessableToken devtools_token = base::UnguessableToken::Create();
  
  frame->Load(reinterpret_cast<WebURLRequestWrapper *>(req)->get(), 
    static_cast<blink::WebFrameLoadType>(floadType), 
    *reinterpret_cast<blink::WebHistoryItem *>(item), 
    static_cast<blink::WebHistoryLoadType>(hloadType),
    is_client_redirect ? true : false,
    devtools_token);
}

// int _WebFrameIsLoading(WebFrameRef handle) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   return frame->IsLoading() ? 1 : 0;
// }

// int _WebFrameIsResourceLoadInProgress(WebFrameRef handle) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   return frame->IsResourceLoadInProgress() ? 1 : 0;
// }

// int _WebFrameIsNavigationScheduled(WebFrameRef handle) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   return frame->IsNavigationScheduled() ? 1 : 0;
// }

void _WebLocalFrameSetCommittedFirstRealLoad(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SetCommittedFirstRealLoad();
}

void _WebLocalFrameSendOrientationChangeEvent(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SendOrientationChangeEvent();
}

int _WebLocalFrameGetPrintPresetOptionsForPlugin(WebFrameRef handle, WebNodeRef node,
    int* isScalingDisabled,
    int* copies,
    WebDuplexModeEnum* duplexMode,
    int** pageRangeFrom,
    int** pageRangeTo,
    int* pageRangeLenght,
    int* isPageSizeUniform,
    int* uniformPageSizeWidth,
    int* uniformPageSizeHeight) {

  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);

  WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(node);
  blink::Node* toNode = *wrapper;
  blink::WebNode webNode(toNode);

  blink::WebPrintPresetOptions options;

  bool result = frame->GetPrintPresetOptionsForPlugin(webNode, &options);
  if (!result) {
    return 0;
  }

  // todo: if the array is not pre-allocated this will break
  for (size_t i = 0; i < options.page_ranges.size(); i++) {
    *pageRangeFrom[i] = options.page_ranges[i].from;
    *pageRangeTo[i] = options.page_ranges[i].to;
  }

  *isScalingDisabled = options.is_scaling_disabled ? 1 : 0;
  *copies = options.copies;
  *duplexMode = static_cast<WebDuplexModeEnum>(options.duplex_mode);
  *pageRangeLenght = options.page_ranges.size();
  *isPageSizeUniform = options.is_page_size_uniform ? 1 : 0;
  *uniformPageSizeWidth = options.uniform_page_size.width;
  *uniformPageSizeHeight = options.uniform_page_size.height;

  return 1;
}

void _WebLocalFrameRequestExecuteScriptAndReturnValue(WebFrameRef handle, const char* source, int userGesture, WebScriptExecutionCallbackRef cb) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  blink::WebScriptSource script(blink::WebString::FromUTF8(source));

  frame->RequestExecuteScriptAndReturnValue(script, userGesture == 0 ? false : true, reinterpret_cast<blink::WebScriptExecutionCallback *>(cb));
}

void _WebLocalFrameRequestExecuteScriptInIsolatedWorld(WebFrameRef handle, 
int worldID, 
const char** sourceIn, 
unsigned numSources, 
int userGesture,
WebScriptExecutionTypeEnum execution_type,
WebScriptExecutionCallbackRef cb) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  
  std::vector<blink::WebScriptSource> scripts;
  
  for (unsigned i = 0; i < numSources; i++) {
    scripts[i] = blink::WebScriptSource(blink::WebString::FromUTF8(sourceIn[i]));
  }

  frame->RequestExecuteScriptInIsolatedWorld(worldID, 
    &scripts[0],
    numSources,
    userGesture == 0 ? false : true,
    static_cast<blink::WebLocalFrame::ScriptExecutionType>(execution_type),
    reinterpret_cast<blink::WebScriptExecutionCallback *>(cb)); 
}

// void _WebFrameRequestRunTask(WebFrameRef handle, WebSuspendableTaskRef task) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   frame->RequestRunTask(reinterpret_cast<blink::WebSuspendableTask *>(task)); 
// }

void _WebLocalFrameSetIsolatedWorldHumanReadableName(WebFrameRef handle, int worldID, const char* name) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SetIsolatedWorldHumanReadableName(worldID, blink::WebString::FromUTF8(name));
}

void _WebLocalFrameMoveRangeSelectionExtent(WebFrameRef handle, int px, int py) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  blink::WebPoint pt(px, py);

  frame->MoveRangeSelectionExtent(pt);
}

void _WebLocalFrameSetContentSettingsClient(WebFrameRef handle, WebContentSettingsClientRef client) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SetContentSettingsClient(reinterpret_cast<blink::WebContentSettingsClient *>(client));
}

// void _WebFrameWillShowInstallBannerPrompt(WebFrameRef handle, int requestId, const char** platforms, int platformsLen, WebAppBannerPromptReplyRef reply) {
//   blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
//   blink::WebVector<blink::WebString> platformStrings(static_cast<size_t>(platformsLen));

//   for (int i = 0; i < platformsLen; i++) {
//     platformStrings[i] = blink::WebString::FromUTF8(platforms[i]);
//   }

//   frame->WillShowInstallBannerPrompt(requestId, platformStrings, reinterpret_cast<blink::WebAppBannerPromptReply *>(reply));
// }

void _WebLocalFrameReloadImage(WebFrameRef handle, WebNodeRef node) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  
  WebNodeWrapper* wrapper = reinterpret_cast<WebNodeWrapper *>(node);
  blink::Node* toNode = *wrapper;
  blink::WebNode webNode(toNode);

  frame->ReloadImage(webNode);
}

void _WebLocalFrameDidCallAddSearchProvider(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->DidCallAddSearchProvider();
}

void _WebLocalFrameDidCallIsSearchProviderInstalled(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->DidCallIsSearchProviderInstalled();
}

WebSandboxFlagsEnum _WebLocalFrameEffectiveSandboxFlags(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return static_cast<WebSandboxFlagsEnum>(frame->EffectiveSandboxFlags());
}

void _WebLocalFrameNotifyUserActivation(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->NotifyUserActivation();
}

void _WebLocalFrameAdvanceFocusInForm(WebFrameRef handle, int type) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->AdvanceFocusInForm(static_cast<blink::WebFocusType>(type));
}

void _WebLocalFrameCopyImageAt(WebFrameRef handle, int x, int y) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->CopyImageAt(blink::WebPoint(x, y));
}

void _WebLocalFrameSaveImageAt(WebFrameRef handle, int x, int y) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SaveImageAt(blink::WebPoint(x, y));
}

void _WebLocalFrameClientDroppedNavigation(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->ClientDroppedNavigation();
}

void _WebLocalFrameCollapse(WebFrameRef handle, int collapsed) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->Collapse(collapsed != 0);
}

void _WebLocalFrameCheckCompleted(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->CheckCompleted(); 
}

void _WebLocalFrameGetWebSurroundingText(WebFrameRef handle, 
  int maxlen, 
  void* ptr,
  void (*cb)(void*, const uint16_t*, int, int, int)) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  blink::WebSurroundingText surrounding_text(frame, maxlen);
  if (!surrounding_text.IsEmpty()) {
    base::string16 str = surrounding_text.TextContent().Utf16();
    cb(ptr, 
       str.data(), 
       surrounding_text.TextContent().length(), 
       surrounding_text.StartOffsetInTextContent(),
       surrounding_text.EndOffsetInTextContent());
  } else {
    cb(ptr, 
       nullptr, 
       0, 
       0,
       0);
  }
}

WebDocumentLoaderRef _WebLocalFrameGetProvisionalDocumentLoader(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return frame->GetProvisionalDocumentLoader();
}

WebDocumentLoaderRef _WebLocalFrameGetDocumentLoader(WebFrameRef handle) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  return frame->GetDocumentLoader(); 
}

int _WebLocalFrameCommitNavigation(
  WebFrameRef handle,
  WebURLRequestRef request_ref,
  int web_frame_load_type,
  WebHistoryItemRef item,
  int is_client_redirect) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  blink::WebHistoryItem* history_item = nullptr;
  blink::WebHistoryItem local_history_item;

  // TODO: really use ExtraData
  //std::unique_ptr<blink::WebDocumentLoader::ExtraData> extra_data = std::make_unique<blink::WebDocumentLoader::ExtraData>();
  base::UnguessableToken devtools_navigation_token;
  //blink::WebNavigationTimings navigation_timings;

  const blink::WebURLRequest& request = reinterpret_cast<WebURLRequestWrapper *>(request_ref)->get();
 
  if (item) {
    history_item = reinterpret_cast<blink::WebHistoryItem *>(item);
  } else {
    local_history_item.Initialize();    
  }

  blink::WebFrameLoadType frame_load_type = static_cast<blink::WebFrameLoadType>(web_frame_load_type);

  //blink::FrameLoadType frame_load_type = static_cast<blink::FrameLoadType>(web_frame_load_type);
  //bool history_navigation = _IsBackForwardLoadType(frame_load_type);

  //if (!history_navigation) {
  //  frame->GetFrame()->Loader().GetDocumentLoader()->SetNavigationType(
  //      DetermineNavigationType(frame_load_type, false, false));
  //  if (frame->GetFrame()->Loader().ShouldTreatURLAsSameAsCurrent(request.Url())) {
  //    frame_load_type = blink::kFrameLoadTypeReplaceCurrentItem;
  //  }
  //}

  frame->CommitNavigation(
    request,
    frame_load_type, 
    history_item ? *history_item : local_history_item,
    is_client_redirect != 0,
    devtools_navigation_token);//,
    //std::move(extra_data),
    //navigation_timings);
    //blink::kHistoryDifferentDocumentLoad);
  
  return static_cast<int>(blink::mojom::CommitResult::Ok);
}

int _WebLocalFrameCommitSameDocumentNavigation(
  WebFrameRef handle,
  const char* url,
  int web_frame_load_type,
  WebHistoryItemRef item,
  int is_client_redirect) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  blink::WebHistoryItem local_history_item;
  blink::WebHistoryItem* history_item = nullptr;
  if (item) {
    history_item = reinterpret_cast<blink::WebHistoryItem *>(item);
  } else {
    local_history_item.Initialize();
  }
  blink::mojom::CommitResult result = 
    frame->GetFrame()->Loader().CommitSameDocumentNavigation(
      blink::KURL(String::FromUTF8(url)), 
      static_cast<blink::FrameLoadType>(web_frame_load_type), 
      history_item ? *history_item : local_history_item,
      is_client_redirect ? blink::ClientRedirectPolicy::kClientRedirect
                         : blink::ClientRedirectPolicy::kNotClientRedirect);
  //blink::mojom::CommitResult result = frame->CommitSameDocumentNavigation(
  //  blink::KURL(String::FromUTF8(url)),
  //  static_cast<blink::WebFrameLoadType>(web_frame_load_type),
  //  history_item ? *history_item : local_history_item,
  //  is_client_redirect);
  int int_result = static_cast<int>(result);
  std::string str;
  if (result == blink::mojom::CommitResult::Ok) {
    str = "Ok";  
  } else if (result == blink::mojom::CommitResult::Aborted) {
    str = "Aborted";
  } else if (result == blink::mojom::CommitResult::RestartCrossDocument) {
    str = "RestartCrossDocument";
  }
  //DLOG(INFO) << "_WebLocalFrameCommitSameDocumentNavigation: " << str << " - " << int_result;
  return int_result;
}

void _WebLocalFrameSetTextDirection(WebFrameRef handle, int direction) {
  blink::WebLocalFrame* frame = reinterpret_cast<blink::WebLocalFrame *>(handle);
  frame->SetTextDirection(static_cast<blink::WebTextDirection>(direction));
}

WebInputMethodControllerRef _WebLocalFrameGetInputMethodController(WebFrameRef handle) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  blink::LocalFrame* local_frame = frame->GetFrame();
  return &local_frame->GetInputMethodController();
}

WebEditorRef _WebLocalFrameGetEditor(WebFrameRef handle) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  blink::LocalFrame* local_frame = frame->GetFrame();
  return &local_frame->GetEditor();
}

int _WebLocalFrameIsLocalRoot(WebFrameRef handle) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  return frame->IsLocalRoot();
}

WebFrameRef _WebLocalFrameGetLocalRoot(WebFrameRef handle) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
  return frame->LocalRoot();
}

WebLocalDomWindowRef _WebLocalFrameGetDomWindow(WebFrameRef handle) {
  blink::WebLocalFrameImpl* frame = reinterpret_cast<blink::WebLocalFrameImpl *>(handle);
   blink::LocalFrame* local_frame = frame->GetFrame();
  // LocalDOMWindow*
  return local_frame->DomWindow();
}

// WebWidget
void _WebWidgetClose(WebWidgetRef handle) {
 blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
 widget->Close();
}

void _WebWidgetSize(WebWidgetRef handle, int* width, int* height) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  blink::WebSize size = widget->Size();
  *width = size.width;
  *height = size.height;
}

// void _WebWidgetWillStartLiveResize(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   widget->WillStartLiveResize();
// }

void _WebWidgetResize(WebWidgetRef handle, int width, int height) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->Resize(blink::WebSize(width, height)); 
}

void _WebWidgetResizeVisualViewport(WebWidgetRef handle, int width, int height) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->ResizeVisualViewport(blink::WebSize(width, height)); 
}

// void _WebWidgetWillEndLiveResize(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   widget->WillEndLiveResize();
// }

void _WebWidgetDidEnterFullScreen(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->DidEnterFullscreen();   
}

void _WebWidgetDidExitFullScreen(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->DidExitFullscreen(); 
}

void _WebWidgetBeginFrame(WebWidgetRef handle, double lastFrameTimeMonotonic) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->BeginFrame(base::TimeTicks::FromInternalValue(lastFrameTimeMonotonic));  
}

void _WebWidgetUpdateAllLifecyclePhases(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->UpdateAllLifecyclePhases();
  widget->SetSuppressFrameRequestsWorkaroundFor704763Only(false);
}

void _WebWidgetUpdateLifecycle(WebWidgetRef handle, WebLifecycleUpdateEnum requested_update) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle); 
  widget->UpdateLifecycle(
      static_cast<blink::WebWidget::LifecycleUpdate>(requested_update));
  widget->SetSuppressFrameRequestsWorkaroundFor704763Only(false);
}

void _WebWidgetPaint(WebWidgetRef handle, CanvasRef canvas, int vx, int vy, int vw, int vh) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  cc::SkiaPaintCanvas paint_canvas(reinterpret_cast<SkiaCanvas *>(canvas)->handle());
 
  widget->Paint(&paint_canvas, blink::WebRect(vx, vy, vw, vh));
}

void _WebWidgetPaintIgnoringCompositing(WebWidgetRef handle, CanvasRef canvas, int x, int y, int w, int h) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  cc::SkiaPaintCanvas paint_canvas(reinterpret_cast<SkiaCanvas *>(canvas)->handle());
  widget->PaintIgnoringCompositing(&paint_canvas, blink::WebRect(x, y, w, h)); 
}

void _WebWidgetLayoutAndPaintAsync(WebWidgetRef handle, WebLayoutAndPaintAsyncCallback cb) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
   base::OnceCallback<void()> once_callback = base::BindOnce(
       [](WebLayoutAndPaintAsyncCallback cb) { cb(); }, base::Unretained(cb));
  widget->LayoutAndPaintAsync(std::move(once_callback));//reinterpret_cast<WebLayoutAndPaintAsyncCallback *>(cb));
}

void _WebWidgetCompositeAndReadbackAsync(WebWidgetRef handle, WebCompositeAndReadbackAsyncCallback cb) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  base::OnceCallback<void(const SkBitmap&)> once_callback = base::BindOnce(
       [](WebCompositeAndReadbackAsyncCallback cb, const SkBitmap& bmp) { cb(&bmp); }, base::Unretained(cb));
  widget->CompositeAndReadbackAsync(std::move(once_callback));
}

void _WebWidgetThemeChanged(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->ThemeChanged(); 
}

// TODO: We are completely loosing information giving we are dealing this in a generic way
// we will need to have a method for each type of input event, so we can pass the relevant information
int _WebWidgetHandleInputEvent(WebWidgetRef handle, WebInputEventRef event) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  blink::WebInputEvent* input = reinterpret_cast<blink::WebInputEvent *>(event);
  blink::WebCoalescedInputEvent coalesced_event(*input);
  return static_cast<int>(widget->HandleInputEvent(coalesced_event));
}

void _WebWidgetSetCursorVisibilityState(WebWidgetRef handle, int isVisible) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->SetCursorVisibilityState(isVisible == 0 ? false : true);
}

// int _WebWidgetHasTouchEventHandlersAt(WebWidgetRef handle, int x, int y) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->HasTouchEventHandlersAt(blink::WebPoint(x, y));
// }

void _WebWidgetApplyViewportDeltas(WebWidgetRef handle, 
  float visualViewportDeltaWidth,
  float visualViewportDeltaHeight, 
  float layoutViewportDeltaWidth,
  float layoutViewportDeltaHeight,
  float elasticOverscrollDeltaWidth,
  float elasticOverscrollDeltaHeight,
  float scaleFactor, 
  float topControlsShownRatioDelta) {

  blink::FloatSize visualViewportDelta(visualViewportDeltaWidth, visualViewportDeltaHeight);
  blink::FloatSize layoutViewportDelta(visualViewportDeltaWidth, visualViewportDeltaHeight);
  blink::FloatSize elasticOverscrollDelta(layoutViewportDeltaWidth, layoutViewportDeltaHeight);

  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  
  widget->ApplyViewportDeltas(visualViewportDelta, layoutViewportDelta, elasticOverscrollDelta, scaleFactor, topControlsShownRatioDelta);
}

// void _WebWidgetRecordFrameTimingEvent(WebWidgetRef handle, WebViewFrameTimingEventEnum eventType, int64_t RectId, unsigned* sourceFrame, 
//     double* startTime,
//     double* finishTime,
//     int lenght) {

//    blink::WebVector<blink::WebFrameTimingEvent> events(static_cast<size_t>(lenght));
//    blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);

//    for (int i = 0; i < lenght; i++) {
//      events[i] = blink::WebFrameTimingEvent(sourceFrame[i], startTime[i], finishTime[i]);
//    }

//    widget->RecordFrameTimingEvent(static_cast<blink::WebWidget::FrameTimingEventType>(eventType), RectId, events);
// }

void _WebWidgetMouseCaptureLost(WebWidgetRef handle) {
   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
   widget->MouseCaptureLost();
}

void _WebWidgetSetFocus(WebWidgetRef handle, int focus) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->SetFocus(focus == 0 ? false : true);
}

// int _WebWidgetSetComposition(WebWidgetRef handle, 
//   const char* text, 
//   unsigned* startOffset,
//   unsigned* endOffset,
//   unsigned* color,
//   int* thick, // was bool
//   unsigned* backgroundColor,
//   int lenght, 
//   int selectionStart,
//   int selectionEnd) {

//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);

//   blink::WebVector<blink::WebCompositionUnderline> underlines(static_cast<size_t>(lenght));

//   for (int i = 0; i < lenght; i++) {
//     underlines[i] = blink::WebCompositionUnderline(startOffset[i], endOffset[i], color[i], thick[i], backgroundColor[i]);
//   }

//   return widget->SetComposition(blink::WebString::FromUTF8(text), underlines, selectionStart, selectionEnd) ? 1 : 0; 
// }

// int _WebWidgetConfirmComposition(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->ConfirmComposition() ? 1 : 0; 
// }

// int _WebWidgetConfirmCompositionConfirm(WebWidgetRef handle, WebViewConfirmCompositionBehaviorEnum selectionBehavior) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->ConfirmComposition(static_cast<blink::WebWidget::ConfirmCompositionBehavior>(selectionBehavior)) ? 1 : 0; 
// }

// int _WebWidgetConfirmCompositionText(WebWidgetRef handle, const char* text) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->ConfirmComposition(blink::WebString::FromUTF8(text)) ? 1 : 0;  
// }

// int _WebWidgetCompositionRange(WebWidgetRef handle, size_t* location, size_t* length) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->CompositionRange(location, length) ? 1 : 0;
// }

// void _WebWidgetTextInputInfo(WebWidgetRef handle, WebTextInputTypeEnum* type, int* flags, const char** outValue, int* selectionStart, int* selectionEnd, int* compositionStart, int* compositionEnd, const char** outInputMode) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   blink::WebTextInputInfo info = widget->GetTextInputInfo();
//   *type = static_cast<WebTextInputTypeEnum>(info.type);
//   *flags = info.flags;
//   *outValue = info.value.Utf8().c_str();
//   *selectionStart = info.selection_start; 
//   *selectionEnd = info.selection_end;
//   *compositionStart = info.composition_start;
//   *compositionEnd = info.composition_end; 
//   *outInputMode = info.input_mode.Utf8().c_str();
// }

// WebTextInputTypeEnum _WebWidgetTextInputType(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return static_cast<WebTextInputTypeEnum>(widget->GetTextInputType());
// }

int _WebWidgetSelectionBounds(WebWidgetRef handle, int* ax, int* ay, int* aw, int* ah, int* fx, int* fy, int* fw, int* fh) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  
  blink::WebRect anchor(*ax, *ay, *aw, *ah);
  blink::WebRect focus(*fx, *fy, *fw, *fh);
  
  bool r = widget->SelectionBounds(anchor, focus);

  if (r) {
    *ax = anchor.x;
    *ay = anchor.y;
    *aw = anchor.width;
    *ah = anchor.height;

    *fx = focus.x;
    *fy = focus.y;
    *fw = focus.width;
    *fh = focus.height;
  }

  return r ? 1 : 0;
}

// int _WebWidgetSelectionTextDirection(WebWidgetRef handle, WebTextDirectionEnum* start, WebTextDirectionEnum* end) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);

//   blink::WebTextDirection textStart;
//   blink::WebTextDirection textEnd;

//   bool result = widget->SelectionTextDirection(textStart, textEnd);

//   *start = static_cast<WebTextDirectionEnum>(textStart);
//   *end = static_cast<WebTextDirectionEnum>(textEnd);

//   return result ? 1 : 0;
// }

// int _WebWidgetIsSelectionAnchorFirst(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->IsSelectionAnchorFirst() ? 1 : 0;
// }

// int _WebWidgetCaretOrSelectionRange(WebWidgetRef handle, size_t* location, size_t* length) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   return widget->CaretOrSelectionRange(location, length); 
// }

// void _WebWidgetSetTextDirection(WebWidgetRef handle, WebTextDirectionEnum dir) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   widget->SetTextDirection(static_cast<blink::WebTextDirection>(dir)); 
// }

int _WebWidgetIsAcceleratedCompositingActive(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->IsAcceleratedCompositingActive() ? 1 : 0;
}

int _WebWidgetIsWebView(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->IsWebView() ? 1 : 0; 
}

int _WebWidgetIsWebFrameWidget(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->IsWebFrameWidget() ? 1 : 0; 
}

int _WebWidgetIsPagePopup(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->IsPagePopup() ? 1 : 0; 
}

void _WebWidgetWillCloseLayerTreeView(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->WillCloseLayerTreeView();
}

void _WebWidgetDidAcquirePointerLock(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->DidAcquirePointerLock(); 
}

void _WebWidgetDidNotAcquirePointerLock(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->DidNotAcquirePointerLock(); 
}

void _WebWidgetDidLosePointerLock(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->DidLosePointerLock();  
}

// void _WebWidgetDidChangeWindowResizerRect(WebWidgetRef handle) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   widget->DidChangeWindowResizerRect(); 
// }

int _WebWidgetBackgroundColor(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->BackgroundColor();
}

WebPagePopupRef _WebWidgetPagePopup(WebWidgetRef handle) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  return widget->GetPagePopup();
}

// void _WebWidgetSetTopControlsHeight(WebWidgetRef handle, float height, int /*bool*/ topControlsShrinkLayoutSize) {
//   blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
//   widget->SetTopControlsHeight(height, topControlsShrinkLayoutSize == 0 ? false : true);
// }

void _WebWidgetUpdateBrowserControlsState(WebWidgetRef handle, WebTopControlsStateEnum constraints, WebTopControlsStateEnum current, int /*bool*/ animate) {
  blink::WebWidget* widget = reinterpret_cast<blink::WebWidget *>(handle);
  widget->UpdateBrowserControlsState(static_cast<blink::WebBrowserControlsState>(constraints), static_cast<blink::WebBrowserControlsState>(current), animate == 0 ? false : true);
}

// WebView
WebWidgetRef _WebViewCreate(void* peer, 
  WebViewClientCbs callbacks, 
  WebPageVisibilityStateEnum visibility,
  WebWidgetRef opener,
  void** client_out) {
  // TODO: ownership giving we dont have a wrapper for WebView here
  WebViewClientImpl* client = new WebViewClientImpl(peer, callbacks);
  *client_out = client;
  blink::mojom::PageVisibilityState state = blink::mojom::PageVisibilityState::kVisible;
  if (visibility == WebPageVisibilityStateHidden) {
    state = blink::mojom::PageVisibilityState::kHidden;
  } else if (visibility == WebPageVisibilityStatePrerender) {
    state = blink::mojom::PageVisibilityState::kPrerender;
  }
  blink::WebView* webview = blink::WebView::Create(
      client,
      state,
      opener == nullptr ? nullptr : reinterpret_cast<blink::WebView *>(opener));

  webview->SetDisplayMode(blink::kWebDisplayModeBrowser);
  webview->GetSettings()->SetThreadedScrollingEnabled(true);

  ScriptFontFamilyMap standard_font_family_map;
  ScriptFontFamilyMap fixed_font_family_map;
  ScriptFontFamilyMap serif_font_family_map;
  ScriptFontFamilyMap sans_serif_font_family_map;
  ScriptFontFamilyMap cursive_font_family_map;
  ScriptFontFamilyMap fantasy_font_family_map;
  ScriptFontFamilyMap pictograph_font_family_map;
  
  FillFontFamilyMap("webkit.webprefs.fonts.standard",
                    &standard_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.fixed",
                    &fixed_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.serif",
                    &serif_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.sansserif",
                    &sans_serif_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.cursive",
                    &cursive_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.fantasy",
                    &fantasy_font_family_map);
  FillFontFamilyMap("webkit.webprefs.fonts.pictograph",
                    &pictograph_font_family_map);

  WebSettings* settings = webview->GetSettings();
  ApplyFontsFromMap(standard_font_family_map,
                    SetStandardFontFamilyWrapper, settings);
  ApplyFontsFromMap(fixed_font_family_map,
                    SetFixedFontFamilyWrapper, settings);
  ApplyFontsFromMap(serif_font_family_map,
                    SetSerifFontFamilyWrapper, settings);
  ApplyFontsFromMap(sans_serif_font_family_map,
                    SetSansSerifFontFamilyWrapper, settings);
  ApplyFontsFromMap(cursive_font_family_map,
                    SetCursiveFontFamilyWrapper, settings);
  ApplyFontsFromMap(fantasy_font_family_map,
                    SetFantasyFontFamilyWrapper, settings);
  ApplyFontsFromMap(pictograph_font_family_map,
                    SetPictographFontFamilyWrapper, settings);
 
  settings->SetDefaultFontSize(16);//prefs.default_font_size);
  settings->SetDefaultFixedFontSize(13);//prefs.default_fixed_font_size);
  settings->SetMinimumFontSize(0);//prefs.minimum_font_size);
  settings->SetMinimumLogicalFontSize(6);//prefs.minimum_logical_font_size);
  settings->SetDefaultTextEncodingName(
      WebString::FromASCII("UTF-8"));//prefs.default_encoding));
  settings->SetJavaScriptEnabled(true);
  
  // NOTE: for "test" we should check what this really means
  // (what sort of security is this)
  // FIX: dont forget to review this
  settings->SetWebSecurityEnabled(false);//prefs.web_security_enabled);
  

  settings->SetLoadsImagesAutomatically(true);//prefs.loads_images_automatically);
  settings->SetImagesEnabled(true);
  settings->SetPluginsEnabled(true);
  settings->SetDOMPasteAllowed(true);
  settings->SetTextAreasAreResizable(false);
  settings->SetAllowScriptsToCloseWindows(true);
  settings->SetDownloadableBinaryFontsEnabled(true);
  settings->SetJavaScriptCanAccessClipboard(true);
  WebRuntimeFeatures::EnableXSLT(true);
  settings->SetXSSAuditorEnabled(true);
  settings->SetDNSPrefetchingEnabled(false);
  //blink::WebNetworkStateNotifier::SetSaveDataEnabled(true);//prefs.data_saver_enabled);
  settings->SetLocalStorageEnabled(false);//prefs.local_storage_enabled);
  settings->SetSyncXHRInDocumentsEnabled(true);//prefs.sync_xhr_in_documents_enabled);
  WebRuntimeFeatures::EnableDatabase(false);//prefs.databases_enabled);
  settings->SetOfflineWebApplicationCacheEnabled(true);
  //    prefs.application_cache_enabled);
  settings->SetHistoryEntryRequiresUserGesture(false);
      //prefs.history_entry_requires_user_gesture);
  settings->SetShouldThrottlePushState(true);//!prefs.disable_pushstate_throttle);
  settings->SetHyperlinkAuditingEnabled(false);//prefs.hyperlink_auditing_enabled);
  settings->SetCookieEnabled(true);//prefs.cookie_enabled);
  settings->SetNavigateOnDragDrop(true);//prefs.navigate_on_drag_drop);

  // By default, allow_universal_access_from_file_urls is set to false and thus
  // we mitigate attacks from local HTML files by not granting file:// URLs
  // universal access. Only test shell will enable this.

  // NOTE: this should be temporary, just for testing
  // FIX: remember to disable this
  settings->SetAllowUniversalAccessFromFileURLs(true);
      //prefs.allow_universal_access_from_file_urls);
  settings->SetAllowFileAccessFromFileURLs(true);
      //prefs.allow_file_access_from_file_urls);

  settings->SetWebGL1Enabled(true);//prefs.webgl1_enabled);
  settings->SetWebGL2Enabled(true);//prefs.webgl2_enabled);

  // Enable WebGL errors to the JS console if requested.
  settings->SetWebGLErrorsToConsoleEnabled(true);
      //prefs.webgl_errors_to_console_enabled);

  // Uses the mock theme engine for scrollbars.
  settings->SetMockScrollbarsEnabled(false);//prefs.mock_scrollbars_enabled);

  settings->SetHideScrollbars(false);//prefs.hide_scrollbars);

  // Enable gpu-accelerated 2d canvas if requested on the command line.
  blink::WebRuntimeFeatures::EnableAccelerated2dCanvas(true);
      //prefs.accelerated_2d_canvas_enabled);

  //settings->SetMinimumAccelerated2dCanvasSize(1);
  //    prefs.minimum_accelerated_2d_canvas_size);

  // Disable antialiasing for 2d canvas if requested on the command line.
  settings->SetAntialiased2dCanvasEnabled(true);
      //!prefs.antialiased_2d_canvas_disabled);

  // Disable antialiasing of clips for 2d canvas if requested on the command
  // line.
  settings->SetAntialiasedClips2dCanvasEnabled(true);
      //prefs.antialiased_clips_2d_canvas_enabled);

  // Set MSAA sample count for 2d canvas if requested on the command line (or
  // default value if not).
  settings->SetAccelerated2dCanvasMSAASampleCount(4);
      //prefs.accelerated_2d_canvas_msaa_sample_count);

  // Tabs to link is not part of the settings. WebCore calls
  // ChromeClient::tabsToLinks which is part of the glue code.
  webview->SetTabsToLinks(false);//prefs.tabs_to_links);

  settings->SetAllowRunningOfInsecureContent(true);
      //prefs.allow_running_insecure_content);
  settings->SetDisableReadingFromCanvas(false);//prefs.disable_reading_from_canvas);
  settings->SetStrictMixedContentChecking(false);//prefs.strict_mixed_content_checking);

  settings->SetStrictlyBlockBlockableMixedContent(false);//
  //    prefs.strictly_block_blockable_mixed_content);

  settings->SetStrictMixedContentCheckingForPlugin(true);
 //     prefs.block_mixed_plugin_content);

  settings->SetStrictPowerfulFeatureRestrictions(false);
  //    prefs.strict_powerful_feature_restrictions);
  settings->SetAllowGeolocationOnInsecureOrigins(true);
  //    prefs.allow_geolocation_on_insecure_origins);
  
  settings->SetPasswordEchoEnabled(false);//prefs.password_echo_enabled);
  settings->SetShouldPrintBackgrounds(true);//prefs.should_print_backgrounds);
  settings->SetShouldClearDocumentBackground(false);//
  //    prefs.should_clear_document_background);
  settings->SetEnableScrollAnimator(true);//prefs.enable_scroll_animator);

  //WebRuntimeFeatures::EnableTouchEventFeatureDetection(true);
  //    prefs.touch_event_feature_detection_enabled);
  //settings->SetMaxTouchPoints(6);//prefs.pointer_events_max_touch_points);
  //settings->SetAvailablePointerTypes(prefs.available_pointer_types);
  //settings->SetPrimaryPointerType(
  //    static_cast<blink::PointerType>(prefs.primary_pointer_type));
  //settings->SetAvailableHoverTypes(prefs.available_hover_types);
  //settings->SetPrimaryHoverType(
  //    static_cast<blink::HoverType>(prefs.primary_hover_type));
  //settings->SetEnableTouchAdjustment(prefs.touch_adjustment_enabled);
  settings->SetBarrelButtonForDragEnabled(true);//prefs.barrel_button_for_drag_enabled);

  settings->SetShouldRespectImageOrientation(
      true);
  //    prefs.should_respect_image_orientation);

  settings->SetEditingBehavior(blink::WebSettings::kEditingBehaviorUnix);

  settings->SetSupportsMultipleWindows(true);//prefs.supports_multiple_windows);

  settings->SetMainFrameClipsContent(false);//!prefs.record_whole_document);

  settings->SetSmartInsertDeleteEnabled(false);//prefs.smart_insert_delete_enabled);

  settings->SetSpatialNavigationEnabled(false);//prefs.spatial_navigation_enabled);

  settings->SetSelectionIncludesAltImageText(true);

  settings->SetV8CacheOptions(blink::WebSettings::kV8CacheOptionsFullCodeWithoutHeatCheck);//blink::WebSettings::kV8CacheOptionsNone);
  //    static_cast<WebSettings::V8CacheOptions>(prefs.v8_cache_options));

  settings->SetImageAnimationPolicy(blink::WebSettings::kImageAnimationPolicyAllowed);

  settings->SetPresentationRequiresUserGesture(false);
      //prefs.user_gesture_required_for_presentation);

  //settings->SetTextTrackMarginPercentage(0);//prefs.text_track_margin_percentage);

  // Needs to happen before setIgnoreVIewportTagScaleLimits below.
  webview->SetDefaultPageScaleLimits(1.0,
                                     1.0);

  // TODO: fix for later
  settings->SetSavePreviousDocumentResources(blink::WebSettings::SavePreviousDocumentResources::kNever);
     // static_cast<WebSettings::SavePreviousDocumentResources>(
     //     prefs.save_previous_document_resources));

// #if defined(OS_ANDROID)
//   settings->SetAllowCustomScrollbarInMainFrame(false);
//   settings->SetTextAutosizingEnabled(prefs.text_autosizing_enabled);
//   settings->SetAccessibilityFontScaleFactor(prefs.font_scale_factor);
//   settings->SetDeviceScaleAdjustment(prefs.device_scale_adjustment);
//   settings->SetFullscreenSupported(prefs.fullscreen_supported);
//   web_view->SetIgnoreViewportTagScaleLimits(prefs.force_enable_zoom);
//   settings->SetAutoZoomFocusedNodeToLegibleScale(true);
//   settings->SetDoubleTapToZoomEnabled(prefs.double_tap_to_zoom_enabled);
//   settings->SetMediaPlaybackGestureWhitelistScope(
//       blink::WebString::FromUTF8(prefs.media_playback_gesture_whitelist_scope));
//   settings->SetDefaultVideoPosterURL(
//       WebString::FromASCII(prefs.default_video_poster_url.spec()));
//   settings->SetSupportDeprecatedTargetDensityDPI(
//       prefs.support_deprecated_target_density_dpi);
//   settings->SetUseLegacyBackgroundSizeShorthandBehavior(
//       prefs.use_legacy_background_size_shorthand_behavior);
//   settings->SetWideViewportQuirkEnabled(prefs.wide_viewport_quirk);
//   settings->SetUseWideViewport(prefs.use_wide_viewport);
//   settings->SetForceZeroLayoutHeight(prefs.force_zero_layout_height);
//   settings->SetViewportMetaLayoutSizeQuirk(
//       prefs.viewport_meta_layout_size_quirk);
//   settings->SetViewportMetaMergeContentQuirk(
//       prefs.viewport_meta_merge_content_quirk);
//   settings->SetViewportMetaNonUserScalableQuirk(
//       prefs.viewport_meta_non_user_scalable_quirk);
//   settings->SetViewportMetaZeroValuesQuirk(
//       prefs.viewport_meta_zero_values_quirk);
//   settings->SetClobberUserAgentInitialScaleQuirk(
//       prefs.clobber_user_agent_initial_scale_quirk);
//   settings->SetIgnoreMainFrameOverflowHiddenQuirk(
//       prefs.ignore_main_frame_overflow_hidden_quirk);
//   settings->SetReportScreenSizeInPhysicalPixelsQuirk(
//       prefs.report_screen_size_in_physical_pixels_quirk);
//   settings->SetShouldReuseGlobalForUnownedMainFrame(
//       prefs.reuse_global_for_unowned_main_frame);
//   settings->SetPreferHiddenVolumeControls(true);
//   settings->SetSpellCheckEnabledByDefault(prefs.spellcheck_enabled_by_default);

//   // Force preload=none and disable autoplay on older Android
//   // platforms because their media pipelines are not stable enough to handle
//   // concurrent elements. See http://crbug.com/612909, http://crbug.com/622826.
//   const bool is_jelly_bean =
//       base::android::BuildInfo::GetInstance()->sdk_int() <=
//       base::android::SDK_VERSION_JELLY_BEAN_MR2;
//   settings->SetForcePreloadNoneForMediaElements(is_jelly_bean);

//   WebRuntimeFeatures::EnableVideoFullscreenOrientationLock(
//       prefs.video_fullscreen_orientation_lock_enabled);
//   WebRuntimeFeatures::EnableVideoRotateToFullscreen(
//       prefs.video_rotate_to_fullscreen_enabled);
//   WebRuntimeFeatures::EnableVideoFullscreenDetection(
//       prefs.video_fullscreen_detection_enabled);
//   settings->SetEmbeddedMediaExperienceEnabled(
//       prefs.embedded_media_experience_enabled);
//   settings->SetImmersiveModeEnabled(prefs.immersive_mode_enabled);
//   settings->SetMediaDownloadInProductHelpEnabled(
//       prefs.enable_media_download_in_product_help);
//   settings->SetDoNotUpdateSelectionOnMutatingSelectionRange(
//       prefs.do_not_update_selection_on_mutating_selection_range);
//   WebRuntimeFeatures::EnableCSSHexAlphaColor(prefs.css_hex_alpha_color_enabled);
//   WebRuntimeFeatures::EnableScrollTopLeftInterop(
//       prefs.scroll_top_left_interop_enabled);
// #endif  // defined(OS_ANDROID)

  // switch (prefs.autoplay_policy) {
  //   case AutoplayPolicy::kNoUserGestureRequired:
  //     settings->SetAutoplayPolicy(
  //         WebSettings::AutoplayPolicy::kNoUserGestureRequired);
  //     break;
  //   case AutoplayPolicy::kUserGestureRequired:
  //     settings->SetAutoplayPolicy(
  //         WebSettings::AutoplayPolicy::kUserGestureRequired);
  //     break;
  //   case AutoplayPolicy::kUserGestureRequiredForCrossOrigin:
  //     settings->SetAutoplayPolicy(
  //         WebSettings::AutoplayPolicy::kUserGestureRequiredForCrossOrigin);
  //     break;
  //   case AutoplayPolicy::kDocumentUserActivationRequired:
      settings->SetAutoplayPolicy(
          blink::WebSettings::AutoplayPolicy::kDocumentUserActivationRequired);
 //     break;
  //}

  settings->SetViewportEnabled(true);//prefs.viewport_enabled);
  settings->SetViewportMetaEnabled(true);//prefs.viewport_meta_enabled);
  settings->SetShrinksViewportContentToFit(true);
  //    prefs.shrinks_viewport_contents_to_fit);
  settings->SetViewportStyle(blink::WebViewportStyle::kDefault);

  settings->SetLoadWithOverviewMode(true);//prefs.initialize_at_minimum_page_scale);
  settings->SetMainFrameResizesAreOrientationChanges(false);
      //prefs.main_frame_resizes_are_orientation_changes);

  settings->SetUseSolidColorScrollbars(true);//prefs.use_solid_color_scrollbars);

  settings->SetShowContextMenuOnMouseUp(false);//prefs.context_menu_on_mouse_up);
  settings->SetAlwaysShowContextMenuOnTouch(false);
  //    prefs.always_show_context_menu_on_touch);
  settings->SetSmoothScrollForFindEnabled(true);//prefs.smooth_scroll_for_find_enabled);

  settings->SetHideDownloadUI(true);//prefs.hide_download_ui);
  WebRuntimeFeatures::EnableBackgroundVideoTrackOptimization(true);
      //prefs.background_video_track_optimization_enabled);
  WebRuntimeFeatures::EnableNewRemotePlaybackPipeline(true);
  //    base::FeatureList::IsEnabled(media::kNewRemotePlaybackPipeline));

  //settings->SetPresentationReceiver(prefs.presentation_receiver);

  settings->SetMediaControlsEnabled(true);//prefs.media_controls_enabled);

  //settings->SetLowPriorityIframesThreshold(
  //    static_cast<blink::WebEffectiveConnectionType>(
  //        prefs.low_priority_iframes_threshold));

  settings->SetPictureInPictureEnabled(true);//prefs.picture_in_picture_enabled);

  //settings->SetDataSaverHoldbackWebApi(
  //    prefs.data_saver_holdback_web_api_enabled);
  //settings->SetDataSaverHoldbackMediaApi(
  //    prefs.data_saver_holdback_media_api_enabled);

#if defined(OS_MACOSX)
  settings->SetDoubleTapToZoomEnabled(true);
  web_view->SetMaximumLegibleScale(10.0);//prefs.default_maximum_page_scale_factor);
#endif

#if defined(OS_WIN)
  WebRuntimeFeatures::EnableMiddleClickAutoscroll(true);
#endif
  settings->SetPreferCompositingToLCDTextEnabled(true);

  return webview;
}

void _WebViewDestroy(WebWidgetRef handle) {
  // TODO: how we will clean this up? inherit?
  //delete reinterpret_cast<blink::WebViewImpl *>(handle);
}

double _WebViewZoomLevelToZoomFactor(double zoomLevel) {
  return blink::WebView::ZoomLevelToZoomFactor(zoomLevel);
}

double _WebViewZoomFactorToZoomLevel(double zoomLevel) {
  return blink::WebView::ZoomFactorToZoomLevel(zoomLevel);
}

void _WebViewWillEnterModalLoop() {
  blink::WebView::WillEnterModalLoop();
}

void _WebViewDidExitModalLoop() {
  blink::WebView::DidExitModalLoop();
}

void _WebViewSetUseExternalPopupMenus(int use) {
  blink::WebView::SetUseExternalPopupMenus(use == 0 ? false : true);
}

void _WebViewUpdateVisitedLinkState(uint64_t hash) {
  blink::WebView::UpdateVisitedLinkState(hash);
}

void _WebViewResetVisitedLinkState(int invalidate_visited_link_hashes) {
  blink::WebView::ResetVisitedLinkState(invalidate_visited_link_hashes == 1 ? true : false);
}

// void _WebViewSetMainFrame(WebWidgetRef handle, WebFrameRef frame) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetMainFrame(reinterpret_cast<blink::WebFrame *>(frame));
// }

// void _WebViewSetCredentialManagerClient(WebWidgetRef handle, void* client) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetCredentialManagerClient(reinterpret_cast<blink::WebCredentialManagerClient *>(client));
// }

void _WebViewSetPrerendererClient(WebWidgetRef handle, void* client) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetPrerendererClient(reinterpret_cast<blink::WebPrerendererClient *>(client));
}

// void _WebViewSetSpellCheckClient(WebWidgetRef handle, void* client) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetSpellCheckClient(reinterpret_cast<blink::WebSpellCheckClient *>(client)); 
// }

WebSettingsRef _WebViewSettings(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->GetSettings();
}

char* _WebViewPageEncoding(WebWidgetRef handle, int* len) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebString text = view->PageEncoding();
  char* result = (char*)malloc(text.length());
  memcpy(result, text.Utf8().c_str(), text.Utf8().length());
  *len = text.Utf8().length();
  return result;
}

// void _WebViewSetPageEncoding(WebWidgetRef handle, const char* encoding) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetPageEncoding(blink::WebString::FromUTF8(encoding));
// }

// int _WebViewIsTransparent(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return view->IsTransparent() ? 1 : 0;
// }

// void _WebViewSetIsTransparent(WebWidgetRef handle, int /*bool*/ transparent) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetIsTransparent(transparent == 0 ? false : true);
// }

// void _WebViewSetBaseBackgroundColor(WebWidgetRef handle, unsigned color) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SetBaseBackgroundColor(color);
// }

int _WebViewTabsToLinks(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->TabsToLinks() ? 1 : 0;
}

void _WebViewSetTabsToLinks(WebWidgetRef handle, int /*bool*/ tabs) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetTabsToLinks(tabs == 0 ? false : true); 
}

int _WebViewTabKeyCyclesThroughElements(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->TabKeyCyclesThroughElements() ? 1 : 0; 
}

void _WebViewSetTabKeyCyclesThroughElements(WebWidgetRef handle, int /*bool*/ tabkeycycle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetTabKeyCyclesThroughElements(tabkeycycle == 0 ? false : true);   
}

int _WebViewIsActive(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->IsActive() ? true : false;
}

void _WebViewSetIsActive(WebWidgetRef handle, int /*bool*/ active) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetIsActive(active == 0 ? false : true);
}

void _WebViewSetDomainRelaxationForbidden(WebWidgetRef handle, int /*bool*/ forbidden, const char* scheme) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetDomainRelaxationForbidden(forbidden == 0 ? false : true, blink::WebString::FromUTF8(scheme));
}

void _WebViewSetWindowFeatures(WebWidgetRef handle, 
  float x, 
  int /*bool*/ xSet, 
  float y, 
  int /*bool*/ ySet, 
  float width, 
  int /*bool*/ widthSet, 
  float height, 
  int /*bool*/ heightSet, 
  int /*bool*/ menuBarVisible, 
  int /*bool*/ statusBarVisible, 
  int /*bool*/ toolBarVisible, 
  int /*bool*/ scrollbarsVisible, 
  int /*bool*/ resizable,
  int /*bool*/ noopener, 
  int /*bool*/ background, 
  int /*bool*/ persistent) {

  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebWindowFeatures features;

  features.x = x;
  features.x_set = xSet == 0 ? false : true;
  features.y = y;
  features.y_set = ySet == 0 ? false : true;
  features.width = width;
  features.width_set = widthSet == 0 ? false : true;
  features.height = height;
  features.height_set = heightSet == 0 ? false : true;

  features.menu_bar_visible = menuBarVisible == 0 ? false : true;
  features.status_bar_visible = statusBarVisible == 0 ? false : true;
  features.tool_bar_visible = toolBarVisible == 0 ? false : true;
  features.scrollbars_visible = scrollbarsVisible == 0 ? false : true;
  features.resizable = resizable == 0 ? false : true;
  features.noopener = noopener == 0 ? false : true;
  features.background = background == 0 ? false : true;
  features.persistent = persistent == 0 ? false : true;

  view->SetWindowFeatures(features);
} 

void _WebViewSetOpenedByDOM(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetOpenedByDOM();
}

WebFrameRef _WebViewMainFrame(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->MainFrame();
}

// WebFrameRef _WebViewFindFrameByName(WebWidgetRef handle, const char* name, WebFrameRef relativeToFrame) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebFrame* result = nullptr;
//   if (relativeToFrame) {
//     result = view->FindFrameByName(blink::WebString::FromUTF8(name), reinterpret_cast<blink::WebFrame *>(relativeToFrame));
//   } else {
//     result = view->FindFrameByName(blink::WebString::FromUTF8(name));
//   }
//   return result;
// }

WebFrameRef _WebViewFocusedFrame(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->FocusedFrame();
}

void _WebViewSetFocusedFrame(WebWidgetRef handle, WebFrameRef frame) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetFocusedFrame(reinterpret_cast<blink::WebFrame *>(frame));
}

void _WebViewFocusDocumentView(WebWidgetRef handle, WebFrameRef frame) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->FocusDocumentView(reinterpret_cast<blink::WebFrame *>(frame)); 
}

void _WebViewSetInitialFocus(WebWidgetRef handle, int /*bool*/ reverse) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetInitialFocus(reverse);
}

void _WebViewClearFocusedElement(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->ClearFocusedElement();
}

// int _WebViewScrollFocusedNodeIntoRect(WebWidgetRef handle, int rx, int ry, int rw, int rh) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return view->ScrollFocusedNodeIntoRect(blink::WebRect(rx, ry, rw, rh)) ? 1 : 0;
// }

void _WebViewSmoothScroll(WebWidgetRef handle, int targetX, int targetY, int64_t durationMs) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SmoothScroll(targetX, targetY, durationMs);
}

void _WebViewAdvanceFocus(WebWidgetRef handle, int /*bool*/ reverse) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->AdvanceFocus(reverse == 0 ? false : true);
}

int _WebViewZoomToMultipleTargetsRect(WebWidgetRef handle, int rx, int ry, int rw, int rh) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->ZoomToMultipleTargetsRect(blink::WebRect(rx, ry, rw, rh)) ? 1 : 0; 
}

double _WebViewZoomLevel(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->ZoomLevel(); 
}

double _WebViewSetZoomLevel(WebWidgetRef handle, double level) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->SetZoomLevel(level);
}

void _WebViewZoomLimitsChanged(WebWidgetRef handle, double minimumZoomLevel, double maximumZoomLevel) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->ZoomLimitsChanged(minimumZoomLevel, maximumZoomLevel);
}

float _WebViewTextZoomFactor(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->TextZoomFactor(); 
}

float _WebViewSetTextZoomFactor(WebWidgetRef handle, float factor) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->SetTextZoomFactor(factor);
}

float _WebViewPageScaleFactor(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->PageScaleFactor();
}

void _WebViewSetPageScaleFactor(WebWidgetRef handle, float scale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->SetPageScaleFactor(scale);
}

void _WebViewSetVisualViewportOffset(WebWidgetRef handle, float px, float py) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetVisualViewportOffset(blink::WebFloatPoint(px, py));
}

void _WebViewVisualViewportOffset(WebWidgetRef handle, float* px, float* py) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebFloatPoint pt = view->VisualViewportOffset();
  *px = pt.x;
  *py = pt.y;
}

void _WebViewVisualViewportSize(WebWidgetRef handle, float* width, float* height) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebFloatSize size = view->VisualViewportSize();
  *width = size.width;
  *height = size.height;
}

void _WebViewSetDefaultPageScaleLimits(WebWidgetRef handle, float minScale, float maxScale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetDefaultPageScaleLimits(minScale, maxScale);
}

void _WebViewSetInitialPageScaleOverride(WebWidgetRef handle, float scale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetInitialPageScaleOverride(scale);
}

void _WebViewSetMaximumLegibleScale(WebWidgetRef handle, float scale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetMaximumLegibleScale(scale);
}

void _WebViewResetScrollAndScaleState(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->ResetScrollAndScaleState();
}

void _WebViewSetIgnoreViewportTagScaleLimits(WebWidgetRef handle, int limits) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetIgnoreViewportTagScaleLimits(limits);
}

void _WebViewContentsPreferredMinimumSize(WebWidgetRef handle, int* width, int* height) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebSize size = view->ContentsPreferredMinimumSize();
  *width = size.width;
  *height = size.height;
}

void _WebViewSetDisplayMode(WebWidgetRef handle, WebDisplayModeEnum mode) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetDisplayMode(static_cast<blink::WebDisplayMode>(mode));
}

void _WebViewSetDeviceScaleFactor(WebWidgetRef handle, float scale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetDeviceScaleFactor(scale);
}

float _WebViewZoomFactorForDeviceScaleFactor(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->ZoomFactorForDeviceScaleFactor();  
}

void _WebViewSetZoomFactorForDeviceScaleFactor(WebWidgetRef handle, float scale) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetZoomFactorForDeviceScaleFactor(scale);
}

// void _WebViewSetDeviceColorProfile(WebWidgetRef handle, char* profile, size_t len) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebVector<char> profiles(len);

//   for (size_t i = 0; i < len ; i++) {
//     profiles[i] = profile[i];
//   }

//   view->SetDeviceColorProfile(profiles);
// }

// void _WebViewResetDeviceColorProfile(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->ResetDeviceColorProfile();
// }

void _WebViewEnableAutoResizeMode(WebWidgetRef handle, int minSizeWidth, int minSizeHeight, int maxSizeWidth, int maxSizeHeight) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->EnableAutoResizeMode(blink::WebSize(minSizeWidth, minSizeHeight), blink::WebSize(maxSizeWidth, maxSizeHeight));
}

void _WebViewDisableAutoResizeMode(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->DisableAutoResizeMode(); 
}

void _WebViewPerformMediaPlayerAction(WebWidgetRef handle, WebMediaPlayerActionEnum action_type, int /*bool*/ action_enable, int locationX, int locationY) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebMediaPlayerAction action(static_cast<blink::WebMediaPlayerAction::Type>(action_type), action_enable == 0 ? false : true);
  view->PerformMediaPlayerAction(action, blink::WebPoint(locationX, locationY));
}

void _WebViewPerformPluginAction(WebWidgetRef handle, WebPluginActionEnum action_type, int /*bool*/ action_enable, int px, int py) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  blink::WebPluginAction action(static_cast<blink::WebPluginAction::Type>(action_type), action_enable == 0 ? false : true);
  view->PerformPluginAction(action, blink::WebPoint(px, py)); 
}

WebHitTestResultRef _WebViewHitTestResultAt(WebWidgetRef handle, int px, int py) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return new WebHitTestResultWrapper(view->HitTestResultAt(blink::WebPoint(px, py)));
}

WebHitTestResultRef _WebViewHitTestResultForTap(WebWidgetRef handle, int tapPointX, int tapPointY, int tapAreaWidth, int tapAreaHeight) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return new WebHitTestResultWrapper(view->HitTestResultForTap(blink::WebPoint(tapPointX, tapPointY), blink::WebSize(tapAreaWidth, tapAreaHeight)));
}

// void _WebViewCopyImageAt(WebWidgetRef handle, int px, int py) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->CopyImageAt(blink::WebPoint(px, py)); 
// }

// void _WebViewSaveImageAt(WebWidgetRef handle, int px, int py) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->SaveImageAt(blink::WebPoint(px, py));
// }

// void _WebViewDragSourceEndedAt(WebWidgetRef handle, int clientX, int clientY, int screenX, int screenY, WebDragOperationEnum operation) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->DragSourceEndedAt(blink::WebPoint(clientX, clientY), blink::WebPoint(screenX, screenY), static_cast<blink::WebDragOperation>(operation)); 
// }

// void _WebViewDragSourceSystemDragEnded(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->DragSourceSystemDragEnded();
// }

// WebDragOperationEnum _WebViewDragTargetDragEnter(WebWidgetRef handle, WebDragDataRef drag, int clientx, int clienty, int screenx, int screeny, WebDragOperationsMask operationsAllowed, int modifiers) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  
//   return static_cast<WebDragOperationEnum>(view->DragTargetDragEnter(
//     *reinterpret_cast<blink::WebDragData *>(drag),
//     blink::WebPoint(clientx, clienty), 
//     blink::WebPoint(screenx, screeny),   
//     static_cast<blink::WebDragOperationsMask>(operationsAllowed),
//     modifiers));
// }

// WebDragOperationEnum _WebViewDragTargetDragOver(WebWidgetRef handle, int clientx, int clienty, int screenx, int screeny, WebDragOperationsMask operationsAllowed, int modifiers) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return static_cast<WebDragOperationEnum>(view->DragTargetDragOver(
//           blink::WebPoint(clientx, clienty), 
//           blink::WebPoint(screenx, screeny),
//           static_cast<blink::WebDragOperationsMask>(operationsAllowed), 
//           modifiers));
// }

// void _WebViewDragTargetDragLeave(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->DragTargetDragLeave();
// }

// void _WebViewDragTargetDrop(WebWidgetRef handle, int px, int py, int screenx, int screeny, int modifiers) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->DragTargetDrop(blink::WebPoint(px, py), blink::WebPoint(screenx, screeny), modifiers);
// }

// size_t _WebViewSpellingMarkersLenght(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebVector<uint32_t> markersvec;
//   view->SpellingMarkers(&markersvec);
//   return markersvec.size();
// }

// void _WebViewSpellingMarkers(WebWidgetRef handle, uint32_t* markers, size_t* len, size_t maxlen) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebVector<uint32_t> markersvec;
//   view->SpellingMarkers(&markersvec);

//   *len = markersvec.size();
  
//   for (size_t i = 0; i < markersvec.size(); i++) {
//     if (i + 1 == maxlen) {
//       *len = i + 1;
//       break;
//     }
//     markers[i] = markersvec[i];
//   }

// }

// void _WebViewRemoveSpellingMarkersUnderWords(WebWidgetRef handle, const char** words, size_t len) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebVector<blink::WebString> wordvec(len);
  
//   for (size_t i = 0; i < len; i++) {
//     wordvec[i] = blink::WebString::FromUTF8(words[i]);
//   }

//   view->RemoveSpellingMarkersUnderWords(wordvec);
// }

unsigned long _WebViewCreateUniqueIdentifierForRequest(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->CreateUniqueIdentifierForRequest();
}

void _WebViewEnableDeviceEmulation(WebWidgetRef handle,
    WebScreenPosition screenPosition,
    int screenSizeWidth,
    int screenSizeHeight,
    int viewPositionX,
    int viewPositionY,
    float deviceScaleFactor,
    int viewSizeWidth,
    int viewSizeHeight,
    //int fitToView,
    float offsetX,
    float offsetY,
    float scale) {

    blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
    
    blink::WebDeviceEmulationParams params;
    params.screen_position = static_cast<blink::WebDeviceEmulationParams::ScreenPosition>(screenPosition);
    params.screen_size = blink::WebSize(screenSizeWidth, screenSizeHeight);
    params.view_position = blink::WebPoint(viewPositionX, viewPositionY);
    params.device_scale_factor = deviceScaleFactor;
    params.view_size = blink::WebSize(viewSizeWidth, viewSizeHeight);
    //params.fit_to_view = fitToView == 0 ? false : true;
    params.viewport_offset = blink::WebFloatPoint(offsetX, offsetY);
    params.scale = scale;

    view->EnableDeviceEmulation(params);
}

void _WebViewDisableDeviceEmulation(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->DisableDeviceEmulation();
}

// WebAXObjectRef _WebViewAccessibilityObject(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return view->AccessibilityObject();
// }

void _WebViewPerformCustomContextMenuAction(WebWidgetRef handle, unsigned action) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->PerformCustomContextMenuAction(action);
}

// void _WebViewShowContextMenu(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   view->ShowContextMenu();
// }

// void _WebViewExtractSmartClipData(WebWidgetRef handle, int x, int y, int w, int h, const char* text, const char* html, int* rx, int* ry, int* rw, int* rh) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebRect result;
//   blink::WebString webText = blink::WebString::FromUTF8(text);
//   blink::WebString webHtml = blink::WebString::FromUTF8(html);
//   view->extractSmartClipData(blink::WebRect(x, y, w, h), webText, webHtml, result);
//   *rx = result.x;
//   *ry = result.y;
//   *rw = result.width; 
//   *rh = result.height;  
// }

void _WebViewHidePopups(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->HidePopups();
}

void _WebViewSetSelectionColors(WebWidgetRef handle, int activeBackgroundColor, int activeForegroundColor, int inactiveBackgroundColor, int inactiveForegroundColor) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetSelectionColors(activeBackgroundColor, activeForegroundColor, inactiveBackgroundColor, inactiveForegroundColor);
}

// void _WebViewTransferActiveWheelFlingAnimation(WebWidgetRef handle, 
//   int dx, int dy,
//   int px, int py,
//   int gx, int gy,
//   int modifiers,
//   WebGestureDeviceEnum sourceDevice,
//   int cumulativeScrollWidth, int cumulativeScrollHeight,
//   double startTime) {

//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   blink::WebActiveWheelFlingParameters params;  
//   params.delta = blink::WebFloatPoint(dx, dy);
//   params.point = blink::WebPoint(px, py);
//   params.globalPoint = blink::WebPoint(gx, gy);
//   params.modifiers = modifiers;
//   params.sourceDevice = static_cast<blink::WebGestureDevice>(sourceDevice);
//   params.cumulativeScroll = blink::WebSize(cumulativeScrollWidth, cumulativeScrollHeight);
//   params.startTime = startTime;

//   view->TransferActiveWheelFlingAnimation(params);
// }

// int _WebViewEndActiveFlingAnimation(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return view->EndActiveFlingAnimation();
// }

void _WebViewSetShowPaintRects(WebWidgetRef handle, int /*bool*/ show) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetShowPaintRects(show == 0 ? false : true);
}

void _WebViewSetShowFPSCounter(WebWidgetRef handle, int /*bool*/ show) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetShowFPSCounter(show == 0 ? false : true);  
}

void _WebViewSetShowScrollBottleneckRects(WebWidgetRef handle, int show) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetShowScrollBottleneckRects(show == 0 ? false : true);
}

void _WebViewSetVisibilityState(WebWidgetRef handle, WebPageVisibilityStateEnum visibilityState, int isInitialState) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetVisibilityState(static_cast<blink::mojom::PageVisibilityState>(visibilityState), isInitialState == 0 ? false : true);
}

void _WebViewSetPageOverlayColor(WebWidgetRef handle, uint8_t a, uint8_t r, uint8_t g, uint8_t b) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->SetPageOverlayColor(SkColorSetARGB(a, r, g, b)); 
}

// WebCompositedDisplayListRef _WebViewGetCompositedDisplayList(WebWidgetRef handle) {
//   blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
//   return view->CompositedDisplayList();
// }

WebPageImportanceSignalsRef _WebViewGetPageImportanceSignals(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  return view->PageImportanceSignals();
}

void _WebViewAcceptLanguagesChanged(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->AcceptLanguagesChanged(); 
}

void _WebViewDidCloseContextMenu(WebWidgetRef handle) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(handle);
  view->DidCloseContextMenu();
}

int _WebViewHasFocusedFrame(WebWidgetRef reference) {
  blink::WebView* view = reinterpret_cast<blink::WebView *>(reference);
  return view->FocusedFrame() != nullptr;
}

WebHTTPLoadInfoRef _WebHTTPLoadInfoCreate() {
  return new WebHTTPLoadInfoWrapper();
}
// WebHTTPLoadInfo
void _WebHTTPLoadInfoDestroy(WebHTTPLoadInfoRef handle) {
  delete reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle);
}

int _WebHTTPLoadInfoGetHttpStatusCode(WebHTTPLoadInfoRef handle) {
  return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->httpStatusCode();
}

void _WebHTTPLoadInfoSetHttpStatusCode(WebHTTPLoadInfoRef handle, int code) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->setHTTPStatusCode(code); 
}

const char* _WebHTTPLoadInfoGetHttpStatusText(WebHTTPLoadInfoRef handle) {
  return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->httpStatusText().Utf8().data();
}

void _WebHTTPLoadInfoSetHttpStatusText(WebHTTPLoadInfoRef handle, const char* status) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->setHTTPStatusText(String::FromUTF8(status));
}

// int64_t _WebHTTPLoadInfoGetEncodedDataLength(WebHTTPLoadInfoRef handle) {
//   return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->EncodedDataLength();
// }

// void _WebHTTPLoadInfoSetEncodedDataLength(WebHTTPLoadInfoRef handle, int64_t len) {
//   reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->SetEncodedDataLength(len);
// }

const char* _WebHTTPLoadInfoGetRequestHeadersText(WebHTTPLoadInfoRef handle) {
  return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->requestHeadersText().Utf8().data();
}

void _WebHTTPLoadInfoSetRequestHeadersText(WebHTTPLoadInfoRef handle, const char* headers) {
 reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->setRequestHeadersText(String::FromUTF8(headers));
}

const char* _WebHTTPLoadInfoGetResponseHeadersText(WebHTTPLoadInfoRef handle) {
  return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->responseHeadersText().Utf8().data();
}

void _WebHTTPLoadInfoSetResponseHeadersText(WebHTTPLoadInfoRef handle, const char* headers) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->setResponseHeadersText(String::FromUTF8(headers));
}

const char* _WebHTTPLoadInfoGetNpnNegotiatedProtocol(WebHTTPLoadInfoRef handle) {
  return reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->npnNegotiatedProtocol().Utf8().data();
}

void _WebHTTPLoadInfoSetNpnNegotiatedProtocol(WebHTTPLoadInfoRef handle, const char* proto) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->setNPNNegotiatedProtocol(String::FromUTF8(proto));
}

void _WebHTTPLoadInfoAddRequestHeader(WebHTTPLoadInfoRef handle, const char* name, const char* value) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->addRequestHeader(AtomicString(name), AtomicString(value));
}

void _WebHTTPLoadInfoAddResponseHeader(WebHTTPLoadInfoRef handle, const char* name, const char* value) {
  reinterpret_cast<WebHTTPLoadInfoWrapper *>(handle)->addResponseHeader(AtomicString(name), AtomicString(value));
}

// WebHTTPBody

WebHTTPBodyRef _WebHTTPBodyCreate() {
  blink::WebHTTPBody* body = new blink::WebHTTPBody();
  
  body->Initialize();
  
  return body;
}

void _WebHTTPBodyDestroy(WebHTTPBodyRef handle) {
  delete reinterpret_cast<blink::WebHTTPBody *>(handle);
}

int _WebHTTPBodyGetElementCount(WebHTTPBodyRef handle) {
  return static_cast<int>(reinterpret_cast<blink::WebHTTPBody *>(handle)->ElementCount());
}

int64_t _WebHTTPBodyGetIdentifier(WebHTTPBodyRef handle) {
  return reinterpret_cast<blink::WebHTTPBody *>(handle)->Identifier();
}

void _WebHTTPBodySetIdentifier(WebHTTPBodyRef handle, int64_t identifier) {
  reinterpret_cast<blink::WebHTTPBody *>(handle)->SetIdentifier(identifier);
}

int _WebHTTPBodyGetContainsPasswordData(WebHTTPBodyRef handle) {
  return reinterpret_cast<blink::WebHTTPBody *>(handle)->ContainsPasswordData() ? 1 : 0;
}

void _WebHTTPBodySetContainsPasswordData(WebHTTPBodyRef handle, int contains) {
  reinterpret_cast<blink::WebHTTPBody *>(handle)->SetContainsPasswordData(contains == 0 ? false : true);
}

int _WebHTTPBodyGetElementDataSizeAt(WebHTTPBodyRef handle, int index) {
  blink::WebHTTPBody::Element element;
  bool result = reinterpret_cast<blink::WebHTTPBody *>(handle)->ElementAt(static_cast<size_t>(index), element);
  if (!result) {
    return -1;
  }  
  return element.data.size();
}

int _WebHTTPBodyGetElementAt(WebHTTPBodyRef handle, 
        int index,
        int* kind,
        uint8_t* data_bytes, 
        int* data_size,
        const char** file,
        int64_t* start,
        int64_t* len,
        double* mod,
        const char** uuid) {

  blink::WebHTTPBody::Element element;
  bool result = reinterpret_cast<blink::WebHTTPBody *>(handle)->ElementAt(static_cast<size_t>(index), element);

  if (!result) {
    return 0;
  }

  const char* data_buf = nullptr;
  size_t data_pos = 0;
  // keep a memento of the original start
  uint8_t* data_bytes_start = data_bytes;

  while (size_t length = element.data.GetSomeData(data_buf, data_pos)) {
    data_bytes = reinterpret_cast<uint8_t*>(memcpy(data_bytes, data_buf, length));
    data_pos += length;
  }

  data_bytes = data_bytes_start;

  *kind = element.type;
  
  *data_size = data_pos;
  *file = element.file_path.Utf8().c_str();
  *start = element.file_start;
  *len = element.file_length;
  *mod = element.modification_time;
  *uuid = element.blob_uuid.Utf8().c_str();
  
  return 1;
}

void _WebHTTPBodyAppendData(WebHTTPBodyRef handle, const uint8_t* data_bytes, int data_size) {
  blink::WebData webdata(reinterpret_cast<const char*>(data_bytes), data_size);
  reinterpret_cast<blink::WebHTTPBody *>(handle)->AppendData(webdata);
}

void _WebHTTPBodyAppendFile(WebHTTPBodyRef handle, const char* file) {
  reinterpret_cast<blink::WebHTTPBody *>(handle)->AppendFile(String::FromUTF8(file)); 
}

void _WebHTTPBodyAppendFileRange(WebHTTPBodyRef handle, const char* file, int64_t start, int64_t length, double modificationTime) {
  reinterpret_cast<blink::WebHTTPBody *>(handle)->AppendFileRange(String::FromUTF8(file), start, length, modificationTime);
}

void _WebHTTPBodyAppendBlob(WebHTTPBodyRef handle, const char* blob) {
  reinterpret_cast<blink::WebHTTPBody *>(handle)->AppendBlob(String::FromUTF8(blob));
}

// void _WebHTTPBodyAppendFileSystemURLRange(WebHTTPBodyRef handle, const char* url, int64_t start, int64_t lenght, double modificationTime) {
//   reinterpret_cast<blink::WebHTTPBody *>(handle)->AppendFileSystemURLRange(blink::KURL(String::FromUTF8(url)), start, lenght, modificationTime);
// }

// WebURLResponse
void _WebURLResponseDestroy(WebURLResponseRef handle) {
  //delete reinterpret_cast<blink::WebURLResponse *>(handle);
}

void _WebURLResponseGetURL(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebURL url = reinterpret_cast<blink::WebURLResponse *>(handle)->Url();
  if (url.IsEmpty() || url.IsNull()) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, url.GetString().Utf8().c_str(), url.GetString().length());
}

void _WebURLResponseSetURL(WebURLResponseRef handle, const char* url) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetURL(blink::KURL(blink::WebString::FromUTF8(url)));
}

// int _WebURLResponseGetConnectionId(WebURLResponseRef handle) {
//   return static_cast<int>(reinterpret_cast<blink::WebURLResponse *>(handle)->connectionID());
// }

void _WebURLResponseSetConnectionId(WebURLResponseRef handle, int id) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetConnectionID(id);
}

// int _WebURLResponseConnectionReused(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->ConnectionReused() ? 1 : 0;
// }

void _WebURLResponseSetConnectionReused(WebURLResponseRef handle, int reused) {
   reinterpret_cast<blink::WebURLResponse *>(handle)->SetConnectionReused(reused == 0 ? false : true);
}

// WebHTTPLoadInfoRef _WebURLResponseGetHttpLoadInfo(WebURLResponseRef handle) {
//   blink::ResourceLoadInfo* info = reinterpret_cast<blink::WebURLResponse *>(handle)->HttpLoadInfo();
//   return new WebHTTPLoadInfoWrapper(info);
// }

void _WebURLResponseSetHttpLoadInfo(WebURLResponseRef handle, WebHTTPLoadInfoRef info) {
  WebHTTPLoadInfoWrapper* webinfo = reinterpret_cast<WebHTTPLoadInfoWrapper *>(info);
  // NOTE: the passed info will point to null, giving we haved passed the inner handle
  // so it will probably break, if we call any methods on it after this on the swift side
  scoped_refptr<blink::ResourceLoadInfo> load_info(*webinfo);
  //blink::WebHTTPLoadInfo load_info(*webinfo);
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetHTTPLoadInfo(load_info);
}

void _WebURLResponseGetMimeType(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString mime_type = reinterpret_cast<blink::WebURLResponse *>(handle)->MimeType();
  if (mime_type.length() == 0) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, mime_type.Utf8().c_str(), mime_type.length());
}

void _WebURLResponseSetMimeType(WebURLResponseRef handle, const char* mime) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetMIMEType(blink::WebString::FromUTF8(mime));
}

int64_t _WebURLResponseGetExpectedContentLength(WebURLResponseRef handle) {
  return reinterpret_cast<blink::WebURLResponse *>(handle)->ExpectedContentLength(); 
}

void _WebURLResponseSetExpectedContentLength(WebURLResponseRef handle, int64_t len) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetExpectedContentLength(len); 
}

// const char* _WebURLResponseGetTextEncoding(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->TextEncodingName().Utf8().c_str();
// }

void _WebURLResponseSetTextEncodingName(WebURLResponseRef handle, const char* encoding) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetTextEncodingName(blink::WebString::FromUTF8(encoding));
}

// const char* _WebURLResponseGetSuggestedFileName(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->SuggestedFileName().Utf8().c_str();
// }

// void _WebURLResponseSetSuggestedFileName(WebURLResponseRef handle, const char* filename) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetSuggestedFileName(blink::WebString::FromUTF8(filename));
// }

int _WebURLResponseGetHttpVersion(WebURLResponseRef handle) {
  return static_cast<int>(reinterpret_cast<blink::WebURLResponse *>(handle)->HttpVersion()); 
}

void _WebURLResponseSetHttpVersion(WebURLResponseRef handle, int version) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetHTTPVersion(static_cast<blink::WebURLResponse::HTTPVersion>(version)); 
}

int _WebURLResponseGetHttpStatusCode(WebURLResponseRef handle) {
  return reinterpret_cast<blink::WebURLResponse *>(handle)->HttpStatusCode();
}

void _WebURLResponseSetHttpStatusCode(WebURLResponseRef handle, int status_code) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetHTTPStatusCode(status_code);
}

void _WebURLResponseGetHttpStatusText(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString status_text = reinterpret_cast<blink::WebURLResponse *>(handle)->HttpStatusText();
  if (status_text.length() == 0) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, status_text.Utf8().c_str(), status_text.length()); 
}

void _WebURLResponseSetHttpStatusText(WebURLResponseRef handle, const char* status) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetHTTPStatusText(blink::WebString::FromUTF8(status));
}

// double _WebURLResponseGetLastModifiedDate(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->LastModifiedDate();
// }

// void _WebURLResponseSetLastModifiedDate(WebURLResponseRef handle, double date) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetLastModifiedDate(date);
// }

int64_t _WebURLResponseGetAppCacheId(WebURLResponseRef handle) {
  return reinterpret_cast<blink::WebURLResponse *>(handle)->AppCacheID();
}

void _WebURLResponseSetAppCacheId(WebURLResponseRef handle, int64_t id) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetAppCacheID(id);
}

void _WebURLResponseGetAppCacheManifestURL(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString appcache_manifest_url = reinterpret_cast<blink::WebURLResponse *>(handle)->AppCacheManifestURL().GetString();
  if (appcache_manifest_url.IsEmpty()) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, appcache_manifest_url.Utf8().c_str(), appcache_manifest_url.length());
}

void _WebURLResponseSetAppCacheManifestURL(WebURLResponseRef handle, const char* url) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetAppCacheManifestURL(blink::KURL(blink::WebString::FromUTF8(url))); 
}

// const char* _WebURLResponseGetSecurityInfo(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->SecurityInfo().data();
// }

// void _WebURLResponseSetSecurityInfo(WebURLResponseRef handle, const char* info) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetSecurityInfo(blink::WebCString(info));
// }

// int _WebURLResponseGetSecurityStyle(WebURLResponseRef handle) {
//   return static_cast<int>(reinterpret_cast<blink::WebURLResponse *>(handle)->WecurityStyle());
// }

void _WebURLResponseSetSecurityStyle(WebURLResponseRef handle, int style) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetSecurityStyle(static_cast<blink::WebSecurityStyle>(style)); 
}

// int _WebURLResponseWasCached(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasCached() ? 1 : 0;
// }

void _WebURLResponseSetWasCached(WebURLResponseRef handle, int cached) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasCached(cached == 0 ? false : true);
}

// int _WebURLResponseWasFetchedViaSPDY(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasFetchedViaSPDY() ? 1 : 0;
// }

void _WebURLResponseSetWasFetchedViaSPDY(WebURLResponseRef handle, int fetched) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasFetchedViaSPDY(fetched == 0 ? false : true);
}

// int _WebURLResponseWasNpnNegotiated(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasNpnNegotiated() ? 1 : 0; 
// }

// void _WebURLResponseSetWasNpnNegotiated(WebURLResponseRef handle, int negotiated) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasNpnNegotiated(negotiated == 0 ? false : true);
// }

// int _WebURLResponseWasAlternateProtocolAvailable(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasAlternateProtocolAvailable() ? 1 : 0;
// }

// void _WebURLResponseSetWasAlternateProtocolAvailable(WebURLResponseRef handle, int available) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasAlternateProtocolAvailable(available == 0 ? false : true);
// }

// int _WebURLResponseWasFetchedViaProxy(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasFetchedViaProxy() ? 1 : 0; 
// }

// void _WebURLResponseSetWasFetchedViaProxy(WebURLResponseRef handle, int fetched) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasFetchedViaProxy(fetched == 0 ? false : true);
// }

int _WebURLResponseWasFetchedViaServiceWorker(WebURLResponseRef handle) {
  return reinterpret_cast<blink::WebURLResponse *>(handle)->WasFetchedViaServiceWorker() ? 1 : 0;
}

void _WebURLResponseSetWasFetchedViaServiceWorker(WebURLResponseRef handle, int fetched) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasFetchedViaServiceWorker(fetched == 0 ? false : true);
}

// int _WebURLResponseWasFallbackRequiredByServiceWorker(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->WasFallbackRequiredByServiceWorker() ? 1 : 0;
// }

void _WebURLResponseSetWasFallbackRequiredByServiceWorker(WebURLResponseRef handle, int required) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetWasFallbackRequiredByServiceWorker(required == 0 ? false : true);
}

// int _WebURLResponseGetServiceWorkerResponseType(WebURLResponseRef handle) {
//   return static_cast<int>(reinterpret_cast<blink::WebURLResponse *>(handle)->ServiceWorkerResponseType()); 
// }

// void _WebURLResponseSetServiceWorkerResponseType(WebURLResponseRef handle, int type) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetServiceWorkerResponseType(static_cast<blink::WebServiceWorkerResponseType>(type)); 
// }

// const char* _WebURLResponseGetOriginalURLViaServiceWorker(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->OriginalURLViaServiceWorker().string().utf8().c_str(); 
// }

// void _WebURLResponseSetOriginalURLViaServiceWorker(WebURLResponseRef handle, const char* url) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetOriginalURLViaServiceWorker(blink::KURL(blink::WebString::FromUTF8(url)));
// }

// int _WebURLResponseIsMultipartPayload(WebURLResponseRef handle) {
//   return reinterpret_cast<blink::WebURLResponse *>(handle)->IsMultipartPayload() ? 1 : 0;
// }

// void _WebURLResponseSetIsMultipartPayload(WebURLResponseRef handle, int payload) {
//   reinterpret_cast<blink::WebURLResponse *>(handle)->SetIsMultipartPayload(payload == 0 ? false : true);
// }

void _WebURLResponseGetDownloadFilePath(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString download_file_path = reinterpret_cast<blink::WebURLResponse *>(handle)->DownloadFilePath();
  if (download_file_path.length() == 0) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, download_file_path.Utf8().c_str(), download_file_path.length());
}

void _WebURLResponseSetDownloadFilePath(WebURLResponseRef handle, const char* path) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetDownloadFilePath(blink::WebString::FromUTF8(path));
}

void _WebURLResponseGetRemoteIPAddress(WebURLResponseRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString remote_ip_address = reinterpret_cast<blink::WebURLResponse *>(handle)->RemoteIPAddress();
  if (remote_ip_address.IsNull()) {
    cb(state, nullptr, 0);  
    return;
  }
  cb(state, remote_ip_address.Utf8().c_str(), remote_ip_address.length());
}

void _WebURLResponseSetRemoteIPAddress(WebURLResponseRef handle, const char* address) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetRemoteIPAddress(blink::WebString::FromUTF8(address));
}

int16_t _WebURLResponseGetRemotePort(WebURLResponseRef handle) {
  return reinterpret_cast<blink::WebURLResponse *>(handle)->RemotePort(); 
}

void _WebURLResponseSetRemotePort(WebURLResponseRef handle, int16_t port) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetRemotePort(port);
}

void _WebURLResponseSetResponseTime(WebURLResponseRef handle, int64_t time) {
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetResponseTime(base::Time::FromInternalValue(time)); 
}

void _WebURLResponseGetHttpHeaderField(WebURLResponseRef handle, const char* field, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString strfield = blink::WebString::FromUTF8(field);
  blink::WebString http_header_field = reinterpret_cast<blink::WebURLResponse *>(handle)->HttpHeaderField(strfield);
  if (http_header_field.IsNull()) {
    cb(state, nullptr, 0); 
    return;
  }
  cb(state, http_header_field.Utf8().c_str(), http_header_field.length()); 
}

void _WebURLResponseSetHTTPHeaderField(WebURLResponseRef handle, const char* name, const char* value) {
  blink::WebString strname = blink::WebString::FromUTF8(name);
  blink::WebString strvalue = blink::WebString::FromUTF8(value);
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetHTTPHeaderField(strname, strvalue);
}

void _WebURLResponseAddHTTPHeaderField(WebURLResponseRef handle, const char* name, const char* value) {
  blink::WebString strname = blink::WebString::FromUTF8(name);
  blink::WebString strvalue = blink::WebString::FromUTF8(value);
  reinterpret_cast<blink::WebURLResponse *>(handle)->AddHTTPHeaderField(strname, strvalue);
}

void _WebURLResponseClearHTTPHeaderField(WebURLResponseRef handle, const char* name) {
  blink::WebString strname = blink::WebString::FromUTF8(name);
  reinterpret_cast<blink::WebURLResponse *>(handle)->ClearHTTPHeaderField(strname);
}

void _WebURLResponseSetSecurityDetails(
  WebURLResponseRef handle, 
  const char* protocol, 
  const char* key, 
  const char* key_group, 
  const char* cypher, 
  const char* mac,
  const char* subject_name,
  const char* issuer,
  double valid_from,
  double valid_to) {

  blink::WebVector<blink::WebString> san_list;
  blink::WebVector<blink::WebString> certificate;
  blink::WebURLResponse::SignedCertificateTimestampList sct_list;
  
  blink::WebURLResponse::WebSecurityDetails details(
    blink::WebString::FromUTF8(protocol),
    blink::WebString::FromUTF8(key),
    blink::WebString::FromUTF8(key_group),
    blink::WebString::FromUTF8(cypher),
    blink::WebString::FromUTF8(mac),
    blink::WebString::FromUTF8(subject_name),
    san_list,
    blink::WebString::FromUTF8(issuer),
    valid_from,
    valid_to,
    certificate,
    sct_list);
  
  reinterpret_cast<blink::WebURLResponse *>(handle)->SetSecurityDetails(details);
}

// WebURLRequest
WebURLRequestRef _WebURLRequestCreate(const char* url) {
  return new WebURLRequestWrapper(blink::WebURLRequest(blink::KURL(blink::WebString::FromUTF8(url))));
}

void _WebURLRequestDestroy(WebURLRequestRef handle) {
  delete reinterpret_cast<WebURLRequestWrapper *>(handle);
}

void _WebURLRequestGetURL(WebURLRequestRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebURL url = reinterpret_cast<WebURLRequestWrapper *>(handle)->get().Url();
  if (url.IsEmpty() || url.IsNull()) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, url.GetString().Utf8().c_str(), url.GetString().length());
}

void _WebURLRequestSetURL(WebURLRequestRef handle, const char* url) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetURL(blink::KURL(blink::WebString::FromUTF8(url)));  
}

// const char* _WebURLRequestGetFirstPartyForCookies(WebURLRequestRef handle) {
//   return reinterpret_cast<const char*>(reinterpret_cast<WebURLRequestWrapper *>(handle)->FirstPartyForCookies().GetString().Utf8().c_str());
// }

// void _WebURLRequestSetFirstPartyForCookies(WebURLRequestRef handle, const char* url) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->SetFirstPartyForCookies(blink::KURL(blink::WebString::FromUTF8(url))); 
// }

WebSecurityOriginRef _WebURLRequestGetRequestorOrigin(WebURLRequestRef handle) {
  blink::WebSecurityOrigin origin = reinterpret_cast<WebURLRequestWrapper *>(handle)->get().RequestorOrigin();
  return new WebSecurityOriginWrapper(const_cast<blink::SecurityOrigin *>(origin.Get()));
}

void _WebURLRequestSetRequestorOrigin(WebURLRequestRef handle, WebSecurityOriginRef origin) {
  WebSecurityOriginWrapper* originWrapper = reinterpret_cast<WebSecurityOriginWrapper *>(origin);
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetRequestorOrigin(originWrapper->asWebSecurityOrigin());
}

int _WebURLRequestGetAllowStoredCredentials(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().AllowStoredCredentials() ? 1 : 0;
}

void _WebURLRequestSetAllowStoredCredentials(WebURLRequestRef handle, int allow) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetAllowStoredCredentials(allow == 0 ? false : true);
}

// int _WebURLRequestCachePolicy(WebURLRequestRef handle) {
//   return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->CachePolicy()); 
// }

// void _WebURLRequestSetCachePolicy(WebURLRequestRef handle, int policy) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->SetCachePolicy(static_cast<WebURLRequestWrapper::CachePolicy>(policy));
// }

void _WebURLRequestGetHttpMethod(WebURLRequestRef handle, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString http_method = reinterpret_cast<WebURLRequestWrapper *>(handle)->get().HttpMethod();
  if (http_method.length() == 0) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, http_method.Utf8().c_str(), http_method.length());
}

void _WebURLRequestSetHTTPMethod(WebURLRequestRef handle, const char* method) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetHTTPMethod(blink::WebString::FromUTF8(method));
}

WebHTTPBodyRef _WebURLRequestGetHttpBody(WebURLRequestRef handle) {
 blink::WebHTTPBody body = reinterpret_cast<WebURLRequestWrapper *>(handle)->get().HttpBody();
 return new blink::WebHTTPBody(scoped_refptr<blink::EncodedFormData>(body));
}

void _WebURLRequestSetHttpBody(WebURLRequestRef handle, WebHTTPBodyRef body) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetHTTPBody(*reinterpret_cast<blink::WebHTTPBody *>(body));
}

int _WebURLRequestGetReportUploadProgress(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().ReportUploadProgress() ? 1 : 0;
}

void _WebURLRequestSetReportUploadProgress(WebURLRequestRef handle, int report) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetReportUploadProgress(report == 0 ? true : false);
}

int _WebURLRequestGetReportRawHeaders(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().ReportRawHeaders() ? 1 : 0;
}

void _WebURLRequestSetReportRawHeaders(WebURLRequestRef handle, int report) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetReportRawHeaders(report == 0 ? false : true);
}

int _WebURLRequestGetRequestContext(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetRequestContext());
}

void _WebURLRequestSetRequestContext(WebURLRequestRef handle, int context) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetRequestContext(static_cast<blink::WebURLRequest::RequestContext>(context)); 
}

int _WebURLRequestGetFrameType(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetFrameType());
}

void _WebURLRequestSetFrameType(WebURLRequestRef handle, int type) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetFrameType(static_cast<network::mojom::RequestContextFrameType>(type));
}

int _WebURLRequestGetWebReferrerPolicy(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetReferrerPolicy());
}

int _WebURLRequestGetHasUserGesture(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().HasUserGesture() ? 1 : 0; 
}

void _WebURLRequestSetHasUserGesture(WebURLRequestRef handle, int hasGesture) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetHasUserGesture(hasGesture == 0 ? false : true);
}

int _WebURLRequestGetRequestorId(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().RequestorID();
}

void _WebURLRequestSetRequestorId(WebURLRequestRef handle, int id) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetRequestorID(id);
}

// int _WebURLRequestGetRequestorProcessId(WebURLRequestRef handle) {
//   return reinterpret_cast<WebURLRequestWrapper *>(handle)->RequestorProcessID(); 
// }

// void _WebURLRequestSetRequestorProcessId(WebURLRequestRef handle, int id) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->SetRequestorProcessID(id);
// }

int _WebURLRequestGetAppCacheHostId(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().AppCacheHostID();
}

void _WebURLRequestSetAppCacheHostId(WebURLRequestRef handle, int id) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetAppCacheHostID(id);
}

int _WebURLRequestGetDownloadToFile(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().DownloadToFile() ? 1 : 0;
}

void _WebURLRequestSetDownloadToFile(WebURLRequestRef handle, int downloadToFile) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetDownloadToFile(downloadToFile == 0 ? false : true);
}

int _WebURLRequestGetUseStreamOnResponse(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().UseStreamOnResponse() ? 1 : 0;
}

void _WebURLRequestSetUseStreamOnResponse(WebURLRequestRef handle, int useStream) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetUseStreamOnResponse(useStream == 0 ? false : true);
}

int _WebURLRequestGetSkipServiceWorker(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetSkipServiceWorker() ? 1 : 0;
}

void _WebURLRequestSetSkipServiceWorker(WebURLRequestRef handle, int skip) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetSkipServiceWorker(skip == 0 ? false : true);
}

int _WebURLRequestGetShouldResetAppCache(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().ShouldResetAppCache() ? 1 : 0;
}

void _WebURLRequestSetShouldResetAppCache(WebURLRequestRef handle, int shouldReset) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetShouldResetAppCache(shouldReset == 0 ? false : true);
}

int _WebURLRequestGetFetchRequestMode(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetFetchRequestMode());
}

void _WebURLRequestSetFetchRequestMode(WebURLRequestRef handle, int mode) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetFetchRequestMode(static_cast<network::mojom::FetchRequestMode>(mode));
}

int _WebURLRequestGetFetchCredentialsMode(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetFetchCredentialsMode());
}

void _WebURLRequestSetFetchCredentialsMode(WebURLRequestRef handle, int mode) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetFetchCredentialsMode(static_cast<network::mojom::FetchCredentialsMode>(mode));
}

int _WebURLRequestGetFetchRedirectMode(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetFetchRedirectMode());
}

void _WebURLRequestSetFetchRedirectMode(WebURLRequestRef handle, int mode) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetFetchRedirectMode(static_cast<network::mojom::FetchRedirectMode>(mode));
}

// int _WebURLRequestGetLoFiState(WebURLRequestRef handle) {
//   return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().LoFiState());
// }

// void _WebURLRequestSetLoFiState(WebURLRequestRef handle, int state) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetLoFiState(static_cast<blink::WebURLRequest::LoFiState>(state));
// }

int _WebURLRequestGetPriority(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().GetPriority());
}

void _WebURLRequestSetPriority(WebURLRequestRef handle, int priority) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetPriority(static_cast<blink::WebURLRequest::Priority>(priority));
}

int _WebURLRequestGetCheckForBrowserSideNavigation(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().CheckForBrowserSideNavigation() ? 1 : 0;  
}

void _WebURLRequestSetCheckForBrowserSideNavigation(WebURLRequestRef handle, int check) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetCheckForBrowserSideNavigation(check == 0 ? false : true);
}

double _WebURLRequestGetUiStartTime(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().UiStartTime(); 
}

void _WebURLRequestSetUiStartTime(WebURLRequestRef handle, double startTime) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetUiStartTime(startTime);
}

int _WebURLRequestGetInputPerfMetricReportPolicy(WebURLRequestRef handle) {
  return static_cast<int>(reinterpret_cast<WebURLRequestWrapper *>(handle)->get().InputPerfMetricReportPolicy());
}

void _WebURLRequestSetInputPerfMetricReportPolicy(WebURLRequestRef handle, int policy) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetInputPerfMetricReportPolicy(static_cast<blink::WebURLRequest::InputToLoadPerfMetricReportPolicy>(policy));  
}

// int _WebURLRequestGetOriginatesFromReservedIPRange(WebURLRequestRef handle) {
//   return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().OriginatesFromReservedIPRange() ? 1 : 0;
// }

// void _WebURLRequestSetOriginatesFromReservedIPRange(WebURLRequestRef handle, int originates) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetOriginatesFromReservedIPRange(originates == 0 ? false : true);
// }

// void _WebURLRequestAddHTTPOriginIfNeeded(WebURLRequestRef handle, const char* origin) {
//   reinterpret_cast<WebURLRequestWrapper *>(handle)->get().AddHTTPOriginIfNeeded(blink::WebString::FromUTF8(origin));
// }

void _WebURLRequestGetHttpHeaderField(WebURLRequestRef handle, const char* field, void* state, void(*cb)(void*, const char *, size_t)) {
  blink::WebString http_header_field = reinterpret_cast<WebURLRequestWrapper *>(handle)->get().HttpHeaderField(blink::WebString::FromUTF8(field));
  if (http_header_field.length()) {
    cb(state, nullptr, 0);
    return;
  }
  cb(state, http_header_field.Utf8().c_str(), http_header_field.length());
}

void _WebURLRequestSetHTTPHeaderField(WebURLRequestRef handle, const char* name, const char* value) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetHTTPHeaderField(blink::WebString::FromUTF8(name), blink::WebString::FromUTF8(value)); 
}

void _WebURLRequestSetHTTPReferrer(WebURLRequestRef handle, const char* referrer, int policy) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetHTTPReferrer(blink::WebString::FromUTF8(referrer), static_cast<blink::WebReferrerPolicy>(policy));
}

void _WebURLRequestAddHTTPHeaderField(WebURLRequestRef handle, const char* name, const char* value) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().AddHTTPHeaderField(blink::WebString::FromUTF8(name), blink::WebString::FromUTF8(value));
}

void _WebURLRequestClearHTTPHeaderField(WebURLRequestRef handle, const char* name) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().ClearHTTPHeaderField(blink::WebString::FromUTF8(name));
}

void _WebURLRequestSetIsSameDocumentNavigation(WebURLRequestRef handle, int same_document) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetIsSameDocumentNavigation(same_document != 0);
}

int _WebURLRequestGetWasDiscarded(WebURLRequestRef handle) {
  return reinterpret_cast<WebURLRequestWrapper *>(handle)->get().WasDiscarded() ? 1 : 0;
}

void _WebURLRequestSetWasDiscarded(WebURLRequestRef handle, int was_discarded) {
  reinterpret_cast<WebURLRequestWrapper *>(handle)->get().SetWasDiscarded(was_discarded != 0);
}

void _WebURLRequestSetNavigationStartTime(WebURLRequestRef reference, int64_t microseconds) {
  return reinterpret_cast<WebURLRequestWrapper *>(reference)->get().SetNavigationStartTime(double(microseconds)); 
}

int _WebURLRequestGetKeepAlive(WebURLRequestRef reference) {
  return reinterpret_cast<WebURLRequestWrapper *>(reference)->get().GetKeepalive(); 
}

void _WebURLRequestSetKeepAlive(WebURLRequestRef reference, int keepalive) {
  reinterpret_cast<WebURLRequestWrapper *>(reference)->get().SetKeepalive(keepalive != 0);
}

// WebHitTestResult

void _WebHitTestResultDestroy(WebHitTestResultRef handle) {
  delete reinterpret_cast<WebHitTestResultWrapper *>(handle);
}

void _WebSecurityOriginDestroy(WebSecurityOriginRef handle) {
  delete reinterpret_cast<WebSecurityOriginWrapper *>(handle); 
}

void _WebPluginContainerDestroy(WebPluginContainerRef handle) {
  //delete reinterpret_cast<blink::WebPluginContainer *>(handle);
}

// void _WebRangeDestroy(WebRangeRef handle) {
//   delete reinterpret_cast<WebRangeWrapper *>(handle); 
// }

WebWidgetRef _WebFrameWidgetCreate(
  void* peer, 
  WebViewClientCbs callbacks, 
  WebFrameRef frame) {
  blink::WebLocalFrame* local_frame = reinterpret_cast<blink::WebLocalFrame *>(frame);
  // TODO: this should be LEAKING. FIX
  WebViewClientImpl* client = new WebViewClientImpl(peer, callbacks);
  return blink::WebFrameWidget::Create(client->WidgetClient(), local_frame);
}

WebFrameRef _WebFrameWidgetGetLocalRoot(WebWidgetRef handle) {
  return reinterpret_cast<blink::WebFrameWidget *>(handle)->LocalRoot();
}

WebInputMethodControllerRef _WebFrameWidgetGetActiveWebInputMethodController(WebWidgetRef handle) {
  blink::LocalFrame* focused = reinterpret_cast<blink::WebFrameWidgetBase *>(handle)->FocusedLocalFrameInWidget();
  if (!focused) {
    return nullptr;
  }
  return &focused->GetInputMethodController();
}

void _WebFrameWidgetSetVisibilityState(WebWidgetRef handle, WebPageVisibilityStateEnum visibility_state) {
  blink::mojom::PageVisibilityState visibility = static_cast<blink::mojom::PageVisibilityState>(visibility_state);
  //DLOG(INFO) << "_WebFrameWidget: setting visibility to " << visibility;
  reinterpret_cast<blink::WebFrameWidget *>(handle)->SetVisibilityState(visibility);
}

WebFrameRef _WebFrameWidgetGetFocusedWebLocalFrameInWidget(WebWidgetRef handle) {
  return reinterpret_cast<blink::WebFrameWidget *>(handle)->FocusedWebLocalFrameInWidget();
}

int _WebFrameWidgetScrollFocusedEditableElementIntoView(WebWidgetRef handle) {
  return reinterpret_cast<blink::WebFrameWidget *>(handle)->ScrollFocusedEditableElementIntoView() ? 1 : 0;
}

// int _WebFrameWidgetHandleInputEvent(WebWidgetRef handle, WebInputEventRef event) {
//   //DLOG(INFO) << "_WebFrameWidgetHandleInputEvent";
//   blink::WebFrameWidget* widget = reinterpret_cast<blink::WebFrameWidget *>(handle);
//   blink::WebInputEvent* input = reinterpret_cast<blink::WebInputEvent *>(event);
//   blink::WebCoalescedInputEvent coalesced_event(*input);
//   return static_cast<int>(widget->HandleInputEvent(coalesced_event));
// }

WebServiceWorkerNetworkProviderRef _WebServiceWorkerNetworkProviderCreate(int provider_id, int route_id, void* state, WebServiceWorkerNetworkProviderCbs callbacks) {
  DCHECK(state);
  return new WebServiceWorkerNetworkProviderImpl(provider_id, route_id, state, callbacks);
}

void _WebServiceWorkerNetworkProviderSetServiceWorkerProviderId(WebServiceWorkerNetworkProviderRef handle, int provider_id) {
  WebServiceWorkerNetworkProviderImpl* provider = reinterpret_cast<WebServiceWorkerNetworkProviderImpl *>(handle);
  provider->set_provider_id(provider_id);
}

void _WebServiceWorkerNetworkProviderDestroy(WebServiceWorkerNetworkProviderRef handle) {
  WebServiceWorkerNetworkProviderImpl* provider = reinterpret_cast<WebServiceWorkerNetworkProviderImpl *>(handle);
  if (provider->is_owned()) {
    delete provider;
  }
}

CSSStyleSheetRef _CSSStyleSheetCreate(WebNodeRef document, const char* title, const char* contents) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exception_state(isolate, blink::ExceptionState::kSetterContext,
                                 "CSSStyleSheet", "create");
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  blink::CSSStyleSheetInit init;
  init.setTitle(String::FromUTF8(title));
  return blink::CSSStyleSheet::Create(*doc_ref->unwrap<blink::Document>(), String::FromUTF8(contents), init, exception_state);
}

CSSStyleSheetRef _CSSStyleSheetCreateFromNode(WebNodeRef node, const char* title, const char* contents) {
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  blink::Node* owner_node = node_ref->unwrap<blink::Node>();
  blink::CSSParserContext* parser_context = blink::CSSParserContext::Create(
      owner_node->GetDocument(), owner_node->GetDocument().BaseURL(),
      owner_node->GetDocument().GetReferrerPolicy(), 
      WTF::UTF8Encoding());
  blink::StyleSheetContents* sheet =
      blink::StyleSheetContents::Create(owner_node->GetDocument().BaseURL().GetString(), parser_context);
  sheet->ParseString(String::FromUTF8(contents));
  return blink::CSSStyleSheet::Create(
    sheet,
    *owner_node); 
}

void _CSSStyleSheetDestroy(CSSStyleSheetRef handle) {
  // i guess this is not owned.. so do nothing
}

const char* _CSSStyleSheetGetBaseURL(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->BaseURL().GetString().Utf8().data(); 
}

int _CSSStyleSheetIsLoading(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->IsLoading(); 
}

const char* _CSSStyleSheetGetHref(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->href().Utf8().data(); 
}

const char* _CSSStyleSheetGetTitle(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->title().Utf8().data(); 
}

void _CSSStyleSheetSetTitle(CSSStyleSheetRef handle, const char* title) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->SetTitle(String::FromUTF8(title));
}

int _CSSStyleSheetIsDisabled(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->disabled();
}

void _CSSStyleSheetSetIsDisabled(CSSStyleSheetRef handle, int disabled) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->setDisabled(disabled != 0); 
}

WebNodeRef _CSSStyleSheetOwnerNode(CSSStyleSheetRef handle) {
  blink::Node* node = reinterpret_cast<blink::CSSStyleSheet*>(handle)->ownerNode();
  if (node) {
    return new WebNodeWrapper(node);
  }
  return nullptr;
}

CSSStyleSheetRef _CSSStyleSheetGetParentStyleSheet(CSSStyleSheetRef handle) {
  blink::CSSStyleSheet* parent = reinterpret_cast<blink::CSSStyleSheet*>(handle)->parentStyleSheet();
  return parent;
}

CSSRuleListRef _CSSStyleSheetGetCSSRuleList(CSSStyleSheetRef handle) {
  blink::NonThrowableExceptionState exceptionState;
  blink::CSSRuleList* list = reinterpret_cast<blink::CSSStyleSheet*>(handle)->cssRules(exceptionState);
  return list;
}

WebNodeRef _CSSStyleSheetGetOwnerDocument(CSSStyleSheetRef handle) {
  blink::Document* document = reinterpret_cast<blink::CSSStyleSheet*>(handle)->OwnerDocument();
  if (document) {
    return new WebNodeWrapper(document);
  }
  return nullptr;
}

int _CSSStyleSheetGetLenght(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->length();
}

StyleSheetContentsRef _CSSStyleSheetGetContents(CSSStyleSheetRef handle) {
  blink::StyleSheetContents* contents = reinterpret_cast<blink::CSSStyleSheet*>(handle)->Contents();
  return contents;
}

int _CSSStyleSheetIsInline(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->IsInline(); 
}

int _CSSStyleSheetIsSheetLoaded(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->SheetLoaded() ? 1 : 0;
}

int _CSSStyleSheetIsLoadCompleted(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->LoadCompleted() ? 1 : 0;
}

int _CSSStyleSheetIsAlternate(CSSStyleSheetRef handle) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->IsAlternate() ? 1 : 0;
}

void _CSSStyleSheetClearOwnerNode(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->ClearOwnerNode();
}

void _CSSStyleSheetClearOwnerRule(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->ClearOwnerRule(); 
}

int _CSSStyleSheetInsertRule(CSSStyleSheetRef handle, const char* rule, int index) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->insertRule(String::FromUTF8(rule), index, exceptionState);
}

int _CSSStyleSheetAddRuleIndex(CSSStyleSheetRef handle, const char* selection, const char* style, int index) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->addRule(String::FromUTF8(selection), String::FromUTF8(style), index, exceptionState); 
}

int _CSSStyleSheetAddRule(CSSStyleSheetRef handle, const char* selection, const char* style) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->addRule(String::FromUTF8(selection), String::FromUTF8(style), exceptionState); 
}

void _CSSStyleSheetDeleteRule(CSSStyleSheetRef handle, int index) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->deleteRule(index, exceptionState);  
}

CSSRuleRef _CSSStyleSheetGetItem(CSSStyleSheetRef handle, int index) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->item(index); 
}

void _CSSStyleSheetWillMutateRules(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->WillMutateRules();
}

void _CSSStyleSheetDidMutateRules(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->DidMutateRules();
}

void _CSSStyleSheetDidMutate(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->DidMutate();
}

void _CSSStyleSheetStartLoadingDynamicSheet(CSSStyleSheetRef handle) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->StartLoadingDynamicSheet(); 
}

void _CSSStyleSheetSetText(CSSStyleSheetRef handle, const char* text) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->SetText(String::FromUTF8(text));
}

void _CSSStyleSheetSetAlternateFromConstructor(CSSStyleSheetRef handle, int alternate) {
  reinterpret_cast<blink::CSSStyleSheet*>(handle)->SetAlternateFromConstructor(alternate != 0);
}

int _CSSStyleSheetCanBeActivated(CSSStyleSheetRef handle, const char* current_preferrable_name) {
  return reinterpret_cast<blink::CSSStyleSheet*>(handle)->CanBeActivated(String::FromUTF8(current_preferrable_name));
}

void _CSSRuleDestroy(CSSRuleRef handle) {

}

void _CSSRuleListDestroy(CSSRuleListRef handle) {

}

CSSStyleSheetListRef _CSSStyleSheetListCreate(CSSStyleSheetRef styles, int style_count) {
  blink::CSSStyleSheet** css_styles = reinterpret_cast<blink::CSSStyleSheet**>(styles);
    
  blink::NonThrowableExceptionState exceptionState;
  blink::HeapVector<blink::Member<blink::CSSStyleSheet>> style_sheet_vector;
  for (int i = 0; i < style_count; i++) {
    style_sheet_vector.push_back(css_styles[i]);
  }
  blink::StyleSheetList* sheet_list =
      blink::StyleSheetList::Create(style_sheet_vector, exceptionState);
  return sheet_list;
}


WebPluginRef _WebPluginCreate() {
  blink::WebPluginParams params;
  return new ViewOnWeb(params);
}

WebPluginRef _WebPluginCreateLayer(LayerRef layer) {
  blink::WebPluginParams params;
  return new ViewOnWeb(params, reinterpret_cast<_Layer*>(layer)->layer());
}

void _WebPluginDestroy(WebPluginRef handle) {
  delete reinterpret_cast<ViewOnWeb*>(handle);
}

LayerRef _WebPluginGetLayer(WebPluginRef handle) {
  return new _Layer(reinterpret_cast<ViewOnWeb*>(handle)->layer()->CcLayer());
}

void CanvasRenderingContext2dDestroy(CanvasRenderingContext2dRef handle) {
 
}

DisplayItemListRef CanvasRenderingContext2dGetDisplayItemList(CanvasRenderingContext2dRef handle) {
  cc::PaintRecorder* paint_recorder = GetPaintRecorder(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  if (!paint_recorder) {
    //DLOG(INFO) << "CanvasRenderingContext2dGetDisplayItemList: PaintRecorder IS null!! failling miserably..";
    DCHECK(false);
    return nullptr;
  }
  return new _DisplayItemList(paint_recorder);
  //cc::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  // if (!canvas) {
  //   //DLOG(INFO) << "CanvasRenderingContext2dGetDisplayItemList: PaintCanvas IS null!! failling miserably..";
  //   DCHECK(false);
  //   return nullptr;
  // }
  // //DLOG(INFO) << "CanvasRenderingContext2dGetDisplayItemList: PaintCanvas = " << canvas;
  // return new _DisplayItemList(canvas);
}

int CanvasRenderingContext2dGetSaveCount(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->getSaveCount();
}

int CanvasRenderingContext2dGetLocalClipBounds(CanvasRenderingContext2dRef handle, float* x, float* y, float* width, float* height) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect bounds;
  bool result = canvas->getLocalClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int CanvasRenderingContext2dGetDeviceClipBounds(CanvasRenderingContext2dRef handle, int* x, int* y, int* width, int* height) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkIRect bounds;
  bool result = canvas->getDeviceClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int CanvasRenderingContext2dIsClipEmpty(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->isClipEmpty();
}

int CanvasRenderingContext2dIsClipRect(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->isClipRect();
}

MatrixRef CanvasRenderingContext2dTotalMatrix(CanvasRenderingContext2dRef handle) {
  return nullptr;
}

void CanvasRenderingContext2dFlush(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->flush();
}

int CanvasRenderingContext2dSave(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->save();
}

int CanvasRenderingContext2dSaveLayerRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  return canvas->saveLayer(&rect, flags);
}

int CanvasRenderingContext2dSaveLayer(CanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  return canvas->saveLayer(nullptr, flags);
}

int CanvasRenderingContext2dSaveLayerAlpha(CanvasRenderingContext2dRef handle, int alpha) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->saveLayerAlpha(nullptr, alpha, true);
}

int CanvasRenderingContext2dSaveLayerAlphaRect(CanvasRenderingContext2dRef handle, int alpha, float rx, float ry, float rw, float rh) {
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  return canvas->saveLayerAlpha(&rect,
                                alpha,
                                true);
}

int CanvasRenderingContext2dSaveLayerPreserveLCDTextRequestsRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

int CanvasRenderingContext2dSaveLayerPreserveLCDTextRequests(CanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

void CanvasRenderingContext2dRestore(CanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->restore();
}

void CanvasRenderingContext2dRestoreToCount(CanvasRenderingContext2dRef handle, int save_count) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->restoreToCount(save_count);
}

void CanvasRenderingContext2dTranslate(CanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->translate(x, y);
}

void CanvasRenderingContext2dScale(CanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->scale(x, y);
}

void CanvasRenderingContext2dRotate(CanvasRenderingContext2dRef handle, float radians) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->rotate(radians);
}

void CanvasRenderingContext2dConcatHandle(CanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->concat(*m);
}

void CanvasRenderingContext2dSetMatrixHandle(CanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->setMatrix(*m);
}

void CanvasRenderingContext2dClipRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->clipRect(rect, static_cast<SkClipOp>(clip), anti_alias);
}

void CanvasRenderingContext2dClipRRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->clipRRect(r, static_cast<SkClipOp>(clip), anti_alias);
}

void CanvasRenderingContext2dClipPath(CanvasRenderingContext2dRef handle, PathRef path, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->clipPath(reinterpret_cast<SkiaPath*>(path)->ref(), static_cast<SkClipOp>(clip), anti_alias);
}

void CanvasRenderingContext2dClearRect(CanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh) {
  reinterpret_cast<blink::CanvasRenderingContext2D *>(handle)->clearRect(rx, ry, rw, rh);
}

void CanvasRenderingContext2dDrawColor(CanvasRenderingContext2dRef handle, int a, int r, int g, int b, int mode) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->drawColor(SkColorSetARGB(a, r, g, b), static_cast<SkBlendMode>(mode));
}

void CanvasRenderingContext2dDrawLine(CanvasRenderingContext2dRef handle, float sx, float sy, float ex, float ey, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->drawLine(sx, sy, ex, ey, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
} 

void CanvasRenderingContext2dDrawIRect(CanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkIRect rect = SkIRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawIRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawOval(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawOval(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawRRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->drawRRect(r, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawDRRect(CanvasRenderingContext2dRef handle, float ox, float oy, float ow, float oh, float ix, float iy, float iw, float ih, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRRect outer = SkRRect::MakeRect(SkRect::MakeXYWH(ox, oy, ow, oh));
  SkRRect inner = SkRRect::MakeRect(SkRect::MakeXYWH(ix, iy, iw, ih));
  canvas->drawDRRect(outer, inner, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawRoundRect(CanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRoundRect(rect, x, y, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void CanvasRenderingContext2dDrawPath(CanvasRenderingContext2dRef handle, PathRef path, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->drawPath(reinterpret_cast<SkiaPath*>(path)->ref(), reinterpret_cast<PaintFlags *>(paint)->const_ref()); 
}

void CanvasRenderingContext2dDrawImage(CanvasRenderingContext2dRef handle, ImageRef image, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();
  canvas->drawImage(
    paint_image,
    x, y,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr); 
}

void CanvasRenderingContext2dDrawImageRect(
  CanvasRenderingContext2dRef handle, 
  ImageRef image, 
  float sx, float sy, float sw, float sh,
  float dx, float dy, float dw, float dh,
  int src_rect_constraint, 
  PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkRect src = SkRect::MakeXYWH(int(sx), int(sy), int(sw), int(sh));
  SkRect dst = SkRect::MakeXYWH(int(dx), int(dy), int(dw), int(dh));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();

  canvas->drawImageRect(
    paint_image, 
    src, 
    dst,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr, 
    static_cast<cc::PaintCanvas::SrcRectConstraint>(src_rect_constraint));
}

void CanvasRenderingContext2dDrawBitmap(CanvasRenderingContext2dRef handle, BitmapRef bitmap, float left, float top, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  SkBitmap* sk_bitmap = reinterpret_cast<SkBitmap*>(bitmap);
  //DLOG(INFO) << "CanvasRenderingContext2dDrawBitmap: bitmap => " << sk_bitmap;
  canvas->drawBitmap(
    *sk_bitmap,
    left, top,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr);
}

void CanvasRenderingContext2dDrawTextBlob(CanvasRenderingContext2dRef handle, PaintTextBlobRef text, float x, float y, PaintFlagsRef paint) {
  PaintTextBlob* text_blob = reinterpret_cast<PaintTextBlob *>(text);
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  const cc::PaintFlags& local_flags = reinterpret_cast<PaintFlags *>(paint)->const_ref();
  
  // NOTE: the reference to flags is not working: FIX
  // by the way, at least Swift have access to C structs
  // so this release us from allocating this structure just to pass flags
  // (of course theres a conversion step later)

  //local_flags.setStyle(cc::PaintFlags::kFill_Style);
  //local_flags.setAntiAlias(true);
  //local_flags.setSubpixelText(false);
  //local_flags.setLCDRenderText(false);
  //local_flags.setHinting(cc::PaintFlags::kNormal_Hinting);

  //sk_sp<SkTypeface> fTypeface = SkTypeface::MakeDefault();//(
      //fm->legacyMakeTypeface(nullptr, SkFontStyle()));
  //DCHECK(fTypeface);
  // make textblob
  //SkPaint sk_paint;
  //sk_paint.setTypeface(fTypeface);
  //const char* txt = "Hello blob!";
  //SkTDArray<uint16_t> glyph_vec;
  //size_t len = strlen(txt);
  //glyph_vec.append(sk_paint.textToGlyphs(txt, len, nullptr));
  //sk_paint.textToGlyphs(txt, len, glyph_vec.begin());

  //SkTextBlobBuilder builder;

  //sk_paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
  //const SkTextBlobBuilder::RunBuffer& run = builder.allocRun(sk_paint, glyph_vec.count(), 10, 10,
   //                                                          nullptr);
  //memcpy(run.glyphs, glyph_vec.begin(), glyph_vec.count() * sizeof(uint16_t));

  //std::vector<cc::PaintTypeface> typefaces;
  //typefaces.push_back(cc::PaintTypeface::TestTypeface());
  //scoped_refptr<cc::PaintTextBlob> txt_blob = base::MakeRefCounted<cc::PaintTextBlob>(builder.make(), std::move(typefaces));

  canvas->drawTextBlob(
    text_blob->handle(),
    x, y, local_flags);
}

void CanvasRenderingContext2dDrawPicture(CanvasRenderingContext2dRef handle, PaintRecordRef record) {
  blink::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  canvas->drawPicture(reinterpret_cast<PaintRecord *>(record)->ref());
}

char* CanvasRenderingContext2dGetFillStyle(CanvasRenderingContext2dRef handle, int* len) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern fill_result;
  context->fillStyle(fill_result);
  String str = fill_result.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void CanvasRenderingContext2dSetFillStyle(CanvasRenderingContext2dRef handle, const char* style) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern canvas_style;
  canvas_style.SetString(String::FromUTF8(style));
  context->setFillStyle(canvas_style);
}

void CanvasRenderingContext2dFillRect(CanvasRenderingContext2dRef handle, int x, int y, int w, int h) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fillRect(x, y, w, h);
}

double CanvasRenderingContext2dGetLineWidth(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->lineWidth();
}
int CanvasRenderingContext2dGetLineCap(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String cap = context->lineCap();
  if (cap == "butt")
    return 0;
  if (cap == "round")
    return 1;
  if (cap == "square")
    return 2;

  return 0;
}

int CanvasRenderingContext2dGetLineJoin(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String join = context->lineJoin();
  if (join == "round")
    return 0;
  if (join == "bevel")
    return 1;
  if (join == "miter")
    return 2;

  return 0;
}

double CanvasRenderingContext2dGetMiterLimit(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->miterLimit();
}

void CanvasRenderingContext2dGetLineDash(CanvasRenderingContext2dRef handle, double** values, int* value_count) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  const Vector<double> dashes = context->getLineDash();
  *values = reinterpret_cast<double*>(malloc(sizeof(double) * dashes.size()));
  for (size_t i = 0; i < dashes.size(); ++i) {
    *values[i] = dashes[i];
  }
  *value_count = dashes.size();
}

void CanvasRenderingContext2dSetLineDash(CanvasRenderingContext2dRef handle, double* values, int value_count) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  Vector<double> dashes;
  for (size_t i = 0; i < dashes.size(); ++i) {
    dashes.push_back(values[i]);
  }
  context->setLineDash(dashes);
}

double CanvasRenderingContext2dGetLineDashOffset(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->lineDashOffset();
}

char* CanvasRenderingContext2dGetFont(CanvasRenderingContext2dRef handle, int* len) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String str = context->font();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int CanvasRenderingContext2dGetTextAlign(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String align = context->textAlign();
  if (align == "start")
    return 0;
  if (align == "end")
    return 1;
  if (align == "left")
    return 2;
  if (align == "right")
    return 3;
  if (align == "center")
    return 4;

  return 0;
}

int CanvasRenderingContext2dGetTextBaseline(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String baseline = context->textBaseline();
  if (baseline == "top")
    return 0;
  if (baseline == "hanging")
    return 1;
  if (baseline == "middle")
    return 2;
  if (baseline == "alphabetic")
    return 3;
  if (baseline == "ideographic")
    return 4;
  if (baseline == "bottom")
    return 5;

  return 0;
}

int CanvasRenderingContext2dGetTextDirection(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String direction = context->direction();
  if (direction == "inherit")
    return 0;
  if (direction == "rtl")
    return 1;
  if (direction == "ltr")
    return 2;

  return 0;
}

double CanvasRenderingContext2dGetGlobalAlpha(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->globalAlpha();
}

void CanvasRenderingContext2dSetGlobalAlpha(CanvasRenderingContext2dRef handle, double alpha) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D*>(handle);
  context->setGlobalAlpha(alpha);
}

int CanvasRenderingContext2dGetGlobalCompositeOperation(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String composite = context->globalCompositeOperation();

  if (composite == "clear")
    return 0;
  if (composite == "copy")
    return 1;
  if (composite == "source-over")
    return 3;
  if (composite == "source-in")
    return 5;
  if (composite == "source-out")
    return 7;
  if (composite == "source-atop")
    return 9;
  if (composite == "destination-over")
    return 5;
  if (composite == "destination-in")
    return 6;
  if (composite == "destination-out")
    return 8;
  if (composite == "destination-atop")
    return 10;
  if (composite == "xor")
    return 11;
  if (composite == "lighter")
    return 12;
  if (composite == "normal")
    return 3;
  if (composite == "multiply")
    return 24;
  if (composite == "screen")
    return 14;
  if (composite == "overlay")
    return 15;
  if (composite == "darken")
    return 16;
  if (composite == "lighten")
    return 17;
  if (composite == "color-dodge")
    return 18;
  if (composite == "color-burn")
    return 19;
  if (composite == "hard-light")
    return 20;
  if (composite == "soft-light")
    return 21;
  if (composite == "difference")
    return 22;
  if (composite == "exclusion")
    return 23;
  if (composite == "hue")
    return 25;
  if (composite == "saturation")
    return 26;
  if (composite == "color")
    return 27;
  if (composite == "luminosity") 
    return 28;

  return 3;
}

char* CanvasRenderingContext2dGetFilter(CanvasRenderingContext2dRef handle, int* len) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String str = context->filter();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int CanvasRenderingContext2dImageSmoothingEnabled(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->imageSmoothingEnabled() ? 1 : 0;
}

void CanvasRenderingContext2dSetImageSmoothingEnabled(CanvasRenderingContext2dRef handle, int value) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setImageSmoothingEnabled(value != 0);
}

int CanvasRenderingContext2dGetImageSmoothingQuality(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String quality = context->imageSmoothingQuality();
  if (quality == "low")
    return 0;
  if (quality == "medium")
    return 1;
  if (quality == "high")
    return 2;
  
  return 0;
}

void CanvasRenderingContext2dSetImageSmoothingQuality(CanvasRenderingContext2dRef handle, int value) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String quality = String::FromUTF8("low");
  switch (value) {
    case 1:
      quality = String::FromUTF8("medium");
      break;
    case 2:
      quality = String::FromUTF8("high");
      break;
  }

  return context->setImageSmoothingQuality(quality);
}

char* CanvasRenderingContext2dGetStrokeStyle(CanvasRenderingContext2dRef handle, int* len) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  context->strokeStyle(stroke_style);
  String str = stroke_style.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void CanvasRenderingContext2dSetStrokeStyle(CanvasRenderingContext2dRef handle, const char* style) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  stroke_style.SetString(String::FromUTF8(style));
  context->setStrokeStyle(stroke_style);
}

double CanvasRenderingContext2dGetShadowOffsetX(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->shadowOffsetX();
}

void CanvasRenderingContext2dSetShadowOffsetX(CanvasRenderingContext2dRef handle, double value) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setShadowOffsetX(value);
}

double CanvasRenderingContext2dGetShadowOffsetY(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->shadowOffsetY();
}

void CanvasRenderingContext2dSetShadowOffsetY(CanvasRenderingContext2dRef handle, double value) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setShadowOffsetX(value);
}

double CanvasRenderingContext2dGetShadowBlur(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->shadowBlur();
}

void CanvasRenderingContext2dSetShadowBlur(CanvasRenderingContext2dRef handle, double value) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setShadowBlur(value);
}

char* CanvasRenderingContext2dGetShadowColor(CanvasRenderingContext2dRef handle, int* len) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  String str = context->shadowColor();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void CanvasRenderingContext2dSetShadowColor(CanvasRenderingContext2dRef handle, const char* color) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setShadowColor(String::FromUTF8(color));
}

void CanvasRenderingContext2dTransform(CanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->transform(a, b, c, d, e, f);
}

void CanvasRenderingContext2dSetTransform(CanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->setTransform(a, b, c, d, e, f);
}

void CanvasRenderingContext2dResetTransform(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->resetTransform();
}

CanvasGradientRef CanvasRenderingContext2dCreateLinearGradient(CanvasRenderingContext2dRef handle, double x0, double y0, double x1, double y1) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->createLinearGradient(x0, y0, x1, y1);
}

CanvasGradientRef CanvasRenderingContext2dCreateRadialGradient(CanvasRenderingContext2dRef handle, double x0, double y0, double r0, double x1, double y1, double r1) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->createRadialGradient(x0, y0, r0, x1, y1, r1, state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternImageBitmap(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternImageBitmapForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternImageBitmapForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternCSSImageValue(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternCSSImageValueForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternCSSImageValueForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlImageElement(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlImageElementForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlImageElementForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternSVGImageElement(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternSVGImageElementForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternSVGImageElementForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlCanvasElement(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlCanvasElementForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlCanvasElementForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternOffscreenCanvas(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternOffscreenCanvasForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternOffscreenCanvasForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlVideoElement(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlVideoElementForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef CanvasRenderingContext2dCreatePatternHtmlVideoElementForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

void CanvasRenderingContext2dStrokeRect(CanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->strokeRect(x, y, width, height);
}

void CanvasRenderingContext2dBeginPath(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->beginPath();
}

void CanvasRenderingContext2dFillWithWinding(CanvasRenderingContext2dRef handle, int w) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fill(w == 0 ? "nonzero" : "evenodd");
}

void CanvasRenderingContext2dFill(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fill();
}

void CanvasRenderingContext2dFillWithPathAndWinding(CanvasRenderingContext2dRef handle, Path2dRef path, int w) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path), w == 0 ? "nonzero" : "evenodd");
}

void CanvasRenderingContext2dFillWithPath(CanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path));
}

void CanvasRenderingContext2dStroke(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->stroke();
}

void CanvasRenderingContext2dStrokeWithPath(CanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->stroke(reinterpret_cast<blink::Path2D*>(path));
}

void CanvasRenderingContext2dClip(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->clip();
}

void CanvasRenderingContext2dClipWithPath(CanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->clip(reinterpret_cast<blink::Path2D*>(path));
}

int CanvasRenderingContext2dIsPointInPathWithWinding(CanvasRenderingContext2dRef handle, double x, double y, int w) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->isPointInPath(x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int CanvasRenderingContext2dIsPointInPath(CanvasRenderingContext2dRef handle, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->isPointInPath(x, y) ? 1 : 0;
}

int CanvasRenderingContext2dIsPointInPathWithPathAndWinding(CanvasRenderingContext2dRef handle, Path2dRef path, double x, double y, int w) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int CanvasRenderingContext2dIsPointInPathWithPath(CanvasRenderingContext2dRef handle, Path2dRef path, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y) ? 1 : 0;
}

int CanvasRenderingContext2dIsPointInStroke(CanvasRenderingContext2dRef handle, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  return context->isPointInStroke(x, y) ? 1 : 0;
}
//int CanvasRenderingContext2dIsPointInStroke(CanvasRenderingContext2dRef handle, int x, int y) {}
void CanvasRenderingContext2dFillTextWithWidth(CanvasRenderingContext2dRef handle, const char* text, double x, double y, double width) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fillText(String::FromUTF8(text), x, y, width);
}

void CanvasRenderingContext2dFillText(CanvasRenderingContext2dRef handle, const char* text, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->fillText(String::FromUTF8(text), x, y);
}

void CanvasRenderingContext2dStrokeTextWithWidth(CanvasRenderingContext2dRef handle, const char* text, double x, double y, double width) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->strokeText(String::FromUTF8(text), x, y, width);
}

void CanvasRenderingContext2dStrokeText(CanvasRenderingContext2dRef handle, const char* text, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->strokeText(String::FromUTF8(text), x, y);
}

void CanvasRenderingContext2dDrawImageBitmap(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageBitmapWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageBitmapSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageBitmapForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageBitmapWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageBitmapSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageBitmapForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageBitmapWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageBitmapSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageCSSImage(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageCSSImageWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageCSSImageSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageCSSImageForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageCSSImageWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageCSSImageSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageCSSImageForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageCSSImageWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageCSSImageSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLImage(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLImageSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageSVGImage(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageSVGImageWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageSVGImageSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageSVGImageForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageSVGImageWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageSVGImageSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageSVGImageForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageSVGImageWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageSVGImageSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvas(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvas(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideo(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoWH(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoSrcDst(CanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoWHForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoSrcDstForWorker(CanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoWHForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void CanvasRenderingContext2dDrawImageHTMLVideoSrcDstForServiceWorker(CanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

WebImageDataRef CanvasRenderingContext2dCreateImageData(CanvasRenderingContext2dRef handle, int width, int height, int color_format, int storage_format) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(width, height, settings, state);
}

WebImageDataRef CanvasRenderingContext2dCreateImageDataWithImageData(CanvasRenderingContext2dRef handle, WebImageDataRef data) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->createImageData(reinterpret_cast<blink::ImageData*>(data), state);
}

WebImageDataRef CanvasRenderingContext2dCreateImageDataWithBytes(CanvasRenderingContext2dRef handle, int width, int height, const uint8_t* data, int count, int color_format, int storage_format) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(blink::DOMUint8ClampedArray::Create(data, count)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef CanvasRenderingContext2dCreateImageDataWithUint8Array(CanvasRenderingContext2dRef handle, int width, int height, DOMArrayBufferRef data, int color_format, int storage_format) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(reinterpret_cast<blink::DOMUint8ClampedArray *>(data)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef CanvasRenderingContext2dGetImageData(CanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->getImageData(x, y, width, height, state);
}

void CanvasRenderingContext2dPutImageData(CanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, state);
}

void CanvasRenderingContext2dPutImageDataWithDamage(CanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y, int dirty_x, int dirty_y, int dirty_width, int dirty_height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, dirty_x, dirty_y, dirty_width, dirty_height, state);
}

void CanvasRenderingContext2dClosePath(CanvasRenderingContext2dRef handle) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->closePath();
}

void CanvasRenderingContext2dMoveTo(CanvasRenderingContext2dRef handle, float x, float y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->moveTo(x, y);
}

void CanvasRenderingContext2dLineTo(CanvasRenderingContext2dRef handle, float x, float y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->lineTo(x, y);
}

void CanvasRenderingContext2dQuadraticCurveTo(CanvasRenderingContext2dRef handle, float cpx, float cpy, float x, float y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->quadraticCurveTo(cpx, cpy, x, y);
}

void CanvasRenderingContext2dBezierCurveTo(CanvasRenderingContext2dRef handle, float cp1x, float cp1y, float cp2x, float cp2y, float x, float y) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

void CanvasRenderingContext2dArcTo(CanvasRenderingContext2dRef handle, float x1, float y1, float x2, float y2, float radius) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->arcTo(x1, y1, x2, y2, radius, state);
}

void CanvasRenderingContext2dRect(CanvasRenderingContext2dRef handle, float x, float y, float width, float height) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  context->rect(x, y, width, height);
}

void CanvasRenderingContext2dArc(CanvasRenderingContext2dRef handle, float x, float y, float radius, float startAngle, float endAngle, int anticlockwise) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->arc(x, y, radius, startAngle, endAngle, anticlockwise != 0, state);
}

void CanvasRenderingContext2dEllipse(CanvasRenderingContext2dRef handle, float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, int anticlockwise) {
  blink::CanvasRenderingContext2D* context = reinterpret_cast<blink::CanvasRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise != 0, state);
}

void PaintCanvasRenderingContext2dDestroy(PaintCanvasRenderingContext2dRef handle) {
 
}

DisplayItemListRef PaintCanvasRenderingContext2dGetDisplayItemList(PaintCanvasRenderingContext2dRef handle) {
  cc::PaintRecorder* paint_recorder = GetPaintRecorderFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  if (!paint_recorder) {
    //DLOG(INFO) << "PaintCanvasRenderingContext2dGetDisplayItemList: PaintRecorder IS null!! failling miserably..";
    DCHECK(false);
    return nullptr;
  }
  return new _DisplayItemList(paint_recorder);
  //cc::PaintCanvas* canvas = GetCanvas(reinterpret_cast<blink::CanvasRenderingContext2D *>(handle));
  // if (!canvas) {
  //   //DLOG(INFO) << "PaintCanvasRenderingContext2dGetDisplayItemList: PaintCanvas IS null!! failling miserably..";
  //   DCHECK(false);
  //   return nullptr;
  // }
  // //DLOG(INFO) << "PaintCanvasRenderingContext2dGetDisplayItemList: PaintCanvas = " << canvas;
  // return new _DisplayItemList(canvas);
}

int PaintCanvasRenderingContext2dGetSaveCount(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->getSaveCount();
}

int PaintCanvasRenderingContext2dGetLocalClipBounds(PaintCanvasRenderingContext2dRef handle, float* x, float* y, float* width, float* height) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect bounds;
  bool result = canvas->getLocalClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int PaintCanvasRenderingContext2dGetDeviceClipBounds(PaintCanvasRenderingContext2dRef handle, int* x, int* y, int* width, int* height) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkIRect bounds;
  bool result = canvas->getDeviceClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int PaintCanvasRenderingContext2dIsClipEmpty(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->isClipEmpty();
}

int PaintCanvasRenderingContext2dIsClipRect(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->isClipRect();
}

MatrixRef PaintCanvasRenderingContext2dTotalMatrix(PaintCanvasRenderingContext2dRef handle) {
  return nullptr;
}

void PaintCanvasRenderingContext2dFlush(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->flush();
}

int PaintCanvasRenderingContext2dSave(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->save();
}

int PaintCanvasRenderingContext2dSaveLayerRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  return canvas->saveLayer(&rect, flags);
}

int PaintCanvasRenderingContext2dSaveLayer(PaintCanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  return canvas->saveLayer(nullptr, flags);
}

int PaintCanvasRenderingContext2dSaveLayerAlpha(PaintCanvasRenderingContext2dRef handle, int alpha) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->saveLayerAlpha(nullptr, alpha, true);
}

int PaintCanvasRenderingContext2dSaveLayerAlphaRect(PaintCanvasRenderingContext2dRef handle, int alpha, float rx, float ry, float rw, float rh) {
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  return canvas->saveLayerAlpha(&rect,
                                alpha,
                                true);
}

int PaintCanvasRenderingContext2dSaveLayerPreserveLCDTextRequestsRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

int PaintCanvasRenderingContext2dSaveLayerPreserveLCDTextRequests(PaintCanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

void PaintCanvasRenderingContext2dRestore(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->restore();
}

void PaintCanvasRenderingContext2dRestoreToCount(PaintCanvasRenderingContext2dRef handle, int save_count) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->restoreToCount(save_count);
}

void PaintCanvasRenderingContext2dTranslate(PaintCanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->translate(x, y);
}

void PaintCanvasRenderingContext2dScale(PaintCanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->scale(x, y);
}

void PaintCanvasRenderingContext2dRotate(PaintCanvasRenderingContext2dRef handle, float radians) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->rotate(radians);
}

void PaintCanvasRenderingContext2dConcatHandle(PaintCanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->concat(*m);
}

void PaintCanvasRenderingContext2dSetMatrixHandle(PaintCanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->setMatrix(*m);
}

void PaintCanvasRenderingContext2dClipRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->clipRect(rect, static_cast<SkClipOp>(clip), anti_alias);
}

void PaintCanvasRenderingContext2dClipRRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->clipRRect(r, static_cast<SkClipOp>(clip), anti_alias);
}

void PaintCanvasRenderingContext2dClipPath(PaintCanvasRenderingContext2dRef handle, PathRef path, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->clipPath(reinterpret_cast<SkiaPath*>(path)->ref(), static_cast<SkClipOp>(clip), anti_alias);
}

void PaintCanvasRenderingContext2dClearRect(PaintCanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh) {
  reinterpret_cast<blink::PaintRenderingContext2D *>(handle)->clearRect(rx, ry, rw, rh);
}

void PaintCanvasRenderingContext2dDrawColor(PaintCanvasRenderingContext2dRef handle, int a, int r, int g, int b, int mode) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->drawColor(SkColorSetARGB(a, r, g, b), static_cast<SkBlendMode>(mode));
}

void PaintCanvasRenderingContext2dDrawLine(PaintCanvasRenderingContext2dRef handle, float sx, float sy, float ex, float ey, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->drawLine(sx, sy, ex, ey, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
} 

void PaintCanvasRenderingContext2dDrawIRect(PaintCanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkIRect rect = SkIRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawIRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawOval(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawOval(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawRRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->drawRRect(r, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawDRRect(PaintCanvasRenderingContext2dRef handle, float ox, float oy, float ow, float oh, float ix, float iy, float iw, float ih, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRRect outer = SkRRect::MakeRect(SkRect::MakeXYWH(ox, oy, ow, oh));
  SkRRect inner = SkRRect::MakeRect(SkRect::MakeXYWH(ix, iy, iw, ih));
  canvas->drawDRRect(outer, inner, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawRoundRect(PaintCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRoundRect(rect, x, y, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void PaintCanvasRenderingContext2dDrawPath(PaintCanvasRenderingContext2dRef handle, PathRef path, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->drawPath(reinterpret_cast<SkiaPath*>(path)->ref(), reinterpret_cast<PaintFlags *>(paint)->const_ref()); 
}

void PaintCanvasRenderingContext2dDrawImage(PaintCanvasRenderingContext2dRef handle, ImageRef image, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();
  canvas->drawImage(
    paint_image,
    x, y,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr); 
}

void PaintCanvasRenderingContext2dDrawImageRect(
  PaintCanvasRenderingContext2dRef handle, 
  ImageRef image, 
  float sx, float sy, float sw, float sh,
  float dx, float dy, float dw, float dh,
  int src_rect_constraint, 
  PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  SkRect src = SkRect::MakeXYWH(int(sx), int(sy), int(sw), int(sh));
  SkRect dst = SkRect::MakeXYWH(int(dx), int(dy), int(dw), int(dh));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix  
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();

  canvas->drawImageRect(
    paint_image, 
    src, 
    dst,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr, 
    static_cast<cc::PaintCanvas::SrcRectConstraint>(src_rect_constraint));
}

void PaintCanvasRenderingContext2dDrawBitmap(PaintCanvasRenderingContext2dRef handle, BitmapRef bitmap, float left, float top, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->drawBitmap(
    *reinterpret_cast<SkBitmap *>(bitmap),
    left, top,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr);
}

void PaintCanvasRenderingContext2dDrawTextBlob(PaintCanvasRenderingContext2dRef handle, PaintTextBlobRef text, float x, float y, PaintFlagsRef paint) {
  PaintTextBlob* text_blob = reinterpret_cast<PaintTextBlob *>(text);
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  const cc::PaintFlags& local_flags = reinterpret_cast<PaintFlags *>(paint)->const_ref();
  
  canvas->drawTextBlob(
    text_blob->handle(),
    x, y, local_flags);
}

void PaintCanvasRenderingContext2dDrawPicture(PaintCanvasRenderingContext2dRef handle, PaintRecordRef record) {
  blink::PaintCanvas* canvas = GetCanvasFromPaint(reinterpret_cast<blink::PaintRenderingContext2D *>(handle));
  canvas->drawPicture(reinterpret_cast<PaintRecord *>(record)->ref());
}


char* PaintCanvasRenderingContext2dGetFillStyle(PaintCanvasRenderingContext2dRef handle, int* len) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern fill_result;
  context->fillStyle(fill_result);
  String str = fill_result.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void PaintCanvasRenderingContext2dSetFillStyle(PaintCanvasRenderingContext2dRef handle, const char* style) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern canvas_style;
  canvas_style.SetString(String::FromUTF8(style));
  context->setFillStyle(canvas_style);
}

void PaintCanvasRenderingContext2dFillRect(PaintCanvasRenderingContext2dRef handle, int x, int y, int w, int h) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->fillRect(x, y, w, h);
}

double PaintCanvasRenderingContext2dGetLineWidth(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->lineWidth();
}
int PaintCanvasRenderingContext2dGetLineCap(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String cap = context->lineCap();
  if (cap == "butt")
    return 0;
  if (cap == "round")
    return 1;
  if (cap == "square")
    return 2;

  return 0;
}

int PaintCanvasRenderingContext2dGetLineJoin(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String join = context->lineJoin();
  if (join == "round")
    return 0;
  if (join == "bevel")
    return 1;
  if (join == "miter")
    return 2;

  return 0;
}

double PaintCanvasRenderingContext2dGetMiterLimit(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->miterLimit();
}

void PaintCanvasRenderingContext2dGetLineDash(PaintCanvasRenderingContext2dRef handle, double** values, int* value_count) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  const Vector<double> dashes = context->getLineDash();
  *values = reinterpret_cast<double*>(malloc(sizeof(double) * dashes.size()));
  for (size_t i = 0; i < dashes.size(); ++i) {
    *values[i] = dashes[i];
  }
  *value_count = dashes.size();
}

void PaintCanvasRenderingContext2dSetLineDash(PaintCanvasRenderingContext2dRef handle, double* values, int value_count) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  Vector<double> dashes;
  for (size_t i = 0; i < dashes.size(); ++i) {
    dashes.push_back(values[i]);
  }
  context->setLineDash(dashes);
}

double PaintCanvasRenderingContext2dGetLineDashOffset(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->lineDashOffset();
}

int PaintCanvasRenderingContext2dGetTextAlign(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String align = context->textAlign();
  if (align == "start")
    return 0;
  if (align == "end")
    return 1;
  if (align == "left")
    return 2;
  if (align == "right")
    return 3;
  if (align == "center")
    return 4;

  return 0;
}

int PaintCanvasRenderingContext2dGetTextBaseline(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String baseline = context->textBaseline();
  if (baseline == "top")
    return 0;
  if (baseline == "hanging")
    return 1;
  if (baseline == "middle")
    return 2;
  if (baseline == "alphabetic")
    return 3;
  if (baseline == "ideographic")
    return 4;
  if (baseline == "bottom")
    return 5;

  return 0;
}

double PaintCanvasRenderingContext2dGetGlobalAlpha(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->globalAlpha();
}

void PaintCanvasRenderingContext2dSetGlobalAlpha(PaintCanvasRenderingContext2dRef handle, double alpha) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D*>(handle);
  context->setGlobalAlpha(alpha);
}

int PaintCanvasRenderingContext2dGetGlobalCompositeOperation(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String composite = context->globalCompositeOperation();

  if (composite == "clear")
    return 0;
  if (composite == "copy")
    return 1;
  if (composite == "source-over")
    return 3;
  if (composite == "source-in")
    return 5;
  if (composite == "source-out")
    return 7;
  if (composite == "source-atop")
    return 9;
  if (composite == "destination-over")
    return 5;
  if (composite == "destination-in")
    return 6;
  if (composite == "destination-out")
    return 8;
  if (composite == "destination-atop")
    return 10;
  if (composite == "xor")
    return 11;
  if (composite == "lighter")
    return 12;
  if (composite == "normal")
    return 3;
  if (composite == "multiply")
    return 24;
  if (composite == "screen")
    return 14;
  if (composite == "overlay")
    return 15;
  if (composite == "darken")
    return 16;
  if (composite == "lighten")
    return 17;
  if (composite == "color-dodge")
    return 18;
  if (composite == "color-burn")
    return 19;
  if (composite == "hard-light")
    return 20;
  if (composite == "soft-light")
    return 21;
  if (composite == "difference")
    return 22;
  if (composite == "exclusion")
    return 23;
  if (composite == "hue")
    return 25;
  if (composite == "saturation")
    return 26;
  if (composite == "color")
    return 27;
  if (composite == "luminosity") 
    return 28;

  return 3;
}

char* PaintCanvasRenderingContext2dGetFilter(PaintCanvasRenderingContext2dRef handle, int* len) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String str = context->filter();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int PaintCanvasRenderingContext2dImageSmoothingEnabled(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->imageSmoothingEnabled() ? 1 : 0;
}

void PaintCanvasRenderingContext2dSetImageSmoothingEnabled(PaintCanvasRenderingContext2dRef handle, int value) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setImageSmoothingEnabled(value != 0);
}

int PaintCanvasRenderingContext2dGetImageSmoothingQuality(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String quality = context->imageSmoothingQuality();
  if (quality == "low")
    return 0;
  if (quality == "medium")
    return 1;
  if (quality == "high")
    return 2;
  
  return 0;
}

void PaintCanvasRenderingContext2dSetImageSmoothingQuality(PaintCanvasRenderingContext2dRef handle, int value) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String quality = String::FromUTF8("low");
  switch (value) {
    case 1:
      quality = String::FromUTF8("medium");
      break;
    case 2:
      quality = String::FromUTF8("high");
      break;
  }

  return context->setImageSmoothingQuality(quality);
}

char* PaintCanvasRenderingContext2dGetStrokeStyle(PaintCanvasRenderingContext2dRef handle, int* len) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  context->strokeStyle(stroke_style);
  String str = stroke_style.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void PaintCanvasRenderingContext2dSetStrokeStyle(PaintCanvasRenderingContext2dRef handle, const char* style) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  stroke_style.SetString(String::FromUTF8(style));
  context->setStrokeStyle(stroke_style);
}

double PaintCanvasRenderingContext2dGetShadowOffsetX(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->shadowOffsetX();
}

void PaintCanvasRenderingContext2dSetShadowOffsetX(PaintCanvasRenderingContext2dRef handle, double value) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setShadowOffsetX(value);
}

double PaintCanvasRenderingContext2dGetShadowOffsetY(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->shadowOffsetY();
}

void PaintCanvasRenderingContext2dSetShadowOffsetY(PaintCanvasRenderingContext2dRef handle, double value) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setShadowOffsetX(value);
}

double PaintCanvasRenderingContext2dGetShadowBlur(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->shadowBlur();
}

void PaintCanvasRenderingContext2dSetShadowBlur(PaintCanvasRenderingContext2dRef handle, double value) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setShadowBlur(value);
}

char* PaintCanvasRenderingContext2dGetShadowColor(PaintCanvasRenderingContext2dRef handle, int* len) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  String str = context->shadowColor();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void PaintCanvasRenderingContext2dSetShadowColor(PaintCanvasRenderingContext2dRef handle, const char* color) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setShadowColor(String::FromUTF8(color));
}

void PaintCanvasRenderingContext2dTransform(PaintCanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->transform(a, b, c, d, e, f);
}

void PaintCanvasRenderingContext2dSetTransform(PaintCanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->setTransform(a, b, c, d, e, f);
}

void PaintCanvasRenderingContext2dResetTransform(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->resetTransform();
}

CanvasGradientRef PaintCanvasRenderingContext2dCreateLinearGradient(PaintCanvasRenderingContext2dRef handle, double x0, double y0, double x1, double y1) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->createLinearGradient(x0, y0, x1, y1);
}

CanvasGradientRef PaintCanvasRenderingContext2dCreateRadialGradient(PaintCanvasRenderingContext2dRef handle, double x0, double y0, double r0, double x1, double y1, double r1) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->createRadialGradient(x0, y0, r0, x1, y1, r1, state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternImageBitmap(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternImageBitmapForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternImageBitmapForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternCSSImageValue(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternCSSImageValueForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternCSSImageValueForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlImageElement(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlImageElementForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlImageElementForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternSVGImageElement(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternSVGImageElementForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternSVGImageElementForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlCanvasElement(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlCanvasElementForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlCanvasElementForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternOffscreenCanvas(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternOffscreenCanvasForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternOffscreenCanvasForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlVideoElement(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlVideoElementForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef PaintCanvasRenderingContext2dCreatePatternHtmlVideoElementForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

void PaintCanvasRenderingContext2dStrokeRect(PaintCanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->strokeRect(x, y, width, height);
}

void PaintCanvasRenderingContext2dBeginPath(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->beginPath();
}

void PaintCanvasRenderingContext2dFillWithWinding(PaintCanvasRenderingContext2dRef handle, int w) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->fill(w == 0 ? "nonzero" : "evenodd");
}

void PaintCanvasRenderingContext2dFill(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->fill();
}

void PaintCanvasRenderingContext2dFillWithPathAndWinding(PaintCanvasRenderingContext2dRef handle, Path2dRef path, int w) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path), w == 0 ? "nonzero" : "evenodd");
}

void PaintCanvasRenderingContext2dFillWithPath(PaintCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path));
}

void PaintCanvasRenderingContext2dStroke(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->stroke();
}

void PaintCanvasRenderingContext2dStrokeWithPath(PaintCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->stroke(reinterpret_cast<blink::Path2D*>(path));
}

void PaintCanvasRenderingContext2dClip(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->clip();
}

void PaintCanvasRenderingContext2dClipWithPath(PaintCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->clip(reinterpret_cast<blink::Path2D*>(path));
}

int PaintCanvasRenderingContext2dIsPointInPathWithWinding(PaintCanvasRenderingContext2dRef handle, double x, double y, int w) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->isPointInPath(x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int PaintCanvasRenderingContext2dIsPointInPath(PaintCanvasRenderingContext2dRef handle, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->isPointInPath(x, y) ? 1 : 0;
}

int PaintCanvasRenderingContext2dIsPointInPathWithPathAndWinding(PaintCanvasRenderingContext2dRef handle, Path2dRef path, double x, double y, int w) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int PaintCanvasRenderingContext2dIsPointInPathWithPath(PaintCanvasRenderingContext2dRef handle, Path2dRef path, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y) ? 1 : 0;
}

int PaintCanvasRenderingContext2dIsPointInStroke(PaintCanvasRenderingContext2dRef handle, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  return context->isPointInStroke(x, y) ? 1 : 0;
}

void PaintCanvasRenderingContext2dDrawImageBitmap(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageBitmapSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImage(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageCSSImageSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImage(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLImageSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImage(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageSVGImageSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvas(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvas(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideo(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoWH(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoSrcDst(PaintCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoWHForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoSrcDstForWorker(PaintCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoWHForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void PaintCanvasRenderingContext2dDrawImageHTMLVideoSrcDstForServiceWorker(PaintCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

WebImageDataRef PaintCanvasRenderingContext2dCreateImageData(PaintCanvasRenderingContext2dRef handle, int width, int height, int color_format, int storage_format) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(width, height, settings, state);
}

WebImageDataRef PaintCanvasRenderingContext2dCreateImageDataWithImageData(PaintCanvasRenderingContext2dRef handle, WebImageDataRef data) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->createImageData(reinterpret_cast<blink::ImageData*>(data), state);
}

WebImageDataRef PaintCanvasRenderingContext2dCreateImageDataWithBytes(PaintCanvasRenderingContext2dRef handle, int width, int height, const uint8_t* data, int count, int color_format, int storage_format) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(blink::DOMUint8ClampedArray::Create(data, count)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef PaintCanvasRenderingContext2dCreateImageDataWithUint8Array(PaintCanvasRenderingContext2dRef handle, int width, int height, DOMArrayBufferRef data, int color_format, int storage_format) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(reinterpret_cast<blink::DOMUint8ClampedArray *>(data)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef PaintCanvasRenderingContext2dGetImageData(PaintCanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  return context->getImageData(x, y, width, height, state);
}

void PaintCanvasRenderingContext2dPutImageData(PaintCanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, state);
}

void PaintCanvasRenderingContext2dPutImageDataWithDamage(PaintCanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y, int dirty_x, int dirty_y, int dirty_width, int dirty_height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, dirty_x, dirty_y, dirty_width, dirty_height, state);
}

void PaintCanvasRenderingContext2dClosePath(PaintCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->closePath();
}

void PaintCanvasRenderingContext2dMoveTo(PaintCanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->moveTo(x, y);
}

void PaintCanvasRenderingContext2dLineTo(PaintCanvasRenderingContext2dRef handle, float x, float y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->lineTo(x, y);
}

void PaintCanvasRenderingContext2dQuadraticCurveTo(PaintCanvasRenderingContext2dRef handle, float cpx, float cpy, float x, float y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->quadraticCurveTo(cpx, cpy, x, y);
}

void PaintCanvasRenderingContext2dBezierCurveTo(PaintCanvasRenderingContext2dRef handle, float cp1x, float cp1y, float cp2x, float cp2y, float x, float y) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

void PaintCanvasRenderingContext2dArcTo(PaintCanvasRenderingContext2dRef handle, float x1, float y1, float x2, float y2, float radius) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->arcTo(x1, y1, x2, y2, radius, state);
}

void PaintCanvasRenderingContext2dRect(PaintCanvasRenderingContext2dRef handle, float x, float y, float width, float height) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->rect(x, y, width, height);
}

void PaintCanvasRenderingContext2dArc(PaintCanvasRenderingContext2dRef handle, float x, float y, float radius, float startAngle, float endAngle, int anticlockwise) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->arc(x, y, radius, startAngle, endAngle, anticlockwise != 0, state);
}

void PaintCanvasRenderingContext2dEllipse(PaintCanvasRenderingContext2dRef handle, float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, int anticlockwise) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  blink::NonThrowableExceptionState state;
  context->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise != 0, state);
}



// WebInputEvent

float _WebInputEventGetFrameScale(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebInputEvent *>(handle)->FrameScale(); 
}

void _WebInputEventSetFrameScale(WebInputEventRef handle, float scale) {
  reinterpret_cast<blink::WebInputEvent *>(handle)->SetFrameScale(scale);
}

void _WebInputEventGetFrameTranslate(WebInputEventRef handle, float* x, float* y) {
  blink::WebFloatPoint pt = reinterpret_cast<blink::WebInputEvent *>(handle)->FrameTranslate();
  *x = pt.x;
  *y = pt.y;
}

void _WebInputEventSetFrameTranslate(WebInputEventRef handle, float x, float y) {
  reinterpret_cast<blink::WebInputEvent *>(handle)->SetFrameTranslate(blink::WebFloatPoint(x, y));
}

int _WebInputEventGetType(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebInputEvent *>(handle)->GetType();
}

void _WebInputEventSetType(WebInputEventRef handle, int type) {
  reinterpret_cast<blink::WebInputEvent *>(handle)->SetType(static_cast<blink::WebInputEvent::Type>(type));
}

int _WebInputEventGetModifiers(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebInputEvent *>(handle)->GetModifiers(); 
}

void _WebInputEventSetModifiers(WebInputEventRef handle, int type) {
  reinterpret_cast<blink::WebInputEvent *>(handle)->SetModifiers(type);
}

int64_t _WebInputEventGetTimestamp(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebInputEvent *>(handle)->TimeStamp().ToInternalValue();
}

void _WebInputEventSetTimestamp(WebInputEventRef handle, int64_t ts) {
  reinterpret_cast<blink::WebInputEvent *>(handle)->SetTimeStamp(base::TimeTicks::FromInternalValue(ts));
}

int _WebInputEventGetSize(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebInputEvent *>(handle)->size();
}

int _WebInputEventIsMouseEvent(WebInputEventRef handle) {
  return blink::WebInputEvent::IsMouseEventType(reinterpret_cast<blink::WebInputEvent *>(handle)->GetType()) ? 1 : 0;
}

int _WebInputEventIsKeyboardEvent(WebInputEventRef handle) {
  return blink::WebInputEvent::IsKeyboardEventType(reinterpret_cast<blink::WebInputEvent *>(handle)->GetType()) ? 1 : 0;
}

int _WebInputEventIsTouchEvent(WebInputEventRef handle) {
  return blink::WebInputEvent::IsTouchEventType(reinterpret_cast<blink::WebInputEvent *>(handle)->GetType()) ? 1 : 0;
}

int _WebInputEventIsGestureEvent(WebInputEventRef handle) {
  return blink::WebInputEvent::IsGestureEventType(reinterpret_cast<blink::WebInputEvent *>(handle)->GetType()) ? 1 : 0;
}

int _WebInputEventIsPointerEvent(WebInputEventRef handle) {
  return blink::WebInputEvent::IsPointerEventType(reinterpret_cast<blink::WebInputEvent *>(handle)->GetType()) ? 1 : 0;
}

void _WebMouseEventGetPositionInWidget(WebInputEventRef handle, float* x, float* y) {
  blink::WebFloatPoint pt = reinterpret_cast<blink::WebMouseEvent *>(handle)->PositionInWidget();
  *x = pt.x;
  *y = pt.y;
}

void _WebMouseEventSetPositionInWidget(WebInputEventRef handle, float x, float y) {
  reinterpret_cast<blink::WebMouseEvent *>(handle)->SetPositionInWidget(x, y);
}

void _WebMouseEventGetPositionInScreen(WebInputEventRef handle, float* x, float* y) {
  blink::WebFloatPoint pt = reinterpret_cast<blink::WebMouseEvent *>(handle)->PositionInScreen();
  *x = pt.x;
  *y = pt.y;
}

void _WebMouseEventSetPositionInScreen(WebInputEventRef handle, float x, float y) {
  reinterpret_cast<blink::WebMouseEvent *>(handle)->SetPositionInScreen(x, y);
}

int32_t _WebMouseEventGetId(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebMouseEvent *>(handle)->id;
}

float _WebMouseEventGetForce(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebMouseEvent *>(handle)->force;
}

int32_t _WebMouseEventGetButton(WebInputEventRef handle) {
  return static_cast<int32_t>(reinterpret_cast<blink::WebMouseEvent *>(handle)->button);
}

int _WebMouseEventGetMovementX(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebMouseEvent *>(handle)->movement_x;
}

int _WebMouseEventGetMovementY(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebMouseEvent *>(handle)->movement_y;
}

int _WebMouseEventGetClickCount(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebMouseEvent *>(handle)->click_count;
}

void _WebGestureEventGetPositionInWidget(WebInputEventRef handle, float* x, float* y) {
  blink::WebFloatPoint pt = reinterpret_cast<blink::WebGestureEvent *>(handle)->PositionInWidget();
  *x = pt.x;
  *y = pt.y; 
}

void _WebGestureEventSetPositionInWidget(WebInputEventRef handle, float x, float y) {
  reinterpret_cast<blink::WebGestureEvent *>(handle)->SetPositionInWidget(blink::WebFloatPoint(x, y));
}

void _WebGestureEventGetPositionInScreen(WebInputEventRef handle, float* x, float* y) {
  blink::WebFloatPoint pt = reinterpret_cast<blink::WebGestureEvent *>(handle)->PositionInScreen();
  *x = pt.x;
  *y = pt.y;
}

void _WebGestureEventSetPositionInScreen(WebInputEventRef handle, float x, float y) {
  reinterpret_cast<blink::WebGestureEvent *>(handle)->SetPositionInScreen(blink::WebFloatPoint(x, y));
}

int _WebKeyboardEventGetWindowsKeyCode(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->windows_key_code;
}

void _WebKeyboardEventSetWindowsKeyCode(WebInputEventRef handle, int code) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->windows_key_code = code;
}

int _WebKeyboardEventGetNativeKeyCode(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->native_key_code;
}

void _WebKeyboardEventSetNativeKeyCode(WebInputEventRef handle, int code) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->native_key_code = code;
}

int _WebKeyboardEventGetDomCode(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->dom_code;
}

void _WebKeyboardEventSetDomCode(WebInputEventRef handle, int code) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->dom_code = code;
}

int _WebKeyboardEventGetDomKey(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->dom_key;
}

void _WebKeyboardEventSetDomKey(WebInputEventRef handle, int code) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->dom_key = code;
}

int _WebKeyboardEventIsSystemKey(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->is_system_key;
}

void _WebKeyboardEventSetIsSystemKey(WebInputEventRef handle, int system_key) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->is_system_key = system_key != 0;
}

int _WebKeyboardEventIsBrowserShortcut(WebInputEventRef handle) {
  return reinterpret_cast<blink::WebKeyboardEvent *>(handle)->is_browser_shortcut;
}

void _WebKeyboardEventSetIsBrowserShortcut(WebInputEventRef handle, int is_browser_shortcut) {
  reinterpret_cast<blink::WebKeyboardEvent *>(handle)->is_browser_shortcut = is_browser_shortcut != 0;
}

void _WebKeyboardEventGetText(WebInputEventRef handle, void* ptr, void(*cb)(void*, const uint16_t*)) {
  cb(ptr, reinterpret_cast<blink::WebKeyboardEvent *>(handle)->text);
}

void _WebKeyboardEventSetText(WebInputEventRef handle, const char* text, int size) {
  size_t real_size = static_cast<size_t>(size) > blink::WebKeyboardEvent::kTextLengthCap ? blink::WebKeyboardEvent::kTextLengthCap : size;
  base::string16 utf16_text = base::ASCIIToUTF16(text);
  std::memcpy(reinterpret_cast<blink::WebKeyboardEvent *>(handle)->text, utf16_text.data(), real_size);
}

void _WebKeyboardEventGetUnmodifiedText(WebInputEventRef handle, void* ptr, void(*cb)(void*, const uint16_t*)) {
  cb(ptr, reinterpret_cast<blink::WebKeyboardEvent *>(handle)->unmodified_text);
}

void _WebKeyboardEventSetUnmodifiedText(WebInputEventRef handle, const char* text, int size) {
  size_t real_size = static_cast<size_t>(size) > blink::WebKeyboardEvent::kTextLengthCap ? blink::WebKeyboardEvent::kTextLengthCap : size;
  base::string16 utf16_text = base::ASCIIToUTF16(text);
  std::memcpy(reinterpret_cast<blink::WebKeyboardEvent *>(handle)->unmodified_text, utf16_text.data(), real_size);
}

// XMLHttpRequest
XMLHttpRequestRef _XMLHttpRequestCreate(WebNodeRef document) {
  WebNodeWrapper* document_ref = reinterpret_cast<WebNodeWrapper *>(document);
  return blink::XMLHttpRequest::Create(document_ref->unwrap<blink::Document>()->ContextDocument());
}

int _XMLHttpRequestGetReadyState(XMLHttpRequestRef reference) {
  return static_cast<int>(reinterpret_cast<blink::XMLHttpRequest *>(reference)->readyState());
}

int _XMLHttpRequestGetStatus(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->status();
}

char* _XMLHttpRequestGetStatusTextString(XMLHttpRequestRef reference, int* len) {
  String status = reinterpret_cast<blink::XMLHttpRequest *>(reference)->statusText();
  *len = status.length();
  char* result = reinterpret_cast<char *>(malloc(status.length()));
  memcpy(result, status.Utf8().data(), status.length());
  return result;
}

int64_t _XMLHttpRequestGetTimeout(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->timeout();
}

void _XMLHttpRequestSetTimeout(XMLHttpRequestRef reference, int64_t value) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->setTimeout(value, exceptionState);
}

int _XMLHttpRequestHasPendingActivity(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->HasPendingActivity() ? 1 : 0;
}

char* _XMLHttpRequestGetUrl(XMLHttpRequestRef reference, int* len) {
  String url = reinterpret_cast<blink::XMLHttpRequest *>(reference)->Url().GetString();
  *len = url.length();
  char* result = reinterpret_cast<char *>(malloc(url.length()));
  memcpy(result, url.Utf8().data(), url.length());
  return result;
}

int _XMLHttpRequestWithCredentials(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->withCredentials() ? 1 : 0;
}

void _XMLHttpRequestSetWithCredentials(XMLHttpRequestRef reference, int value) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->setWithCredentials(value != 0, exceptionState);
}

char* _XMLHttpRequestGetResponseUrl(XMLHttpRequestRef reference, int* len) {
  String url = reinterpret_cast<blink::XMLHttpRequest *>(reference)->responseURL();
  *len = url.length();
  char* result = reinterpret_cast<char *>(malloc(url.length()));
  memcpy(result, url.Utf8().data(), url.length());
  return result;
}

char* _XMLHttpRequestGetResponseText(XMLHttpRequestRef reference, int* len) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::NonThrowableExceptionState exceptionState;
  v8::Local<v8::String> str = reinterpret_cast<blink::XMLHttpRequest *>(reference)->responseText(exceptionState);
  v8::String::Utf8Value str_value(isolate, str);
  char* result = reinterpret_cast<char *>(malloc(str_value.length()));
  memcpy(result, *str_value, str_value.length());
  
  *len = str_value.length();
  return result;
}

WebNodeRef _XMLHttpRequestGetResponseXML(XMLHttpRequestRef reference) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->responseXML(exceptionState);
}

BlobRef _XMLHttpRequestGetResponseBlob(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->ResponseBlob();
}

DOMArrayBufferRef _XMLHttpRequestGetResponseArrayBuffer(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->ResponseArrayBuffer();
}

int _XMLHttpRequestGetResponseType(XMLHttpRequestRef reference) {
  return static_cast<int>(reinterpret_cast<blink::XMLHttpRequest *>(reference)->GetResponseTypeCode());
}

void _XMLHttpRequestSetResponseType(XMLHttpRequestRef reference, int type) {
  blink::NonThrowableExceptionState exceptionState;
  String response_type(String::FromUTF8(XMLHttpRequestGetResponseTypeString(type)));
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->setResponseType(response_type, exceptionState);
}

int _XMLHttpRequestIsAsync(XMLHttpRequestRef reference) {
  return reinterpret_cast<blink::XMLHttpRequest *>(reference)->IsAsync();
}

void _XMLHttpRequestOpen(XMLHttpRequestRef reference, int method, const char* url) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kSetterContext,
                                       "XMLHttpRequest", "open");
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->open(
    AtomicString(XMLHttpRequestMethodToString(method)), 
    String::FromUTF8(url),
    exceptionState);
}

void _XMLHttpRequestOpenWithAsync(XMLHttpRequestRef reference, int method, const char* url, int async) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kSetterContext,
                                        "XMLHttpRequest", "open");
  blink::KURL kurl(String::FromUTF8(url));
  AtomicString method_string(XMLHttpRequestMethodToString(method));
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->open(
    method_string, 
    kurl,
    async != 0,
    exceptionState);
}

void _XMLHttpRequestOpenWithUsername(XMLHttpRequestRef reference, int method, const char* url, int async, const char* username, const char* password) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kSetterContext,
                                       "XMLHttpRequest", "open");
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->open(
    AtomicString(XMLHttpRequestMethodToString(method)), 
    String::FromUTF8(url),
    async != 0,
    String::FromUTF8(username),
    String::FromUTF8(password),
    exceptionState);
}

void _XMLHttpRequestSend(XMLHttpRequestRef reference) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kSetterContext,
                                       "XMLHttpRequest", "send");
  blink::ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormDataOrURLSearchParams params;
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->send(params, exceptionState);
}

void _XMLHttpRequestAbort(XMLHttpRequestRef reference) {
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->abort();
}

void _XMLHttpRequestSetRequestHeader(XMLHttpRequestRef reference, const char* name, const char* value) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->setRequestHeader(AtomicString(name), AtomicString(value), exceptionState);
}

void _XMLHttpRequestOverrideMimeType(XMLHttpRequestRef reference, const char* type) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::XMLHttpRequest *>(reference)->overrideMimeType(AtomicString(type), exceptionState);
}

char* _XMLHttpRequestGetAllResponseHeaders(XMLHttpRequestRef reference, int* len) {
  String url = reinterpret_cast<blink::XMLHttpRequest *>(reference)->getAllResponseHeaders();
  *len = url.length();
  char* result = reinterpret_cast<char *>(malloc(url.length()));
  memcpy(result, url.Utf8().data(), url.length());
  return result;
}

char* _XMLHttpRequestGetResponseHeader(XMLHttpRequestRef reference, const char* name, int* len) {
  const AtomicString& url = reinterpret_cast<blink::XMLHttpRequest *>(reference)->getResponseHeader(AtomicString(name));
  *len = url.length();
  char* result = reinterpret_cast<char *>(malloc(url.length()));
  memcpy(result, url.Utf8().data(), url.length());
  return result;
}

void _XMLHttpRequestSetOnReadyStateChangeCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnreadystatechange(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnTimeoutCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOntimeout(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnProgressCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, int, uint64_t, uint64_t)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnprogress(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnAbortCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnabort(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnErrorCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnerror(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnLoadCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnload(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnLoadStartCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnload(new XMLHttpRequestEventListener(state, cb));
}

void _XMLHttpRequestSetOnLoadEndCallback(XMLHttpRequestRef reference, void* state, void(*cb)(void*, void*, void*)) {
  blink::XMLHttpRequest* xhr = reinterpret_cast<blink::XMLHttpRequest *>(reference);
  xhr->setOnloadend(new XMLHttpRequestEventListener(state, cb));
}

DOMArrayBufferRef _DOMArrayBufferCreate(unsigned numElements, unsigned elementByteSize) {
  return blink::DOMArrayBuffer::Create(numElements, elementByteSize);
}

DOMArrayBufferRef _DOMArrayBufferCreateWithBuffer(const void* source, unsigned byteLength) {
  return blink::DOMArrayBuffer::Create(source, byteLength);
}

void* _DOMArrayBufferGetData(DOMArrayBufferRef reference) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->Data();
}

unsigned _DOMArrayBufferGetByteLength(DOMArrayBufferRef reference) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->ByteLength();
}

int _DOMArrayBufferIsNeutered(DOMArrayBufferRef reference) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->IsNeutered() ? 1 : 0;
}

int _DOMArrayBufferIsShared(DOMArrayBufferRef reference) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->IsShared() ? 1 : 0;
}

DOMArrayBufferRef _DOMArrayBufferSlice(DOMArrayBufferRef reference, int begin, int end) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->Slice(begin, end);
}

DOMArrayBufferRef _DOMArrayBufferSliceBegin(DOMArrayBufferRef reference, int begin) {
  return reinterpret_cast<blink::DOMArrayBuffer*>(reference)->Slice(begin);
}

int _DOMArrayBufferViewGetType(DOMArrayBufferViewRef reference) {
  return reinterpret_cast<blink::DOMArrayBufferView*>(reference)->GetType();
}

DOMArrayBufferRef _DOMArrayBufferViewGetBuffer(DOMArrayBufferViewRef reference) {
  blink::DOMArrayBuffer* buffer = reinterpret_cast<blink::DOMArrayBufferView*>(reference)->buffer();
  return buffer;
}

unsigned _DOMArrayBufferViewGetByteLenght(DOMArrayBufferViewRef reference) {
  return reinterpret_cast<blink::DOMArrayBufferView*>(reference)->byteLength();
}

unsigned _DOMArrayBufferViewGetByteOffset(DOMArrayBufferViewRef reference) {
  return reinterpret_cast<blink::DOMArrayBufferView*>(reference)->byteOffset();
}

DOMArrayBufferViewRef _Float32ArrayCreateWithSize(unsigned size) {
  return blink::DOMFloat32Array::Create(size);
}

DOMArrayBufferViewRef _Float32ArrayCreateWithData(const float* data, unsigned size) {
  return blink::DOMFloat32Array::Create(data, size);
}

DOMArrayBufferViewRef _Float32ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMFloat32Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Float64ArrayCreateWithSize(unsigned size) {
  return blink::DOMFloat64Array::Create(size);
}

DOMArrayBufferViewRef _Float64ArrayCreateWithData(const double* data, unsigned size) {
  return blink::DOMFloat64Array::Create(data, size);
}

DOMArrayBufferViewRef _Float64ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMFloat64Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Int8ArrayCreateWithSize(unsigned size) {
  return blink::DOMInt8Array::Create(size); 
}

DOMArrayBufferViewRef _Int8ArrayCreateWithData(const int8_t* data, unsigned size) {
  return blink::DOMInt8Array::Create(data, size);
}

DOMArrayBufferViewRef _Int8ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMInt8Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Int16ArrayCreateWithSize(unsigned size) {
  return blink::DOMInt16Array::Create(size);
}

DOMArrayBufferViewRef _Int16ArrayCreateWithData(const int16_t* data, unsigned size) {
  return blink::DOMInt16Array::Create(data, size);
}

DOMArrayBufferViewRef _Int16ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMInt16Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Int32ArrayCreateWithSize(unsigned size) {
  return blink::DOMInt32Array::Create(size); 
}

DOMArrayBufferViewRef _Int32ArrayCreateWithData(const int32_t* data, unsigned size) {
  return blink::DOMInt32Array::Create(data, size);
}

DOMArrayBufferViewRef _Int32ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMInt8Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Uint8ArrayCreateWithSize(unsigned size) {
  return blink::DOMUint8Array::Create(size);
}

DOMArrayBufferViewRef _Uint8ArrayCreateWithData(const uint8_t* data, unsigned size) {
  return blink::DOMUint8Array::Create(data, size);
}

DOMArrayBufferViewRef _Uint8ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMUint8Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length); 
}

DOMArrayBufferViewRef _Uint8ClampedArrayCreateWithSize(unsigned size) {
  return blink::DOMUint8ClampedArray::Create(size);
}

DOMArrayBufferViewRef _Uint8ClampedArrayCreateWithData(const uint8_t* data, unsigned size) {
  return blink::DOMUint8ClampedArray::Create(data, size);
}

DOMArrayBufferViewRef _Uint8ClampedArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMUint8ClampedArray::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Uint16ArrayCreateWithSize(unsigned size) {
  return blink::DOMUint16Array::Create(size);  
}

DOMArrayBufferViewRef _Uint16ArrayCreateWithData(const uint16_t* data, unsigned size) {
  return blink::DOMUint16Array::Create(data, size);
}

DOMArrayBufferViewRef _Uint16ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMUint16Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

DOMArrayBufferViewRef _Uint32ArrayCreateWithSize(unsigned size) {
  return blink::DOMUint32Array::Create(size);
}

DOMArrayBufferViewRef _Uint32ArrayCreateWithData(const uint32_t* data, unsigned size) {
  return blink::DOMUint32Array::Create(data, size);
}

DOMArrayBufferViewRef _Uint32ArrayCreateWithBuffer(DOMArrayBufferRef reference, unsigned byte_offset, unsigned length) {
  return blink::DOMUint32Array::Create(reinterpret_cast<blink::DOMArrayBuffer*>(reference), byte_offset, length);
}

class BlobDataHandleWrapper {
public:
  BlobDataHandleWrapper(scoped_refptr<blink::BlobDataHandle> data):
   handle_(std::move(data)) {}

  ~BlobDataHandleWrapper() {}

  blink::BlobDataHandle* ptr() const {
    return handle_.get();
  }

  const scoped_refptr<blink::BlobDataHandle>& ref() const {
    return handle_;
  }

  scoped_refptr<blink::BlobDataHandle> own() {
    return std::move(handle_);
  }

private:
 scoped_refptr<blink::BlobDataHandle> handle_;

 DISALLOW_COPY_AND_ASSIGN(BlobDataHandleWrapper);
};

class BlobDataWrapper {
public:
  BlobDataWrapper(std::unique_ptr<blink::BlobData> data):
   handle_(std::move(data)) {}

  ~BlobDataWrapper() {}

  blink::BlobData* ptr() const {
    return handle_.get();
  }

  std::unique_ptr<blink::BlobData> own() {
    return std::move(handle_);
  }

private:

 std::unique_ptr<blink::BlobData> handle_;

 DISALLOW_COPY_AND_ASSIGN(BlobDataWrapper);
};

BlobDataRef _BlobDataCreateEmpty() {
  std::unique_ptr<blink::BlobData> data = blink::BlobData::Create();
  return new BlobDataWrapper(std::move(data));
}

BlobDataRef _BlobDataCreateForFile(const char* path) {
  std::unique_ptr<blink::BlobData> data = blink::BlobData::CreateForFileWithUnknownSize(String::FromUTF8(path));
  return new BlobDataWrapper(std::move(data));
}

void _BlobDataDestroy(BlobDataRef handle) {
  delete reinterpret_cast<BlobDataWrapper *>(handle);
}

char* _BlobDataGetContentType(BlobDataRef handle, int* len) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  const String& content_type = data->ContentType();
  *len = content_type.length();
  char* result = reinterpret_cast<char *>(malloc(content_type.length()));
  memcpy(result, content_type.Utf8().data(), content_type.length());
  return result;
}

void _BlobDataSetContentType(BlobDataRef handle, const char* content_type) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  data->SetContentType(String::FromUTF8(content_type));
}

void _BlobDataAppendBytes(BlobDataRef handle, const void* data, size_t length) {
  blink::BlobData* blob_data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  blob_data->AppendBytes(data, length);
}

void _BlobDataAppendFile(
  BlobDataRef handle,
  const char* path,
  long long offset,
  long long length,
  double expected_modification_time) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  data->AppendFile(String::FromUTF8(path),
                   offset,
                   length,
                   expected_modification_time);
}

void _BlobDataAppendBlobData(
  BlobDataRef handle,
  BlobDataRef blob_data,
  long long offset,
  long long length) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  BlobDataWrapper* data_wrapper = reinterpret_cast<BlobDataWrapper *>(blob_data);
  data->AppendBlob(
    blink::BlobDataHandle::Create(data_wrapper->own(), length),
    offset,
    length);
}

void _BlobDataAppendBlobDataHandle(
  BlobDataRef handle,
  BlobDataHandleRef blob_data,
  long long offset,
  long long length) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  BlobDataHandleWrapper* data_wrapper = reinterpret_cast<BlobDataHandleWrapper *>(blob_data);
  data->AppendBlob(
    data_wrapper->own(),
    offset,
    length);
}

void _BlobDataAppendFileSystemURL(
  BlobDataRef handle,
  const char* url,
  long long offset,
  long long length,
  double expected_modification_time) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  data->AppendFileSystemURL(blink::KURL(String::FromUTF8(url)),
                            offset,
                            length,
                            expected_modification_time);
}

void _BlobDataAppendText(
  BlobDataRef handle,
  const char* text, 
  int normalize_line_endings_to_native) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  data->AppendText(
    String::FromUTF8(text), 
    normalize_line_endings_to_native != 0);

}

uint64_t _BlobDataGetLength(BlobDataRef handle) {
  blink::BlobData* data = reinterpret_cast<BlobDataWrapper *>(handle)->ptr();
  return data->length();
}

BlobDataHandleRef _BlobDataHandleCreateEmpty() {
  return new BlobDataHandleWrapper(blink::BlobDataHandle::Create());
}

BlobDataHandleRef _BlobDataHandleCreateUUID(const char* uuid, const char* type, long long size) {
  return new BlobDataHandleWrapper(blink::BlobDataHandle::Create(
    String::FromUTF8(uuid),
    String::FromUTF8(type), 
    size));
}

BlobDataHandleRef _BlobDataHandleCreateData(BlobDataRef buffer, long long size) {
  BlobDataWrapper* data_buffer = reinterpret_cast<BlobDataWrapper *>(buffer);
  return new BlobDataHandleWrapper(blink::BlobDataHandle::Create(data_buffer->own(), size));
}

void _BlobDataHandleDestroy(BlobDataHandleRef handle) {
  delete reinterpret_cast<BlobDataHandleWrapper *>(handle);
}

BlobRef _BlobCreateEmpty() {
  return blink::Blob::Create(blink::BlobDataHandle::Create());
}

BlobRef _BlobCreateBytes(const unsigned char* data, unsigned bytes, const char* content_type) {
  return blink::Blob::Create(data, bytes, String::FromUTF8(content_type));
}

BlobRef _BlobCreateDataHandle(BlobDataHandleRef data) {
  BlobDataHandleWrapper* data_wrapper = reinterpret_cast<BlobDataHandleWrapper *>(data);
  return blink::Blob::Create(data_wrapper->own());
}

BlobRef _BlobCreateData(BlobDataRef buf, long long size) {
  BlobDataWrapper* data = reinterpret_cast<BlobDataWrapper *>(buf);
  return blink::Blob::Create(blink::BlobDataHandle::Create(data->own(), size));
}

char* _DOMUrlCreateObjectURLForBlob(BlobRef blob, int* len) {
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  DCHECK(script_state);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  String str = blink::DOMURL::CreatePublicURL(execution_context, reinterpret_cast<blink::Blob *>(blob));
  //String str = blink::URLFileAPI::createObjectURL(script_state, reinterpret_cast<blink::Blob *>(blob), exceptionState);
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

char* _DOMUrlCreateObjectURLForBlobWithContext(WebNodeRef document_handle, BlobRef blob, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(document_handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::NonThrowableExceptionState exceptionState;
  //blink::ExecutionContext* execution_context = reinterpret_cast<blink::ExecutionContext *>(context);
  blink::UseCounter::Count(document, blink::WebFeature::kCreateObjectURLBlob);
  String str = blink::DOMURL::CreatePublicURL(document, reinterpret_cast<blink::Blob *>(blob));
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

char* _DOMUrlCreateObjectURLForSourceWithContext(WebNodeRef document_handle, MediaSourceRef source, int* len) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(document_handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  blink::NonThrowableExceptionState exceptionState;
  //blink::ExecutionContext* execution_context = reinterpret_cast<blink::ExecutionContext *>(context);
  //blink::UseCounter::Count(document, blink::WebFeature::kCreateObjectURLBlob);
  String str = blink::DOMURL::CreatePublicURL(document, reinterpret_cast<blink::MediaSource *>(source));
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

WebRangeRef _WebRangeCreateWithDocument(WebNodeRef document_handle) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(document_handle);
  blink::Document* document = ref->unwrap<blink::Document>();
  return new WebRangeWrapper(blink::Range::Create(*document));
}

WebRangeRef _WebRangeCreate(
  WebNodeRef document, 
  WebNodeRef startContainer,
  uint16_t startOffset,
  WebNodeRef endContainer,
  uint16_t endOffset) {
  
  WebNodeWrapper* document_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* start_container_ref = reinterpret_cast<WebNodeWrapper *>(startContainer);
  WebNodeWrapper* end_container_ref = reinterpret_cast<WebNodeWrapper *>(endContainer);
  blink::Range* range = blink::Range::Create(
    *document_ref->unwrap<blink::Document>(),
    start_container_ref->unwrap<blink::Node>(),
    startOffset,
    end_container_ref->unwrap<blink::Node>(),
    endOffset);
  return new WebRangeWrapper(range);
}

void _WebRangeDestroy(WebRangeRef handle) {
  delete reinterpret_cast<WebRangeWrapper *>(handle);
}

WebNodeRef _WebRangeGetStartContainer(WebRangeRef handle) {
  blink::Node* start = reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->startContainer();
  return start ? new WebNodeWrapper(start) : nullptr;
}

WebNodeRef _WebRangeGetEndContainer(WebRangeRef handle) {
  blink::Node* end = reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->endContainer();
  return end ? new WebNodeWrapper(end) : nullptr;
}

uint64_t _WebRangeGetStartOffset(WebRangeRef handle) {
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->startOffset();
}

uint64_t _WebRangeGetEndOffset(WebRangeRef handle) {
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->endOffset();
}

int _WebRangeIsCollapsed(WebRangeRef handle) {
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->collapsed() ? 1 : 0;
}

WebNodeRef _WebRangeGetCommonAncestorContainer(WebRangeRef handle) {
  blink::Node* ancestor = reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->commonAncestorContainer();
  return ancestor ? new WebNodeWrapper(ancestor) : nullptr;
}

void _WebRangeGetClientRects(WebRangeRef handle, int** x, int** y, int** w, int** h, int* count) {
  Vector<blink::FloatQuad> quads;
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->GetBorderAndTextQuads(quads);
  *count = quads.size(); 
  *x = reinterpret_cast<int*>(malloc(sizeof(int) * quads.size()));
  *y = reinterpret_cast<int*>(malloc(sizeof(int) * quads.size()));
  *w = reinterpret_cast<int*>(malloc(sizeof(int) * quads.size()));
  *h = reinterpret_cast<int*>(malloc(sizeof(int) * quads.size()));
  for (size_t i = 0; i > quads.size(); i++) {
    blink::FloatRect rect = quads[i].BoundingBox();
    *x[i] = rect.X();
    *y[i] = rect.Y();
    *w[i] = rect.Width();
    *h[i] = rect.Height(); 
  }
}

void _WebRangeGetBoundingClientRect(WebRangeRef handle, int* x, int* y, int* w, int* h) {
  blink::IntRect rect = reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->BoundingBox();
  *x = rect.X();
  *y = rect.Y();
  *w = rect.Width();
  *h = rect.Height();
}

void _WebRangeSetStart(WebRangeRef handle, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setStart(node_ref->unwrap<blink::Node>(), offset, exceptionState);
}

void _WebRangeSetEnd(WebRangeRef handle, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setEnd(node_ref->unwrap<blink::Node>(), offset, exceptionState);
}

void _WebRangeSetStartBefore(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setStartBefore(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeSetStartAfter(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setStartAfter(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeSetEndBefore(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setEndBefore(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeSetEndAfter(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->setEndAfter(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeCollapse(WebRangeRef handle, int toStart) {
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->collapse(toStart != 0);
}

void _WebRangeSelectNode(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->selectNode(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeSelectNodeContents(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->selectNodeContents(node_ref->unwrap<blink::Node>(), exceptionState);
}

int16_t _WebRangeCompareBoundaryPoints(WebRangeRef handle, uint16_t how, WebRangeRef sourceRange) {
  blink::NonThrowableExceptionState exceptionState;
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->compareBoundaryPoints(how, reinterpret_cast<WebRangeWrapper *>(sourceRange)->unwrap(), exceptionState);
}

void _WebRangeDeleteContents(WebRangeRef handle) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->deleteContents(exceptionState);
}

WebNodeRef _WebRangeExtractContents(WebRangeRef handle) {
  blink::NonThrowableExceptionState exceptionState;
  return new WebNodeWrapper(reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->extractContents(exceptionState));
}

WebNodeRef _WebRangeCloneContents(WebRangeRef handle) {
  blink::NonThrowableExceptionState exceptionState;
  return new WebNodeWrapper(reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->cloneContents(exceptionState));
}

void _WebRangeInsertNode(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->insertNode(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebRangeSurroundContents(WebRangeRef handle, WebNodeRef newParent) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(newParent);
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->surroundContents(node_ref->unwrap<blink::Node>(), exceptionState);
}

WebRangeRef _WebRangeCloneRange(WebRangeRef handle) {
  return new WebRangeWrapper(reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->cloneRange());
}

void _WebRangeDetach(WebRangeRef handle) {
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->detach();
}

int _WebRangeIsPointInRange(WebRangeRef handle, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->isPointInRange(node_ref->unwrap<blink::Node>(), offset, exceptionState) ? 1 : 0;
}

int16_t _WebRangeComparePoint(WebRangeRef handle, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->comparePoint(node_ref->unwrap<blink::Node>(), offset, exceptionState);
}

int _WebRangeIntersectsNode(WebRangeRef handle, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  return reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->intersectsNode(node_ref->unwrap<blink::Node>(), exceptionState) ? 1 : 0;
}

WebNodeRef _WebRangeCreateContextualFragment(WebRangeRef handle, const char* fragment) {
  blink::NonThrowableExceptionState exceptionState;
  return new WebNodeWrapper(reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->createContextualFragment(String::FromUTF8(fragment), exceptionState));
}

void _WebRangeExpand(WebRangeRef handle, const char* unit) {
  blink::NonThrowableExceptionState exceptionState;
  String unit_str = unit ? String::FromUTF8(unit) : String();
  reinterpret_cast<WebRangeWrapper *>(handle)->unwrap()->expand(unit_str, exceptionState); 
}

// WebFrameSelection
int _WebFrameSelectionGetLayoutSelectionStart(WebFrameSelectionRef reference, unsigned* result) {
  base::Optional<unsigned> start = reinterpret_cast<blink::FrameSelection *>(reference)->LayoutSelectionStart();
  if (start) { 
    *result = *start;
    return 1;
  }
  return 0;
}

int _WebFrameSelectionGetLayoutSelectionEnd(WebFrameSelectionRef reference, unsigned* result) { 
  base::Optional<unsigned> end = reinterpret_cast<blink::FrameSelection *>(reference)->LayoutSelectionEnd();
  if (end) { 
    *result = *end;
    return 1;
  }
  return 0;
}

int _WebFrameSelectionGetIsAvailable(WebFrameSelectionRef reference) { 
  return reinterpret_cast<blink::FrameSelection *>(reference)->IsAvailable() ? 1 : 0;
}

WebNodeRef _WebFrameSelectionGetDocument(WebFrameSelectionRef reference) { 
  return new WebNodeWrapper(&reinterpret_cast<blink::FrameSelection *>(reference)->GetDocument());
}

WebFrameRef _WebFrameSelectionGetLocalFrame(WebFrameSelectionRef reference) {
  blink::WebFrame* frame = blink::WebFrame::FromFrame(reinterpret_cast<blink::FrameSelection *>(reference)->GetFrame());
  return frame->ToWebLocalFrame();
}

WebNodeRef _WebFrameSelectionGetRootEditableElementOrDocumentElement(WebFrameSelectionRef reference) { 
  return new WebNodeWrapper(reinterpret_cast<blink::FrameSelection *>(reference)->RootEditableElementOrDocumentElement());
}

int _WebFrameSelectionNeedsLayoutSelectionUpdate(WebFrameSelectionRef reference) { 
  return reinterpret_cast<blink::FrameSelection *>(reference)->NeedsLayoutSelectionUpdate() ? 1 : 0;
}

void _WebFrameSelectionGetAbsoluteCaretBounds(WebFrameSelectionRef reference, int* x, int* y, int* w, int* h) {
  blink::IntRect bounds = reinterpret_cast<blink::FrameSelection *>(reference)->AbsoluteCaretBounds();
  *x = bounds.X();
  *y = bounds.Y();
  *w = bounds.Width();
  *h = bounds.Height();
}

int _WebFrameSelectionGetGranularity(WebFrameSelectionRef reference) {
  return static_cast<int>(reinterpret_cast<blink::FrameSelection *>(reference)->Granularity());
}

WebSelectionRef _WebFrameSelectionGetSelection(WebFrameSelectionRef reference) {
  blink::FrameSelection* sel = reinterpret_cast<blink::FrameSelection *>(reference);
  return blink::DOMSelection::Create(&sel->GetDocument());
}

int _WebFrameSelectionGetIsDirectional(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->IsDirectional() ? 1 : 0;
}

int _WebFrameSelectionGetSelectionHasFocus(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->SelectionHasFocus() ? 1: 0;
}

int _WebFrameSelectionGetFrameIsFocused(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->FrameIsFocused() ? 1 : 0;
}

void _WebFrameSelectionSetFrameIsFocused(WebFrameSelectionRef reference, int focused) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetFrameIsFocused(focused != 0);
}

int _WebFrameSelectionGetFrameIsFocusedAndActive(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->FrameIsFocusedAndActive() ? 1 : 0;
}

WebRangeRef _WebFrameSelectionGetDocumentCachedRange(WebFrameSelectionRef reference) {
  return new WebRangeWrapper(reinterpret_cast<blink::FrameSelection *>(reference)->DocumentCachedRange());
}

int _WebFrameSelectionGetIsHidden(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->IsHidden() ? 1 : 0;
}

int _WebFrameSelectionGetIsHandleVisible(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->IsHandleVisible() ? 1 : 0;
}

int _WebFrameSelectionGetShouldShrinkNextTap(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->ShouldShrinkNextTap() ? 1 : 0;
}

int _WebFrameSelectionGetShouldShowBlockCursor(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->ShouldShowBlockCursor() ? 1 : 0;
}

void _WebFrameSelectionSetShouldShowBlockCursor(WebFrameSelectionRef reference, int show) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetShouldShowBlockCursor(show != 0);
}

int _WebFrameSelectionGetIsCaretBlinkingSuspended(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->IsCaretBlinkingSuspended() ? 1 : 0;
}

void _WebFrameSelectionSetIsCaretBlinkingSuspended(WebFrameSelectionRef reference, int suspended) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetCaretBlinkingSuspended(suspended != 0);
}

char* _WebFrameSelectionGetSelectedHTMLForClipboard(WebFrameSelectionRef reference, int* len) {
  String str = reinterpret_cast<blink::FrameSelection *>(reference)->SelectedHTMLForClipboard();
  if (str.IsEmpty()) {
    return nullptr;
  }
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

char* _WebFrameSelectionGetSelectedText(WebFrameSelectionRef reference, int* len) {
  String str = reinterpret_cast<blink::FrameSelection *>(reference)->SelectedText();
  if (str.IsEmpty()) {
    return nullptr;
  }
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

char* _WebFrameSelectionGetSelectedTextForClipboard(WebFrameSelectionRef reference, int* len) {
  String str = reinterpret_cast<blink::FrameSelection *>(reference)->SelectedTextForClipboard();
  if (str.IsEmpty()) {
    return nullptr;
  }
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

void _WebFrameSelectionGetAbsoluteUnclippedBounds(WebFrameSelectionRef reference, int* x, int* y, int* w, int* h) {
  blink::LayoutRect bounds = reinterpret_cast<blink::FrameSelection *>(reference)->AbsoluteUnclippedBounds();
  *x = bounds.X().ToInt();
  *y = bounds.Y().ToInt();
  *w = bounds.Width().ToInt();
  *h = bounds.Height().ToInt();
}

int _WebFrameSelectionGetCharacterIndexForPoint(WebFrameSelectionRef reference, int x, int y) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->CharacterIndexForPoint(blink::IntPoint(x, y));
}

void _WebFrameSelectionMoveCaretSelection(WebFrameSelectionRef reference, int x, int y) {
  blink::IntPoint pt(x, y); 
  reinterpret_cast<blink::FrameSelection *>(reference)->MoveCaretSelection(pt);
}

void _WebFrameSelectionSetSelection(WebFrameSelectionRef reference, 
    WebSelectionRef selection,
    int cursorAlignOnScroll,
    int doNotClearStrategy,
    int doNotSetFocus,
    int granularity,
    int setSelectionBy,
    int shouldClearTypingStyle,
    int shouldCloseTyping,
    int shouldShowHandle,
    int shouldShrinkNextTap,
    int isDirectional) {
  blink::SetSelectionOptions options;
  options = blink::SetSelectionOptions::Builder(options).
    SetCursorAlignOnScroll(static_cast<blink::CursorAlignOnScroll>(cursorAlignOnScroll)).
    SetDoNotClearStrategy(doNotClearStrategy != 0).
    SetDoNotSetFocus(doNotSetFocus != 0).
    SetGranularity(static_cast<blink::TextGranularity>(granularity)).
    SetSetSelectionBy(static_cast<blink::SetSelectionBy>(setSelectionBy)).
    SetShouldClearTypingStyle(shouldClearTypingStyle != 0).
    SetShouldCloseTyping(shouldClearTypingStyle != 0).
    SetShouldShowHandle(shouldShowHandle != 0).
    SetShouldShrinkNextTap(shouldShrinkNextTap != 0).
    SetIsDirectional(isDirectional != 0).Build();

  blink::DOMSelection* dom_selection = reinterpret_cast<blink::DOMSelection *>(selection);
  blink::Position base_position(dom_selection->baseNode(), dom_selection->baseOffset());
  blink::Position extent_position(dom_selection->extentNode(), dom_selection->extentOffset());
  blink::SelectionInDOMTree sel = blink::SelectionInDOMTree::Builder()
          .SetBaseAndExtentDeprecated(base_position, extent_position)
          .Build();
  reinterpret_cast<blink::FrameSelection *>(reference)->SetSelection(
    sel,
    options);
}

void _WebFrameSelectionSetSelectionAndEndTyping(WebFrameSelectionRef reference, WebSelectionRef selection) {
  blink::DOMSelection* dom_selection = reinterpret_cast<blink::DOMSelection *>(selection);
  blink::Position base_position(dom_selection->baseNode(), dom_selection->baseOffset());
  blink::Position extent_position(dom_selection->extentNode(), dom_selection->extentOffset());
  blink::SelectionInDOMTree sel = blink::SelectionInDOMTree::Builder()
          .SetBaseAndExtentDeprecated(base_position, extent_position)
          .Build();
  reinterpret_cast<blink::FrameSelection *>(reference)->SetSelectionAndEndTyping(sel);
}

void _WebFrameSelectionSelectAllBy(WebFrameSelectionRef reference, int by) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SelectAll(static_cast<blink::SetSelectionBy>(by));
}

void _WebFrameSelectionSelectAll(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SelectAll();
}

void _WebFrameSelectionSelectSubString(WebFrameSelectionRef reference, WebNodeRef element, int offset, int count) {
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(element); 
  reinterpret_cast<blink::FrameSelection *>(reference)->SelectSubString(*node_ref->unwrap<blink::Element>(), offset, count);
}

void _WebFrameSelectionClear(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->Clear();
}

void _WebFrameSelectionSelectFrameElementInParentIfFullySelected(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SelectFrameElementInParentIfFullySelected();
}

int _WebFrameSelectionContains(WebFrameSelectionRef reference, int px, int py) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->Contains(blink::LayoutPoint(px, py)) ? 1 : 0;
}

int _WebFrameSelectionModify(WebFrameSelectionRef reference,
    int alteration,
    int direction,
    int granularity,
    int by) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->Modify(static_cast<blink::SelectionModifyAlteration>(alteration), static_cast<blink::SelectionModifyDirection>(direction), static_cast<blink::TextGranularity>(granularity), static_cast<blink::SetSelectionBy>(by));
}

void _WebFrameSelectionMoveRangeSelectionExtent(WebFrameSelectionRef reference, int px, int py) {
  blink::IntPoint p(px, py);
  reinterpret_cast<blink::FrameSelection *>(reference)->MoveRangeSelectionExtent(p);
}

void _WebFrameSelectionMoveRangeSelection(WebFrameSelectionRef reference,
    int base_x, 
    int base_y,
    int extent_x, 
    int extent_y,
    int granularity) {
  blink::IntPoint bp(base_x, base_y);
  blink::IntPoint ep(extent_x, extent_y);    
  reinterpret_cast<blink::FrameSelection *>(reference)->MoveRangeSelection(bp, ep, static_cast<blink::TextGranularity>(granularity));
}

void _WebFrameSelectionCommitAppearanceIfNeeded(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->CommitAppearanceIfNeeded();
}

void _WebFrameSelectionSetCaretVisible(WebFrameSelectionRef reference, int visible) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetCaretVisible(visible != 0);
}

void _WebFrameSelectionPageActivationChanged(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->PageActivationChanged();
}

int _WebFrameSelectionSelectWordAroundCaret(WebFrameSelectionRef reference) {
  return reinterpret_cast<blink::FrameSelection *>(reference)->SelectWordAroundCaret() != 0;
}

void _WebFrameSelectionSetFocusedNodeIfNeeded(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetFocusedNodeIfNeeded();
}

void _WebFrameSelectionNotifyTextControlOfSelectionChange(WebFrameSelectionRef reference, int by) {
  reinterpret_cast<blink::FrameSelection *>(reference)->NotifyTextControlOfSelectionChange(static_cast<blink::SetSelectionBy>(by));
}

char* _WebFrameSelectionGetSelectedTextWithOptions(WebFrameSelectionRef reference, 
    int collapseTrailingSpace,
    int doesNotBreakAtReplacedElement,
    int emitsCharactersBetweenAllVisiblePositions,
    int emitsImageAltText,
    int emitsSpaceForNbsp,
    int emitsObjectReplacementcharacter,
    int emitsOriginalText,
    int emitsSmallXForTextSecurity,
    int entersOpenShadowRoots,
    int entersTextControls,
    int excludeAutofilledValue,
    int forInnerText,
    int forSelectionToString,
    int forWindowFind,
    int ignoresStyleVisibility,
    int stopsOnFormControls,
    int doesNotEmitSpaceBeyondRangeEnd,
    int skipsUnselectableContent,
    int suppressesNewlineEmission,
    int* len) {
  blink::TextIteratorBehavior behavior;
  blink::TextIteratorBehavior::Builder builder(behavior);

  behavior = builder.SetCollapseTrailingSpace(collapseTrailingSpace != 0).
    SetDoesNotBreakAtReplacedElement(doesNotBreakAtReplacedElement != 0).
    SetEmitsCharactersBetweenAllVisiblePositions(emitsCharactersBetweenAllVisiblePositions != 0).
    SetEmitsImageAltText(emitsImageAltText != 0).
    SetEmitsSpaceForNbsp(emitsSpaceForNbsp != 0).
    SetEmitsObjectReplacementCharacter(emitsObjectReplacementcharacter != 0).
    SetEmitsOriginalText(emitsOriginalText != 0).
    SetEmitsSmallXForTextSecurity(emitsSmallXForTextSecurity != 0).
    SetEntersOpenShadowRoots(entersOpenShadowRoots != 0).
    SetEntersTextControls(entersTextControls != 0).
    SetExcludeAutofilledValue(excludeAutofilledValue != 0).
    SetForInnerText(forInnerText != 0).
    SetForSelectionToString(forSelectionToString != 0).
    SetForWindowFind(forWindowFind != 0).
    SetIgnoresStyleVisibility(ignoresStyleVisibility != 0).
    SetStopsOnFormControls(stopsOnFormControls != 0).
    SetDoesNotEmitSpaceBeyondRangeEnd(doesNotEmitSpaceBeyondRangeEnd != 0).
    SetSkipsUnselectableContent(skipsUnselectableContent != 0).
    SetSuppressesExtraNewlineEmission(suppressesNewlineEmission != 0).
    Build();

  String str = reinterpret_cast<blink::FrameSelection *>(reference)->SelectedText(behavior);
  if (str.IsEmpty()) {
    return nullptr;
  }
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

void _WebFrameSelectionRevealSelection(WebFrameSelectionRef reference, int alignment, int revealExtent) {  
  reinterpret_cast<blink::FrameSelection *>(reference)->RevealSelection(GetScrollAligment(alignment), revealExtent == 0 ? blink::kRevealExtent : blink::kDoNotRevealExtent);
}

void _WebFrameSelectionSetSelectionFromNone(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->SetSelectionFromNone();
}

void _WebFrameSelectionUpdateAppearance(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->UpdateAppearance();
}

void _WebFrameSelectionCacheRangeOfDocument(WebFrameSelectionRef reference, WebRangeRef range) {
  reinterpret_cast<blink::FrameSelection *>(reference)->CacheRangeOfDocument(reinterpret_cast<WebRangeWrapper*>(range)->unwrap());
}

void _WebFrameSelectionClearDocumentCachedRange(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->ClearDocumentCachedRange();
}

void _WebFrameSelectionClearLayoutSelection(WebFrameSelectionRef reference) {
  reinterpret_cast<blink::FrameSelection *>(reference)->ClearLayoutSelection();
}

WebFrameCaretRef _WebFrameSelectionGetFrameCaret(WebFrameSelectionRef reference) {
  blink::FrameCaret& caret = reinterpret_cast<blink::FrameSelection *>(reference)->FrameCaretForTesting();
  return &caret;
}

int _WebFrameCaretGetIsActive(WebFrameCaretRef reference) {
  return reinterpret_cast<blink::FrameCaret*>(reference)->IsActive() ? 1 : 0;
}

int _WebFrameCaretGetIsCaretBlinkingSuspended(WebFrameCaretRef reference) {
  return reinterpret_cast<blink::FrameCaret*>(reference)->IsCaretBlinkingSuspended() ? 1 : 0;
}

void _WebFrameCaretSetIsCaretBlinkingSuspended(WebFrameCaretRef reference, int suspended) {
  reinterpret_cast<blink::FrameCaret*>(reference)->SetCaretBlinkingSuspended(suspended != 0);
}

void _WebFrameCaretGetAbsoluteCaretBounds(WebFrameCaretRef reference, int* x, int* y, int* w, int* h) {
  blink::IntRect bounds = reinterpret_cast<blink::FrameCaret*>(reference)->AbsoluteCaretBounds();
  *x = bounds.X();
  *y = bounds.Y();
  *w = bounds.Width();
  *h = bounds.Height();
}

int _WebFrameCaretGetShouldShowBlockCursor(WebFrameCaretRef reference) {
  return reinterpret_cast<blink::FrameCaret*>(reference)->ShouldShowBlockCursor() ? 1 : 0;
}

void _WebFrameCaretSetShouldShowBlockCursor(WebFrameCaretRef reference, int show) {
  reinterpret_cast<blink::FrameCaret*>(reference)->SetShouldShowBlockCursor(show != 0);
}

void _WebFrameCaretStopCaretBlinkTimer(WebFrameCaretRef reference) {
  reinterpret_cast<blink::FrameCaret*>(reference)->StopCaretBlinkTimer();
}

void _WebFrameCaretStartBlinkCaret(WebFrameCaretRef reference) {
  reinterpret_cast<blink::FrameCaret*>(reference)->StartBlinkCaret();
}

void _WebFrameCaretSetCaretVisibility(WebFrameCaretRef reference, int visibility) {
  reinterpret_cast<blink::FrameCaret*>(reference)->SetCaretVisibility(static_cast<blink::CaretVisibility>(visibility));
}

// WebSelection
WebNodeRef _WebSelectionGetAnchorNode(WebSelectionRef reference) {
  return new WebNodeWrapper(reinterpret_cast<blink::DOMSelection *>(reference)->anchorNode());
}

uint64_t _WebSelectionGetAnchorOffset(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->anchorOffset();
}

WebNodeRef _WebSelectionGetFocusNode(WebSelectionRef reference) {
  return new WebNodeWrapper(reinterpret_cast<blink::DOMSelection *>(reference)->focusNode());
}

uint64_t _WebSelectionGetFocusOffset(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->focusOffset();
}

WebNodeRef _WebSelectionGetBaseNode(WebSelectionRef reference) {
  return new WebNodeWrapper(reinterpret_cast<blink::DOMSelection *>(reference)->baseNode());
}

uint64_t _WebSelectionGetBaseOffset(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->baseOffset();
}

WebNodeRef _WebSelectionGetExtentNode(WebSelectionRef reference) {
  return new WebNodeWrapper(reinterpret_cast<blink::DOMSelection *>(reference)->extentNode());
}

uint64_t _WebSelectionGetExtentOffset(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->extentOffset();
}

int _WebSelectionGetRangeCount(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->rangeCount();
}

int _WebSelectionGetIsCollapsed(WebSelectionRef reference) {
  return reinterpret_cast<blink::DOMSelection *>(reference)->isCollapsed() ? 1 : 0;
}

char* _WebSelectionGetType(WebSelectionRef reference, int* len) {
  String str = reinterpret_cast<blink::DOMSelection *>(reference)->type();
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

WebRangeRef _WebSelectionGetRangeAt(WebSelectionRef reference, int index) {
  blink::NonThrowableExceptionState exceptionState;
  return new WebRangeWrapper(reinterpret_cast<blink::DOMSelection *>(reference)->getRangeAt(index, exceptionState));
}

void _WebSelectionAddRange(WebSelectionRef reference, WebRangeRef range) {
  reinterpret_cast<blink::DOMSelection *>(reference)->addRange(reinterpret_cast<WebRangeWrapper*>(range)->unwrap());
}

void _WebSelectionRemoveRange(WebSelectionRef reference, WebRangeRef range) {
  reinterpret_cast<blink::DOMSelection *>(reference)->removeRange(reinterpret_cast<WebRangeWrapper*>(range)->unwrap());
}

void _WebSelectionRemoveAllRanges(WebSelectionRef reference) {
  reinterpret_cast<blink::DOMSelection *>(reference)->removeAllRanges();
}

void _WebSelectionEmpty(WebSelectionRef reference) {
  reinterpret_cast<blink::DOMSelection *>(reference)->empty();
}

void _WebSelectionCollapse(WebSelectionRef reference, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<blink::DOMSelection *>(reference)->collapse(node_ref->unwrap<blink::Node>(), offset, exceptionState);
}

// void _WebSelectionSetPosition(WebSelectionRef reference, WebNodeRef node, uint64_t offset) {
//   WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
//   reinterpret_cast<blink::DOMSelection *>(reference)->setPosition(node_ref->unwrap<blink::Node>(), offset);
// }

void _WebSelectionCollapseToStart(WebSelectionRef reference) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::DOMSelection *>(reference)->collapseToStart(exceptionState);
}

void _WebSelectionCollapseToEnd(WebSelectionRef reference) {
  blink::NonThrowableExceptionState exceptionState;
  reinterpret_cast<blink::DOMSelection *>(reference)->collapseToEnd(exceptionState);
}

void _WebSelectionExtend(WebSelectionRef reference, WebNodeRef node, uint64_t offset) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<blink::DOMSelection *>(reference)->extend(node_ref->unwrap<blink::Node>(), offset, exceptionState);
}

void _WebSelectionSetBaseAndExtent(WebSelectionRef reference, 
    WebNodeRef baseNode, uint64_t baseOffset,
    WebNodeRef extentNode, uint64_t extentOffset) {
  WebNodeWrapper* bnode_ref = reinterpret_cast<WebNodeWrapper *>(baseNode);
  WebNodeWrapper* enode_ref = reinterpret_cast<WebNodeWrapper *>(extentNode);
  reinterpret_cast<blink::DOMSelection *>(reference)->setBaseAndExtent(bnode_ref->unwrap<blink::Node>(), baseOffset, enode_ref->unwrap<blink::Node>(), extentOffset);
}

void _WebSelectionSelectAllChildren(WebSelectionRef reference, WebNodeRef node) {
  blink::NonThrowableExceptionState exceptionState;
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  reinterpret_cast<blink::DOMSelection *>(reference)->selectAllChildren(node_ref->unwrap<blink::Node>(), exceptionState);
}

void _WebSelectionDeleteFromDocument(WebSelectionRef reference) {
  reinterpret_cast<blink::DOMSelection *>(reference)->deleteFromDocument();
}

int _WebSelectionContainsNode(WebSelectionRef reference, WebNodeRef node, int allowPartialContainment) {
  WebNodeWrapper* node_ref = reinterpret_cast<WebNodeWrapper *>(node);
  return reinterpret_cast<blink::DOMSelection *>(reference)->containsNode(node_ref->unwrap<blink::Node>(), allowPartialContainment != 0);
}

// WebInputMethodController

void _WebInputMethodControllerGetTextInputInfo(
  WebInputMethodControllerRef handle, 
  int* type,
  int* flags,
  char** value,
  int* value_len,
  int* sstart,
  int* send,
  int* cstart,
  int* cend,
  int* input_mode) {

  blink::WebTextInputInfo info = reinterpret_cast<blink::InputMethodController *>(handle)->TextInputInfo();
  
  *type = info.type;
  *flags = info.flags;
  *sstart = info.selection_start;
  *send = info.selection_end;
  *cstart = info.composition_start;
  *cend = info.composition_end;
  *input_mode = info.input_mode;
  String value_string = info.value;
  *value = (char *)malloc(value_string.length() * sizeof(char));
  memcpy(*value, value_string.Utf8().data(), value_string.length());
  *value_len = value_string.length();
}

int _WebInputMethodControllerComputeWebTextInputNextPreviousFlags(WebInputMethodControllerRef handle) {
  return reinterpret_cast<blink::InputMethodController *>(handle)->ComputeWebTextInputNextPreviousFlags();
}

int _WebInputMethodControllerGetTextInputType(WebInputMethodControllerRef handle) {
  return static_cast<int>(reinterpret_cast<blink::InputMethodController *>(handle)->TextInputType());
}

void _WebInputMethodControllerGetSelectionOffsets(WebInputMethodControllerRef handle, int* start, int* end) {
  blink::PlainTextRange range = reinterpret_cast<blink::InputMethodController *>(handle)->GetSelectionOffsets();
  *start = range.Start();
  *end = range.End();
}

// void _WebInputMethodControllerGetCompositionRange(WebInputMethodControllerRef handle, int* start, int* end) {
//   blink::WebRange range = reinterpret_cast<blink::InputMethodController *>(handle)->CompositionRange();
//   *start = range.StartOffset();
//   *end = range.EndOffset();
// }

// int _WebInputMethodControllerGetCompositionCharacterBounds(WebInputMethodControllerRef handle, int* count, int** x, int** y, int** w, int** h) {
//   blink::WebVector<blink::WebRect> bounds;
//   bool r = reinterpret_cast<blink::InputMethodController *>(handle)->GetCompositionCharacterBounds(bounds);
//   if (r) {
//     *count = bounds.size();
//     *x = (int*)malloc(bounds.size() * sizeof(int));
//     *y = (int*)malloc(bounds.size() * sizeof(int));
//     *w = (int*)malloc(bounds.size() * sizeof(int));
//     *h = (int*)malloc(bounds.size() * sizeof(int));
//     for (size_t i = 0; i < bounds.size(); i++) {
//       *x[i] = bounds[i].x;
//       *y[i] = bounds[i].y;
//       *w[i] = bounds[i].width;
//       *h[i] = bounds[i].height;
//     } 
//   }
//   return r ? 1 : 0;
// }

void _WebInputMethodControllerSetComposition(
  WebInputMethodControllerRef handle, 
  const char* text,
  int* span_type,
  int* span_start,
  int* span_end,
  int* span_ucolor,
  int* span_thick,
  int* span_bg,
  int span_count,
  int selection_start,
  int selection_end) {
  
  blink::WebVector<blink::WebImeTextSpan> ime_text_spans;
  
  for(int i = 0; i < span_count; i++) {
    ime_text_spans.emplace_back(blink::WebImeTextSpan(
      static_cast<blink::WebImeTextSpan::Type>(span_type[i]), 
      span_start[i], 
      span_end[i], 
      static_cast<ui::mojom::ImeTextSpanThickness>(span_thick[i]),
      blink::WebColor(span_bg[i]),
      blink::WebColor(span_ucolor[i])));  
  }
  reinterpret_cast<blink::InputMethodController *>(handle)->SetComposition(
    String::FromUTF8(text),
    blink::ImeTextSpanVectorBuilder::Build(ime_text_spans),
    selection_start,
    selection_end
  );
}

int _WebInputMethodControllerCommitText(
  WebInputMethodControllerRef handle, 
  const char* text,
  int* span_type,
  int* span_start,
  int* span_end,
  int* span_ucolor,
  int* span_thick,
  int* span_bg,
  int span_count,
  int caret_position) {
  blink::WebVector<blink::WebImeTextSpan> ime_text_spans;
  
  for(int i = 0; i < span_count; i++) {
    ime_text_spans.emplace_back(blink::WebImeTextSpan(
      static_cast<blink::WebImeTextSpan::Type>(span_type[i]), 
      span_start[i], 
      span_end[i], 
      static_cast<ui::mojom::ImeTextSpanThickness>(span_thick[i]),
      blink::WebColor(span_bg[i]),
      blink::WebColor(span_ucolor[i])));  
  }
  return reinterpret_cast<blink::InputMethodController *>(handle)->CommitText(
    String::FromUTF8(text),
    blink::ImeTextSpanVectorBuilder::Build(ime_text_spans),
    caret_position
  ) ? 1 : 0;
}

int _WebInputMethodControllerFinishComposingText(WebInputMethodControllerRef handle, int selection_behavior) {
  return reinterpret_cast<blink::InputMethodController *>(handle)->FinishComposingText(static_cast<blink::InputMethodController::ConfirmCompositionBehavior>(selection_behavior)) ? 1 : 0;
}

void _WebInputMethodControllerDeleteSurroundingText(WebInputMethodControllerRef handle, int before, int after) {
  reinterpret_cast<blink::InputMethodController *>(handle)->DeleteSurroundingText(before, after);
}

void _WebInputMethodControllerDeleteSurroundingTextInCodePoints(WebInputMethodControllerRef handle, int before, int after) {
  reinterpret_cast<blink::InputMethodController *>(handle)->DeleteSurroundingTextInCodePoints(before, after);
}

int _WebInputMethodControllerHasComposition(WebInputMethodControllerRef handle) {
  return reinterpret_cast<blink::InputMethodController *>(handle)->HasComposition() ? 1 : 0;
}

void _WebInputMethodControllerSetCompositionFromExistingText(
  WebInputMethodControllerRef handle, 
  int* span_type,
  int* span_start,
  int* span_end,
  int* span_ucolor,
  int* span_thick,
  int* span_bg,
  int span_count,
  int composition_start,
  int composition_end) {
  blink::WebVector<blink::WebImeTextSpan> ime_text_spans;
  
  for(int i = 0; i < span_count; i++) {
    ime_text_spans.emplace_back(blink::WebImeTextSpan(
      static_cast<blink::WebImeTextSpan::Type>(span_type[i]), 
      span_start[i], 
      span_end[i], 
      static_cast<ui::mojom::ImeTextSpanThickness>(span_thick[i]),
      blink::WebColor(span_bg[i]),
      blink::WebColor(span_ucolor[i])));  
  }
  reinterpret_cast<blink::InputMethodController *>(handle)->SetCompositionFromExistingText(
    blink::ImeTextSpanVectorBuilder::Build(ime_text_spans),
    composition_start,
    composition_end);
}

void _WebInputMethodControllerCancelComposition(WebInputMethodControllerRef handle) {
  reinterpret_cast<blink::InputMethodController *>(handle)->CancelComposition();
}

WebRangeRef _WebInputMethodControllerGetCompositionEphemeralRange(WebInputMethodControllerRef handle, WebFrameRef frame) {
  blink::EphemeralRange range = reinterpret_cast<blink::InputMethodController *>(handle)->CompositionEphemeralRange();
  blink::WebLocalFrameImpl* frame_impl = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::LocalFrame* local_frame = frame_impl->GetFrame();
  return new WebRangeWrapper(blink::Range::Create(*local_frame->GetDocument(), range.StartPosition(), range.EndPosition()));
}

int _WebInputMethodControllerSetEditableSelectionOffsets(WebInputMethodControllerRef handle, int start, int end) {
  blink::PlainTextRange range(start, end);
  return reinterpret_cast<blink::InputMethodController *>(handle)->SetEditableSelectionOffsets(range) ? 1 : 0;
}

void _WebInputMethodControllerExtendSelectionAndDelete(WebInputMethodControllerRef handle, int before, int after) {
  reinterpret_cast<blink::InputMethodController *>(handle)->ExtendSelectionAndDelete(before, after);
}

void _WebInputMethodControllerCreateRangeForSelection(WebInputMethodControllerRef handle, int start, int end, int length, int* start_out, int* end_out) {
  blink::PlainTextRange range = reinterpret_cast<blink::InputMethodController *>(handle)->CreateRangeForSelection(start, end, length);
  *start_out = range.Start();
  *end_out = range.End();
}

int _WebInputMethodControllerReplaceText(WebInputMethodControllerRef handle, const char* text, int start, int end) {
  blink::PlainTextRange range(start, end);
  String text_string = String::FromUTF8(text);
  return reinterpret_cast<blink::InputMethodController *>(handle)->ReplaceText(text_string, range) ? 1 : 0;
}

void _WebTextRangeCreateFromNodeAndRange(WebNodeRef node, int rstart, int rend, int* start, int* end) {
  blink::Element* element = reinterpret_cast<blink::Element *>(node);
  blink::PlainTextRange in_range(rstart, rend);
  blink::EphemeralRange range = in_range.CreateRange(element->GetDocument());
  blink::PlainTextRange out_range = blink::PlainTextRange::Create(*element, range);
  *start = out_range.Start();
  *end = out_range.End();
}

void WebAutofillClientDidCompleteFocusChangeInFrame(WebAutofillClientRef handle) {
  reinterpret_cast<blink::WebAutofillClient *>(handle)->DidCompleteFocusChangeInFrame();
}

int _WebEditorCanEdit(WebEditorRef handle) {
  return reinterpret_cast<blink::Editor *>(handle)->CanEdit() ? 1 : 0;
}

void _WebEditorHandleKeyboardEvent(WebEditorRef handle, WebFrameRef frame, WebInputEventRef event) {
  blink::Editor* editor = reinterpret_cast<blink::Editor *>(handle);
  blink::WebLocalFrameImpl* frame_impl = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::LocalFrame* local_frame = frame_impl->GetFrame();
  blink::WebKeyboardEvent* input = reinterpret_cast<blink::WebKeyboardEvent *>(event);
  blink::KeyboardEvent* key_event = blink::KeyboardEvent::Create(*input, local_frame->GetDocument()->domWindow());
  editor->HandleKeyboardEvent(key_event);
}

WebEventRef _WebEventCreateEmpty() {
  return blink::Event::Create();
}

WebEventRef _WebEventCreate(const char* type, int bubbles, int cancelable) {
  
  if (!bubbles && !cancelable) {
   return blink::Event::Create(AtomicString::FromUTF8(type));
  } 
  
  if (bubbles && !cancelable) {
   return blink::Event::CreateBubble(AtomicString::FromUTF8(type));
  }
  
  if (cancelable && !bubbles) {
   return blink::Event::CreateCancelable(AtomicString::FromUTF8(type));
  }

  return blink::Event::CreateCancelableBubble(AtomicString::FromUTF8(type));
}

char* _WebEventGetType(WebEventRef reference, int* len) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  AtomicString type = event->type();
  char* result = (char*)malloc(type.length());
  memcpy(result, type.Utf8().data(), type.length());
  *len = type.length();
  return result;
}

WebNodeRef _WebEventGetTarget(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  blink::EventTarget* target = event->target();
  blink::Node* node = target ? target->ToNode() : nullptr;
  if (!node) {
    //DLOG(INFO) << "WebEvent.target getter: warning found target but its not a DOM node. corner case. fix this";
    return nullptr;
  }
  return new WebNodeWrapper(node);
}

WebNodeRef _WebEventGetCurrentTarget(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  blink::EventTarget* target = event->currentTarget();
  blink::Node* node = target ? target->ToNode() : nullptr;
  if (!node) {
    //DLOG(INFO) << "WebEvent.currentTarget getter: warning found target but its not a DOM node. corner case. fix this";
    return nullptr;
  }
  return new WebNodeWrapper(node);
}

WebNodeRef _WebEventGetSrcElement(WebEventRef reference) {
  return _WebEventGetTarget(reference);
}

int _WebEventGetEventPhase(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->eventPhase();
}

int _WebEventBubbles(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->bubbles() ? 1 : 0;
}

int _WebEventIsCancelable(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->cancelable() ? 1 : 0;
}

int _WebEventDefaultPrevented(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->defaultPrevented() ? 1 : 0;
}

int _WebEventIsComposed(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->composed() ? 1 : 0;
}

int _WebEventIsTrusted(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->isTrusted() ? 1 : 0;
}

int64_t _WebEventGetTimestamp(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->PlatformTimeStamp().ToInternalValue();
}

void _WebEventStopPropagation(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  event->stopPropagation(); 
}

void _WebEventStopImmediatePropagation(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  event->stopImmediatePropagation();
}

void _WebEventPreventDefault(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  event->preventDefault();
}

void _WebEventInitEvent(WebEventRef reference, const char* type, int bubbles, int cancelable) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  event->initEvent(AtomicString::FromUTF8(type), bubbles != 0, cancelable != 0);  
}

int _WebEventIsUIEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsUIEvent() ? 1 : 0;
}

int _WebEventIsMouseEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsMouseEvent() ? 1 : 0;
}

int _WebEventIsFocusEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsFocusEvent() ? 1 : 0;
}

int _WebEventIsKeyboardEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsKeyboardEvent() ? 1 : 0;
}

int _WebEventIsTouchEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsTouchEvent() ? 1 : 0;
}

int _WebEventIsGestureEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsGestureEvent() ? 1 : 0;
}

int _WebEventIsWheelEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsWheelEvent() ? 1 : 0;
}

int _WebEventIsRelatedEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsRelatedEvent() ? 1 : 0;
}

int _WebEventIsPointerEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsPointerEvent() ? 1 : 0;
}

int _WebEventIsInputEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsInputEvent() ? 1 : 0;
}

int _WebEventIsDragEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsDragEvent() ? 1 : 0;
}

int _WebEventIsClipboardEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsClipboardEvent() ? 1 : 0;
}

int _WebEventIsBeforeTextInsertedEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsBeforeTextInsertedEvent() ? 1 : 0;
}

int _WebEventIsBeforeUnloadEvent(WebEventRef reference) {
  blink::Event* event = reinterpret_cast<blink::Event *>(reference);
  return event->IsBeforeUnloadEvent() ? 1 : 0;
}

void _MediaControlsMaybeShow(MediaControlsRef handle) {
  blink::MediaControls* controls = reinterpret_cast<blink::MediaControls *>(handle);
  controls->MaybeShow();
}

void _MediaControlsHide(MediaControlsRef handle) {
  blink::MediaControls* controls = reinterpret_cast<blink::MediaControls *>(handle);
  controls->Hide();
}

void _MediaControlsReset(MediaControlsRef handle) {
  blink::MediaControls* controls = reinterpret_cast<blink::MediaControls *>(handle);
  controls->Reset();
}

WebMediaPlayerRef _WebMediaPlayerCreateURL(
  void* state,
  struct WebMediaPlayerDelegateCallbacks callbacks,
  WebFrameRef frame, 
  const char* url,
  void* client,
  void* enc_client,
  void* module,
  const char* sink_id,
  void* web_view_client) {
  //DLOG(INFO) << "_WebMediaPlayerCreateURL: sink_id = " << sink_id;

  application::ApplicationThread* thread = application::ApplicationThread::current();
  blink::WebLocalFrameImpl* local_frame = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::WebMediaPlayerEncryptedMediaClient* encClient = enc_client ? reinterpret_cast<blink::WebMediaPlayerEncryptedMediaClient*>(enc_client) : nullptr;
  blink::WebContentDecryptionModule* mod = module ? reinterpret_cast<blink::WebContentDecryptionModule*>(module) : nullptr; 
  blink::WebString sinkId = sink_id == nullptr ? blink::WebString() : blink::WebString::FromUTF8(sink_id);
  blink::WebMediaPlayerSource source(blink::KURL(WebString::FromUTF8(url)));

  WebViewClientImpl* view_client = reinterpret_cast<WebViewClientImpl*>(web_view_client);
  WebLayerTreeViewImpl* layer_tree_view = view_client->web_layer_tree_view();
  cc::LayerTreeSettings settings = layer_tree_view->GetLayerTreeSettings();
  blink::WebMediaPlayer* media_player = thread->CreateWebMediaPlayer(
  	state,
  	callbacks,
    local_frame,
    source,
    reinterpret_cast<blink::WebMediaPlayerClient *>(client),
    encClient,
    mod,
    std::move(sinkId),
    layer_tree_view,
    settings);

  return media_player;
}

WebMediaPlayerRef _WebMediaPlayerCreateMediaStreamDescriptor(
  void* state,
  struct WebMediaPlayerDelegateCallbacks callbacks,
  WebFrameRef frame, 
  WebMediaStreamDescriptorRef descriptor,
  void* client,
  void* enc_client,
  void* module,
  const char* sink_id,
  void* web_view_client) {
  //DLOG(INFO) << "_WebMediaPlayerCreateMediaStreamDescriptor: sink_id = " << sink_id;

  application::ApplicationThread* thread = application::ApplicationThread::current();
  blink::WebLocalFrameImpl* local_frame = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::WebMediaPlayerEncryptedMediaClient* encClient = enc_client ? reinterpret_cast<blink::WebMediaPlayerEncryptedMediaClient*>(enc_client) : nullptr;
  blink::WebContentDecryptionModule* mod = module ? reinterpret_cast<blink::WebContentDecryptionModule*>(module) : nullptr; 
  blink::WebString sinkId = sink_id == nullptr ? blink::WebString() : blink::WebString::FromUTF8(sink_id);
  
  WebViewClientImpl* view_client = reinterpret_cast<WebViewClientImpl*>(web_view_client);
  WebLayerTreeViewImpl* layer_tree_view = view_client->web_layer_tree_view();
  cc::LayerTreeSettings settings = layer_tree_view->GetLayerTreeSettings();

  blink::WebMediaStream stream(reinterpret_cast<blink::MediaStreamDescriptor*>(descriptor));
  blink::WebMediaPlayerSource player_source(stream);

  blink::WebMediaPlayer* media_player = thread->CreateWebMediaPlayer(
  	state,
  	callbacks,
    local_frame,
    player_source,
    reinterpret_cast<blink::WebMediaPlayerClient *>(client),
    encClient,
    mod,
    std::move(sinkId),
    layer_tree_view,
    settings);

  return media_player;
}

WebMediaPlayerRef _WebMediaPlayerCreateMediaStreamVideo(
  void* state,
  struct WebMediaPlayerDelegateCallbacks callbacks,
  WebFrameRef frame,
  const char* id,
  const char* name,
  int is_remote,
  void* client,
  void* enc_client,
  void* module,
  const char* sink_id,
  void* web_view_client) {
  //DLOG(INFO) << "_WebMediaPlayerCreateMediaStreamVideo: sink_id = " << sink_id;

  application::ApplicationThread* thread = application::ApplicationThread::current();
  blink::WebLocalFrameImpl* local_frame = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::WebMediaPlayerEncryptedMediaClient* encClient = enc_client ? reinterpret_cast<blink::WebMediaPlayerEncryptedMediaClient*>(enc_client) : nullptr;
  blink::WebContentDecryptionModule* mod = module ? reinterpret_cast<blink::WebContentDecryptionModule*>(module) : nullptr; 
  blink::WebString sinkId = sink_id == nullptr ? blink::WebString() : blink::WebString::FromUTF8(sink_id);
  
  blink::WebVector<blink::WebMediaStreamTrack> audio_tracks;
  blink::WebVector<blink::WebMediaStreamTrack> video_tracks;

  blink::WebMediaStreamSource source;
  source.Initialize(WebString::FromUTF8(id),
                    blink::WebMediaStreamSource::kTypeVideo,
                    WebString::FromUTF8(name),
                    is_remote == 0 ? false : true);

  blink::WebMediaStreamTrack video_track;
  video_track.Initialize(source);

  video_tracks.emplace_back(video_track);

  blink::WebMediaStream stream;
  stream.Initialize(audio_tracks, video_tracks);
  
  blink::WebMediaPlayerSource player_source(stream);

  WebViewClientImpl* view_client = reinterpret_cast<WebViewClientImpl*>(web_view_client);
  WebLayerTreeViewImpl* layer_tree_view = view_client->web_layer_tree_view();
  cc::LayerTreeSettings settings = layer_tree_view->GetLayerTreeSettings();
  blink::WebMediaPlayer* media_player = thread->CreateWebMediaPlayer(
  	state,
  	callbacks,
    local_frame,
    player_source,
    reinterpret_cast<blink::WebMediaPlayerClient *>(client),
    encClient,
    mod,
    std::move(sinkId),
    layer_tree_view,
    settings);

  return media_player;
}

WebMediaPlayerRef _WebMediaPlayerCreateMediaStreamAudio(
  void* state,
  struct WebMediaPlayerDelegateCallbacks callbacks,
  WebFrameRef frame,
  const char* id,
  const char* name,
  int is_remote,
  void* client,
  void* enc_client,
  void* module,
  const char* sink_id,
  void* web_view_client) {

  application::ApplicationThread* thread = application::ApplicationThread::current();
  blink::WebLocalFrameImpl* local_frame = reinterpret_cast<blink::WebLocalFrameImpl *>(frame);
  blink::WebMediaPlayerEncryptedMediaClient* encClient = enc_client ? reinterpret_cast<blink::WebMediaPlayerEncryptedMediaClient*>(enc_client) : nullptr;
  blink::WebContentDecryptionModule* mod = module ? reinterpret_cast<blink::WebContentDecryptionModule*>(module) : nullptr; 
  blink::WebString sinkId = sink_id == nullptr ? blink::WebString() : blink::WebString::FromUTF8(sink_id);
  
  blink::WebVector<blink::WebMediaStreamTrack> audio_tracks;
  blink::WebVector<blink::WebMediaStreamTrack> video_tracks;

  blink::WebMediaStreamSource source;
  source.Initialize(WebString::FromUTF8(id),
                    blink::WebMediaStreamSource::kTypeAudio,
                    WebString::FromUTF8(name),
                    is_remote == 0 ? false : true);
  
  blink::WebMediaStreamTrack audio_track;
  audio_track.Initialize(source);

  audio_tracks.emplace_back(audio_track);

  blink::WebMediaStream stream;
  stream.Initialize(audio_tracks, video_tracks);
  
  blink::WebMediaPlayerSource player_source(stream);

  WebViewClientImpl* view_client = reinterpret_cast<WebViewClientImpl*>(web_view_client);
  WebLayerTreeViewImpl* layer_tree_view = view_client->web_layer_tree_view();
  cc::LayerTreeSettings settings = layer_tree_view->GetLayerTreeSettings();
  blink::WebMediaPlayer* media_player = thread->CreateWebMediaPlayer(
  	state,
  	callbacks,
    local_frame,
    player_source,
    reinterpret_cast<blink::WebMediaPlayerClient *>(client),
    encClient,
    mod,
    std::move(sinkId),
    layer_tree_view,
    settings);

  return media_player;
}

void _WebMediaPlayerDestroy(WebMediaPlayerRef reference) {
  delete reinterpret_cast<blink::WebMediaPlayer *>(reference);
}

int _WebMediaPlayerHasVideo(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->HasVideo() ? 1 : 0;
}

int _WebMediaPlayerHasAudio(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->HasAudio() ? 1 : 0;
}

void _WebMediaPlayerGetNaturalSize(WebMediaPlayerRef reference, int* w, int* h) {
  auto rect = reinterpret_cast<blink::WebMediaPlayer *>(reference)->NaturalSize();
  *w = rect.width;
  *h = rect.height;
}

void _WebMediaPlayerGetVisibleRect(WebMediaPlayerRef reference, int* w, int* h) {
  auto rect = reinterpret_cast<blink::WebMediaPlayer *>(reference)->VisibleRect();
  *w = rect.width;
  *h = rect.height;
}

int _WebMediaPlayerIsPaused(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->Paused() ? 1 : 0;
}

int _WebMediaPlayerIsSeeking(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->Seeking() ? 1 : 0;
}

double _WebMediaPlayerGetDuration(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->Duration();
}

double _WebMediaPlayerGetTimelineOffset(WebMediaPlayerRef reference) {
  return reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->timelineOffset();
}

double _WebMediaPlayerGetCurrentTime(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->CurrentTime();
}

int _WebMediaPlayerGetNetworkState(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->GetNetworkState();
}

int _WebMediaPlayerGetRadyState(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->GetReadyState();
}

char* _WebMediaPlayerGetErrorMessage(WebMediaPlayerRef reference, int* len) {
  blink::WebString err = reinterpret_cast<blink::WebMediaPlayer *>(reference)->GetErrorMessage();
  char* result = (char*)malloc(err.length());
  memcpy(result, err.Utf8().data(), err.length());
  *len = err.length();
  return result;
}

uint32_t _WebMediaPlayerGetDecodedFrameCount(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->DecodedFrameCount();
}

uint32_t _WebMediaPlayerGetDroppedFrameCount(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->DroppedFrameCount();
}

uint32_t _WebMediaPlayerGetAudioDecodedByteCount(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->AudioDecodedByteCount();
}

uint32_t _WebMediaPlayerGetVideoDecodedByteCount(WebMediaPlayerRef reference) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->VideoDecodedByteCount();
}

void _WebMediaPlayerGetBuffered(WebMediaPlayerRef reference, int* len, double** start, double** end) {
  blink::WebMediaPlayer* media_player = reinterpret_cast<blink::WebMediaPlayer *>(reference);
  blink::WebTimeRanges ranges = media_player->Buffered();
  *len = ranges.size();
  if (ranges.size() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges.size()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges.size()));
  for (unsigned i = 0; i < ranges.size(); i++) {
    *start[i] = ranges[i].start;
    *end[i] = ranges[i].end;
  }
}

void _WebMediaPlayerGetSeekable(WebMediaPlayerRef reference, int* len, double** start, double** end) {
  blink::WebMediaPlayer* media_player = reinterpret_cast<blink::WebMediaPlayer *>(reference);
  blink::WebTimeRanges ranges = media_player->Seekable();
  *len = ranges.size();
  if (ranges.size() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges.size()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges.size()));
  for (unsigned i = 0; i < ranges.size(); i++) {
    *start[i] = ranges[i].start;
    *end[i] = ranges[i].end;
  }
}

void _WebMediaPlayerLoadWithURL(WebMediaPlayerRef reference, int load_type, const char* url, int cors_mode) {
  blink::KURL local_url(blink::WebString::FromUTF8(url));
  blink::WebMediaPlayerSource url_source(local_url);
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->Load(
    static_cast<blink::WebMediaPlayer::LoadType>(load_type),
    url_source,
    static_cast<blink::WebMediaPlayer::CORSMode>(cors_mode));
}

void _WebMediaPlayerPlay(WebMediaPlayerRef reference) {
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->Play();
}

void _WebMediaPlayerPause(WebMediaPlayerRef reference) {
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->Pause();
}

void _WebMediaPlayerSeek(WebMediaPlayerRef reference, double seconds) {
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->Seek(seconds);
}

void _WebMediaPlayerSetRate(WebMediaPlayerRef reference, double rate) {
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->SetRate(rate);
}

void _WebMediaPlayerSetVolume(WebMediaPlayerRef reference, double volume) {
  reinterpret_cast<blink::WebMediaPlayer *>(reference)->SetVolume(volume);
}

double _WebMediaPlayerGetMediaTimeForTimeValue(WebMediaPlayerRef reference, double time_value) {
  return reinterpret_cast<blink::WebMediaPlayer *>(reference)->MediaTimeForTimeValue(time_value);
}

void _WebMediaPlayerOnFrameHidden(WebMediaPlayerRef reference) {
  reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnFrameHidden();	
}

void _WebMediaPlayerOnFrameClosed(WebMediaPlayerRef reference) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnFrameClosed();
}

void _WebMediaPlayerOnFrameShown(WebMediaPlayerRef reference) {
  reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnFrameShown();
}

void _WebMediaPlayerOnIdleTimeout(WebMediaPlayerRef reference) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnIdleTimeout();
}

void _WebMediaPlayerOnPlay(WebMediaPlayerRef reference) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnPlay();
}

void _WebMediaPlayerOnPause(WebMediaPlayerRef reference) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnPause();
}

void _WebMediaPlayerOnSeekForward(WebMediaPlayerRef reference, double seconds) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnSeekForward(seconds);
}

void _WebMediaPlayerOnSeekBackward(WebMediaPlayerRef reference, double seconds) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnSeekBackward(seconds);
}

void _WebMediaPlayerOnVolumeMultiplierUpdate(WebMediaPlayerRef reference, double multiplier) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnVolumeMultiplierUpdate(multiplier);
}

void _WebMediaPlayerOnBecamePersistentVideo(WebMediaPlayerRef reference, int value) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnBecamePersistentVideo(value != 0);
}

void _WebMediaPlayerOnPictureInPictureModeEnded(WebMediaPlayerRef reference) {
	reinterpret_cast<media::WebMediaPlayerImpl *>(reference)->OnPictureInPictureModeEnded();
}

void _WebNetworkStateNotifierSetOnline(int online) {
	blink::WebNetworkStateNotifier::SetOnLine(online != 0);
}

void _WebNetworkStateNotifierSetWebConnection(int connection_type, double max_bandwidth_mbps) {
	blink::WebNetworkStateNotifier::SetWebConnection(static_cast<blink::WebConnectionType>(connection_type), max_bandwidth_mbps);
}

void _WebNetworkStateNotifierSetNetworkQuality(int connection_type, int64_t http_rtt, int64_t transport_rtt, int downlink_throughput_kbps) {
	blink::WebNetworkStateNotifier::SetNetworkQuality(
      static_cast<blink::WebEffectiveConnectionType>(connection_type),
      base::TimeDelta::FromInternalValue(http_rtt),
      base::TimeDelta::FromInternalValue(transport_rtt),
      downlink_throughput_kbps);
}

void _WebNetworkStateNotifierSetSaveDataEnabled(int enabled) {
	blink::WebNetworkStateNotifier::SetSaveDataEnabled(enabled != 0);
}

/*
 * WebMediaStreamDescriptor
 */

WebMediaStreamDescriptorRef _WebMediaStreamDescriptorCreate() {
  blink::MediaStreamComponentVector audio_components;
  blink::MediaStreamComponentVector video_components;
  return blink::MediaStreamDescriptor::Create(audio_components, video_components);
}

char* _WebMediaStreamDescriptorGetId(WebMediaStreamDescriptorRef reference, int* len) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  
  String string = descriptor->Id();
  if (string.IsEmpty()) {
    return nullptr;
  }
  *len = string.length();
  char* result = reinterpret_cast<char *>(malloc(string.length()));
  memcpy(result, string.Utf8().data(), string.length());
  return result;
}

int _WebMediaStreamDescriptorGetUniqueId(WebMediaStreamDescriptorRef reference) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  return descriptor->UniqueId();
}

void _WebMediaStreamDescriptorGetAudioTracks(WebMediaStreamDescriptorRef reference, WebMediaStreamComponentRef** tracks, int* len) {  
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  *tracks = reinterpret_cast<WebMediaStreamComponentRef*>(malloc(sizeof(blink::MediaStreamComponent) * descriptor->NumberOfAudioComponents()));
  *len = descriptor->NumberOfAudioComponents();
  for (unsigned i = 0; i < descriptor->NumberOfAudioComponents(); i++) {
    *tracks[i] = descriptor->AudioComponent(i);
  }
}

void _WebMediaStreamDescriptorGetVideoTracks(WebMediaStreamDescriptorRef reference, WebMediaStreamComponentRef** tracks, int* len) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  *tracks = reinterpret_cast<WebMediaStreamComponentRef*>(malloc(sizeof(blink::MediaStreamComponent) * descriptor->NumberOfVideoComponents()));
  *len = descriptor->NumberOfVideoComponents();
  for (unsigned i = 0; i < descriptor->NumberOfVideoComponents(); i++) {
    *tracks[i] = descriptor->VideoComponent(i);
  }
}

int _WebMediaStreamDescriptorGetAudioTrackCount(WebMediaStreamDescriptorRef reference) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  return descriptor->NumberOfAudioComponents();
}

int _WebMediaStreamDescriptorGetVideoTrackCount(WebMediaStreamDescriptorRef reference) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  return descriptor->NumberOfVideoComponents();
}

WebMediaStreamComponentRef _WebMediaStreamDescriptorGetAudioTrack(WebMediaStreamDescriptorRef reference, int index) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  blink::MediaStreamComponent* track = descriptor->AudioComponent(index);
  return track;
}

WebMediaStreamComponentRef _WebMediaStreamDescriptorGetVideoTrack(WebMediaStreamDescriptorRef reference, int index) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  blink::MediaStreamComponent* track = descriptor->VideoComponent(index);
  return track;
}

WebMediaStreamComponentRef _WebMediaStreamDescriptorGetAudioTrackById(WebMediaStreamDescriptorRef reference, const char* id) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  blink::MediaStreamComponent* track = nullptr;
  String id_str = String::FromUTF8(id);
  for (unsigned i = 0; i < descriptor->NumberOfAudioComponents(); i++) {
    blink::MediaStreamComponent* cur = descriptor->AudioComponent(i);
    if (cur->Id() == id_str) {
      track = cur;
      break;
    }
  }
  return track;
}

WebMediaStreamComponentRef _WebMediaStreamDescriptorGetVideoTrackById(WebMediaStreamDescriptorRef reference, const char* id) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  blink::MediaStreamComponent* track = nullptr;
  String id_str = String::FromUTF8(id);
  for (unsigned i = 0; i < descriptor->NumberOfVideoComponents(); i++) {
    blink::MediaStreamComponent* cur = descriptor->VideoComponent(i);
    if (cur->Id() == id_str) {
      track = cur;
      break;
    }
  }
  return track;
}

void _WebMediaStreamDescriptorAddTrack(WebMediaStreamDescriptorRef reference, WebMediaStreamComponentRef track) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  descriptor->AddComponent(reinterpret_cast<blink::MediaStreamComponent*>(track));
}

void _WebMediaStreamDescriptorRemoveTrack(WebMediaStreamDescriptorRef reference, WebMediaStreamComponentRef track) {
  blink::MediaStreamDescriptor* descriptor = static_cast<blink::MediaStreamDescriptor*>(reference);
  descriptor->RemoveComponent(reinterpret_cast<blink::MediaStreamComponent*>(track));
}

/* WebMediaStreamComponent */

void _WebMediaStreamComponentGetSource(WebMediaStreamComponentRef reference,
  char** id,
  int* id_len,
  int* type,
  char** name,
  int* name_len,
  int* remote,
  int* ready_state) {
  blink::MediaStreamComponent* track = reinterpret_cast<blink::MediaStreamComponent*>(reference);
  blink::MediaStreamSource* source = track->Source();
  
  const String& id_str = source->Id();
  const String& name_str = source->GetName();
  
  *id_len = 0;
  *name_len = 0;
  if (!id_str.IsEmpty()) {
    *id_len = id_str.length();
    *id = reinterpret_cast<char *>(malloc(id_str.length()));
    memcpy(*id, id_str.Utf8().data(), id_str.length());  
  }
  if (!name_str.IsEmpty()) {
    *name_len = name_str.length();
    *name = reinterpret_cast<char *>(malloc(name_str.length()));
    memcpy(*name, name_str.Utf8().data(), name_str.length());  
  }

  *type = static_cast<int>(source->GetType());
  *remote = source->Remote() ? 1 : 0;
  *ready_state = static_cast<int>(source->GetReadyState());
}

int _WebMediaStreamComponentIsEnabled(WebMediaStreamComponentRef reference) {
  blink::MediaStreamComponent* track = reinterpret_cast<blink::MediaStreamComponent*>(reference);
  return track->Enabled() ? 1 : 0;
}

int _WebMediaStreamComponentIsMuted(WebMediaStreamComponentRef reference) {
  blink::MediaStreamComponent* track = reinterpret_cast<blink::MediaStreamComponent*>(reference);
  return track->Muted() ? 1 : 0;
}

int _MediaSourceIsTypeSupported(const char* type) {
  return blink::MediaSource::isTypeSupported(String::FromUTF8(type)) ? 1 : 0;
}

MediaSourceRef _MediaSourceCreate(WebNodeRef document) {
  WebNodeWrapper* document_ref = reinterpret_cast<WebNodeWrapper *>(document);
  return blink::MediaSource::Create(document_ref->unwrap<blink::Document>()->ContextDocument());
}

double _MediaSourceGetDuration(MediaSourceRef handle) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  return source->duration();
}

SourceBufferRef _MediaSourceAddSourceBuffer(MediaSourceRef handle, const char* type) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::ExceptionState exceptionState(isolate, 
    blink::ExceptionState::kExecutionContext,
    "MediaSource", "addSourceBuffer");
  blink::SourceBuffer* buffer = source->addSourceBuffer(String::FromUTF8(type), exceptionState);
  if (exceptionState.HadException()) {
    //DLOG(INFO) << "Exception thrown\n code: " << exceptionState.Code() << 
    //"\n message: " << exceptionState.Message();
  }
  return buffer;
}

void _MediaSourceRemoveSourceBuffer(MediaSourceRef handle, SourceBufferRef buffer) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  source->removeSourceBuffer(reinterpret_cast<blink::SourceBuffer*>(buffer), exceptionState);
}

char* _MediaSourceGetReadyState(MediaSourceRef handle, int* len) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  const AtomicString& state = source->readyState();
  *len = state.length();
  char* result = reinterpret_cast<char *>(malloc(state.length()));
  memcpy(result, state.Utf8().data(), state.length());
  return result;
}

void _MediaSourceEndOfStream(MediaSourceRef handle, const char* error) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::ExceptionState exceptionState(isolate, 
    blink::ExceptionState::kExecutionContext,
    "MediaSource", "endOfStream");
  if (error != nullptr) {
    source->endOfStream(AtomicString::FromUTF8(error), exceptionState);
  } else {
    source->endOfStream(exceptionState);
  }
  if (exceptionState.HadException()) {
    //DLOG(INFO) << "Exception thrown\n code: " << exceptionState.Code() << 
    //"\n message: " << exceptionState.Message();
  }
}

void _MediaSourceSetLiveSeekableRange(MediaSourceRef handle, double start, double end) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  source->setLiveSeekableRange(start, end, exceptionState);  
}

void _MediaSourceClearLiveSeekableRange(MediaSourceRef handle) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  source->clearLiveSeekableRange(exceptionState);
}

void _MediaSourceOnSourceOpen(MediaSourceRef handle, void* state, void(*cb)(void*, void*)) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  source->setOnsourceopen(listener);
}

void _MediaSourceOnSourceEnded(MediaSourceRef handle, void* state, void(*cb)(void*, void*)) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  source->setOnsourceended(listener);
}

void _MediaSourceOnSourceClose(MediaSourceRef handle, void* state, void(*cb)(void*, void*)) {
  blink::MediaSource* source = reinterpret_cast<blink::MediaSource*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  source->setOnsourceclose(listener);
}

// SourceBuffer

char* _SourceBufferGetMode(SourceBufferRef handle, int* len) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  const AtomicString& mode = buffer->mode();
  *len = mode.length();
  char* result = reinterpret_cast<char *>(malloc(mode.length()));
  memcpy(result, mode.Utf8().data(), mode.length());
  return result;
}

int _SourceBufferIsUpdating(SourceBufferRef handle) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  return buffer->updating() ? 1 : 0;
}

void _SourceBufferGetBuffered(SourceBufferRef handle, int* len, double** start, double** end) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  blink::TimeRanges* ranges = buffer->buffered(exceptionState);
  if (!ranges) {
    *len = 0;
    return;
  }
  *len = ranges->length();
  if (ranges->length() == 0) {
    return;
  }
  *start = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));
  *end = reinterpret_cast<double*>(malloc(sizeof(double) * ranges->length()));

  for (unsigned i = 0; i < ranges->length(); i++) {
    *start[i] = ranges->start(i, exceptionState);
    *end[i] = ranges->end(i, exceptionState);
  }
}

double _SourceBufferGetTimestampOffset(SourceBufferRef handle) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  return buffer->timestampOffset();
}

double _SourceBufferAppendWindowStart(SourceBufferRef handle) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  return buffer->appendWindowStart();
}

double _SourceBufferAppendWindowEnd(SourceBufferRef handle) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  return buffer->appendWindowEnd();
}

void _SourceBufferAppendBuffer(SourceBufferRef handle, DOMArrayBufferRef data) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  buffer->appendBuffer(reinterpret_cast<blink::DOMArrayBuffer*>(data), exceptionState);
}

void _SourceBufferAbort(SourceBufferRef handle) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  buffer->abort(exceptionState);
}

void _SourceBufferRemove(SourceBufferRef handle, double start, double end) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  buffer->remove(start, end, exceptionState);
}

void _SourceBufferOnUpdateStart(SourceBufferRef handle, void* state, void(*cb)(void*, void*)) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  buffer->setOnupdatestart(listener);
}

void _SourceBufferOnUpdate(SourceBufferRef handle, void* state, void(*cb)(void*, void*)) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  buffer->setOnupdate(listener);
}

void _SourceBufferOnUpdateEnd(SourceBufferRef handle, void* state, void(*cb)(void*, void*)) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  buffer->setOnupdateend(listener);
}

void _SourceBufferOnError(SourceBufferRef handle, void* state, void(*cb)(void*, void*)) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  buffer->setOnerror(listener);
}

void _SourceBufferOnAbort(SourceBufferRef handle, void* state, void(*cb)(void*, void*)) {
  blink::SourceBuffer* buffer = reinterpret_cast<blink::SourceBuffer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, cb);
  buffer->setOnabort(listener);
}

void WebGLRenderingContextGetContextAttributes(WebGLRenderingContextRef handle, int* a, int* b) {
  DCHECK(false);
}

GLenum WebGLRenderingContextGetError(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getError();
}

int WebGLRenderingContextIsContextLost(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isContextLost();
}

void WebGLRenderingContextActiveTexture(WebGLRenderingContextRef handle, GLenum texture) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->activeTexture(texture);
}

void WebGLRenderingContextAttachShader(WebGLRenderingContextRef handle, WebGLProgramRef program, WebGLShaderRef shader) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->attachShader(reinterpret_cast<blink::WebGLProgram*>(program), reinterpret_cast<blink::WebGLShader*>(shader));
}

void WebGLRenderingContextBindAttribLocation(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint index, const char* name) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bindAttribLocation(reinterpret_cast<blink::WebGLProgram*>(program), index, name);
}

void WebGLRenderingContextBindBuffer(WebGLRenderingContextRef handle, GLenum target, WebGLBufferRef buffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bindBuffer(target, buffer ? reinterpret_cast<blink::WebGLBuffer*>(buffer) : nullptr);
}

void WebGLRenderingContextBindFramebuffer(WebGLRenderingContextRef handle, GLenum target, WebGLFramebufferRef framebuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bindFramebuffer(target, reinterpret_cast<blink::WebGLFramebuffer*>(framebuffer));
}

void WebGLRenderingContextBindRenderbuffer(WebGLRenderingContextRef handle, GLenum target, WebGLRenderbufferRef renderbuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bindRenderbuffer(target, reinterpret_cast<blink::WebGLRenderbuffer*>(renderbuffer));
}

void WebGLRenderingContextBindTexture(WebGLRenderingContextRef handle, GLenum target, WebGLTextureRef texture) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bindTexture(target, reinterpret_cast<blink::WebGLTexture*>(texture));
}

void WebGLRenderingContextBlendColor(WebGLRenderingContextRef handle, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->blendColor(red, green, blue, alpha);
}

void WebGLRenderingContextBlendEquation(WebGLRenderingContextRef handle, GLenum mode) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->blendEquation(mode);
}

void WebGLRenderingContextBlendEquationSeparate(WebGLRenderingContextRef handle, GLenum modeRGB, GLenum modeAlpha) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->blendEquationSeparate(modeRGB, modeAlpha);
}

void WebGLRenderingContextBlendFunc(WebGLRenderingContextRef handle, GLenum sfactor, GLenum dfactor) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->blendFunc(sfactor, dfactor);
}

void WebGLRenderingContextBlendFuncSeparate(WebGLRenderingContextRef handle, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void WebGLRenderingContextBufferData0(WebGLRenderingContextRef handle, GLenum target, GLsizeiptr size, GLenum usage) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bufferData(target, size, usage);
}

void WebGLRenderingContextBufferData1(WebGLRenderingContextRef handle, GLenum target, DOMArrayBufferViewRef data, GLenum usage) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl_context->bufferData(target, ref, usage);
}

void WebGLRenderingContextBufferData2(WebGLRenderingContextRef handle, GLenum target, DOMArrayBufferRef data, GLenum usage) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bufferData(target, reinterpret_cast<blink::DOMArrayBuffer *>(data), usage);
}

void WebGLRenderingContextBufferSubData0(WebGLRenderingContextRef handle, GLenum target, GLintptr offset, DOMArrayBufferViewRef data) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleArrayBufferView view_ref;
  view_ref.SetFull(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl_context->bufferSubData(target, offset, view_ref);
}

void WebGLRenderingContextBufferSubData1(WebGLRenderingContextRef handle, GLenum target, GLintptr offset, DOMArrayBufferRef data) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->bufferSubData(target, offset, reinterpret_cast<blink::DOMArrayBuffer *>(data));
}

GLenum WebGLRenderingContextCheckFramebufferStatus(WebGLRenderingContextRef handle, GLenum target) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->checkFramebufferStatus(target);
}

void WebGLRenderingContextClear(WebGLRenderingContextRef handle, GLbitfield mask) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->clear(mask);
}

void WebGLRenderingContextClearColor(WebGLRenderingContextRef handle, GLclampf r, GLclampf g, GLclampf b, GLclampf a) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->clearColor(r, g, b, a);
}

void WebGLRenderingContextClearDepth(WebGLRenderingContextRef handle, GLclampf depth) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->clearDepth(depth);
}

void WebGLRenderingContextClearStencil(WebGLRenderingContextRef handle, GLint s) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->clearStencil(s);
}

void WebGLRenderingContextColorMask(WebGLRenderingContextRef handle, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->colorMask(r, g, b, a);
}

void WebGLRenderingContextCompileShader(WebGLRenderingContextRef handle, WebGLShaderRef shader) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->compileShader(reinterpret_cast<blink::WebGLShader*>(shader));
}

void WebGLRenderingContextCompressedTexImage2D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, DOMArrayBufferViewRef data) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  //blink::NonThrowableExceptionState exceptionState;
  //v8::Isolate* isolate = v8::Isolate::GetCurrent();
  //blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  //DCHECK(script_state);
  //blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->compressedTexImage2D(target, level, internalformat, width, height, border, data_ref);
}

void WebGLRenderingContextCompressedTexSubImage2D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, DOMArrayBufferViewRef data) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl_context->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data_ref);
}

void WebGLRenderingContextCopyTexImage2D(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->copyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

void WebGLRenderingContextCopyTexSubImage2D(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

WebGLBufferRef WebGLRenderingContextCreateBuffer(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createBuffer();
}

WebGLFramebufferRef WebGLRenderingContextCreateFramebuffer(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createFramebuffer();
}

WebGLProgramRef WebGLRenderingContextCreateProgram(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createProgram();
}

WebGLRenderbufferRef WebGLRenderingContextCreateRenderbuffer(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createRenderbuffer();
}

WebGLShaderRef WebGLRenderingContextCreateShader(WebGLRenderingContextRef handle, GLenum type) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createShader(type);
}

WebGLTextureRef WebGLRenderingContextCreateTexture(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->createTexture();
}

void WebGLRenderingContextCullFace(WebGLRenderingContextRef handle, GLenum mode) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->cullFace(mode);
}

void WebGLRenderingContextDeleteBuffer(WebGLRenderingContextRef handle, WebGLBufferRef buffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteBuffer(reinterpret_cast<blink::WebGLBuffer*>(buffer));
}

void WebGLRenderingContextDeleteFramebuffer(WebGLRenderingContextRef handle, WebGLFramebufferRef framebuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteFramebuffer(reinterpret_cast<blink::WebGLFramebuffer*>(framebuffer));
}

void WebGLRenderingContextDeleteProgram(WebGLRenderingContextRef handle, WebGLProgramRef program) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteProgram(reinterpret_cast<blink::WebGLProgram*>(program));
}

void WebGLRenderingContextDeleteRenderbuffer(WebGLRenderingContextRef handle, WebGLRenderbufferRef renderbuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteRenderbuffer(reinterpret_cast<blink::WebGLRenderbuffer*>(renderbuffer));
}

void WebGLRenderingContextDeleteShader(WebGLRenderingContextRef handle, WebGLShaderRef shader) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteShader(reinterpret_cast<blink::WebGLShader*>(shader));
}

void WebGLRenderingContextDeleteTexture(WebGLRenderingContextRef handle, WebGLTextureRef texture) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->deleteTexture(reinterpret_cast<blink::WebGLTexture*>(texture));
}

void WebGLRenderingContextDepthFunc(WebGLRenderingContextRef handle, GLenum func) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->depthFunc(func);
}

void WebGLRenderingContextDepthMask(WebGLRenderingContextRef handle, GLboolean flag) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->depthMask(flag);
}

void WebGLRenderingContextDepthRange(WebGLRenderingContextRef handle, GLclampf zNear, GLclampf zFar) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->depthRange(zNear, zFar);
}

void WebGLRenderingContextDetachShader(WebGLRenderingContextRef handle, WebGLProgramRef program, WebGLShaderRef shader) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->detachShader(reinterpret_cast<blink::WebGLProgram*>(program), reinterpret_cast<blink::WebGLShader*>(shader));
}

void WebGLRenderingContextDisable(WebGLRenderingContextRef handle, GLenum cap) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->disable(cap);
}

void WebGLRenderingContextDisableVertexAttribArray(WebGLRenderingContextRef handle, GLuint index) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->disableVertexAttribArray(index);
}

void WebGLRenderingContextDrawArrays(WebGLRenderingContextRef handle, GLenum mode, GLint first, GLsizei count) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->drawArrays(mode, first, count);
}

void WebGLRenderingContextDrawElements(WebGLRenderingContextRef handle, GLenum mode, GLsizei count, GLenum type, GLintptr offset) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->drawElements(mode, count, type, offset);
}

void WebGLRenderingContextEnable(WebGLRenderingContextRef handle, GLenum cap) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->enable(cap);
}

void WebGLRenderingContextEnableVertexAttribArray(WebGLRenderingContextRef handle, GLuint index) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->enableVertexAttribArray(index);
}

void WebGLRenderingContextFinish(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->finish();
}

void WebGLRenderingContextFlush(WebGLRenderingContextRef handle) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->flush();
}

void WebGLRenderingContextFramebufferRenderbuffer(WebGLRenderingContextRef handle, GLenum target, GLenum attachment, GLenum renderbuffertarget, WebGLRenderbufferRef renderbuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->framebufferRenderbuffer(target, attachment, renderbuffertarget, reinterpret_cast<blink::WebGLRenderbuffer*>(renderbuffer));
}

void WebGLRenderingContextFramebufferTexture2D(WebGLRenderingContextRef handle, GLenum target, GLenum attachment, GLenum textarget, WebGLTextureRef texture, GLint level) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->framebufferTexture2D(target, attachment, textarget, reinterpret_cast<blink::WebGLTexture*>(texture), level);
}

void WebGLRenderingContextFrontFace(WebGLRenderingContextRef handle, GLenum mode) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->frontFace(mode);
}

void WebGLRenderingContextGenerateMipmap(WebGLRenderingContextRef handle, GLenum target) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->generateMipmap(target);
}

WebGLActiveInfoRef WebGLRenderingContextGetActiveAttrib(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint index) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getActiveAttrib(reinterpret_cast<blink::WebGLProgram*>(program), index);
}

WebGLActiveInfoRef WebGLRenderingContextGetActiveUniform(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint index) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getActiveUniform(reinterpret_cast<blink::WebGLProgram*>(program), index);
}

void WebGLRenderingContextGetAttachedShaders(WebGLRenderingContextRef handle, WebGLProgramRef program, WebGLShaderRef* out, int* count) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  base::Optional<blink::HeapVector<blink::Member<blink::WebGLShader>>> maybe_shaders = gl_context->getAttachedShaders(reinterpret_cast<blink::WebGLProgram*>(program));
  if (!maybe_shaders) {
    *count = 0;
    return;
  }
  blink::HeapVector<blink::Member<blink::WebGLShader>> shaders = std::move(maybe_shaders.value());
  *count = shaders.size();
  *out = static_cast<WebGLShaderRef>(malloc(sizeof(intptr_t) * shaders.size()));
  for (size_t i = 0; i < shaders.size(); ++i) {
    out[i] = shaders[i];
  }
}

GLint WebGLRenderingContextGetAttribLocation(WebGLRenderingContextRef handle, WebGLProgramRef program, const char* name) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getAttribLocation(reinterpret_cast<blink::WebGLProgram*>(program), name);
}

void* WebGLRenderingContextGetBufferParameter(WebGLRenderingContextRef handle, GLenum target, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  //gl_context->getBufferParameter(target, name);
  return nullptr;
}

void* WebGLRenderingContextGetExtension(WebGLRenderingContextRef handle, const char* name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

void* WebGLRenderingContextGetFramebufferAttachmentParameter(WebGLRenderingContextRef handle, GLenum target, GLenum attachment, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

void* WebGLRenderingContextGetParameter(WebGLRenderingContextRef handle, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

void* WebGLRenderingContextGetProgramParameter(WebGLRenderingContextRef handle, WebGLProgramRef program, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

char* WebGLRenderingContextGetProgramInfoLog(WebGLRenderingContextRef handle, WebGLProgramRef program, int* len) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  String str = gl_context->getProgramInfoLog(reinterpret_cast<blink::WebGLProgram*>(program));
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

void* WebGLRenderingContextGetRenderbufferParameter(WebGLRenderingContextRef handle, GLenum target, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

void* WebGLRenderingContextGetShaderParameter(WebGLRenderingContextRef handle, WebGLShaderRef shader, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

char* WebGLRenderingContextGetShaderInfoLog(WebGLRenderingContextRef handle, WebGLShaderRef shader, int* len) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  String str = gl_context->getShaderInfoLog(reinterpret_cast<blink::WebGLShader*>(shader));
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

WebGLShaderPrecisionFormatRef WebGLRenderingContextGetShaderPrecisionFormat(WebGLRenderingContextRef handle, GLenum shadertype, GLenum precisiontype) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getShaderPrecisionFormat(shadertype, precisiontype);
}

char* WebGLRenderingContextGetShaderSource(WebGLRenderingContextRef handle, WebGLShaderRef shader, int* len) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  String str = gl_context->getShaderSource(reinterpret_cast<blink::WebGLShader*>(shader));
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

void WebGLRenderingContextGetSupportedExtensions(WebGLRenderingContextRef handle, const char** ext_out, int* count) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
}

void* WebGLRenderingContextGetTexParameter(WebGLRenderingContextRef handle, GLenum target, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

void* WebGLRenderingContextGetUniform(WebGLRenderingContextRef handle, WebGLProgramRef program, WebGLUniformLocationRef location) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

WebGLUniformLocationRef WebGLRenderingContextGetUniformLocation(WebGLRenderingContextRef handle, WebGLProgramRef program, const char* name) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getUniformLocation(reinterpret_cast<blink::WebGLProgram*>(program), name);
}

void* WebGLRenderingContextGetVertexAttrib(WebGLRenderingContextRef handle, GLuint index, GLenum name) {
  //blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return nullptr;
}

GLintptr WebGLRenderingContextGetVertexAttribOffset(WebGLRenderingContextRef handle, GLuint index, GLenum name) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->getVertexAttribOffset(index, name);
}

void WebGLRenderingContextHint(WebGLRenderingContextRef handle, GLenum target, GLenum mode) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->hint(target, mode);
}

GLboolean WebGLRenderingContextIsBuffer(WebGLRenderingContextRef handle, WebGLBufferRef buffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isBuffer(reinterpret_cast<blink::WebGLBuffer*>(buffer));
}

GLboolean WebGLRenderingContextIsEnabled(WebGLRenderingContextRef handle, GLenum cap) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isEnabled(cap);
}

GLboolean WebGLRenderingContextIsFramebuffer(WebGLRenderingContextRef handle, WebGLFramebufferRef framebuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isFramebuffer(reinterpret_cast<blink::WebGLFramebuffer*>(framebuffer));
}

GLboolean WebGLRenderingContextIsProgram(WebGLRenderingContextRef handle, WebGLProgramRef program) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isProgram(reinterpret_cast<blink::WebGLProgram*>(program));
}

GLboolean WebGLRenderingContextIsRenderbuffer(WebGLRenderingContextRef handle, WebGLRenderbufferRef renderbuffer) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isRenderbuffer(reinterpret_cast<blink::WebGLRenderbuffer*>(renderbuffer));
}

GLboolean WebGLRenderingContextIsShader(WebGLRenderingContextRef handle, WebGLShaderRef shader) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isShader(reinterpret_cast<blink::WebGLShader*>(shader));
}

GLboolean WebGLRenderingContextIsTexture(WebGLRenderingContextRef handle, WebGLTextureRef texture) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->isTexture(reinterpret_cast<blink::WebGLTexture*>(texture));
}

void WebGLRenderingContextLineWidth(WebGLRenderingContextRef handle, GLfloat width) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  return gl_context->lineWidth(width);
}

void WebGLRenderingContextLinkProgram(WebGLRenderingContextRef handle, WebGLProgramRef program) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->linkProgram(reinterpret_cast<blink::WebGLProgram*>(program));
}

void WebGLRenderingContextPixelStorei(WebGLRenderingContextRef handle, GLenum name, GLint param) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->pixelStorei(name, param);
}

void WebGLRenderingContextPolygonOffset(WebGLRenderingContextRef handle, GLfloat factor, GLfloat units) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->polygonOffset(factor, units);
}

void WebGLRenderingContextReadPixels(WebGLRenderingContextRef handle, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, DOMArrayBufferViewRef pixels) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> pixels_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl_context->readPixels(x, y, width, height, format, type, pixels_ref);
}

void WebGLRenderingContexRenderbufferStorage(WebGLRenderingContextRef handle, GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->renderbufferStorage(target, internalformat, width, height);
}

void WebGLRenderingContextSampleCoverage(WebGLRenderingContextRef handle, GLclampf value, GLboolean invert) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->sampleCoverage(value, invert);
}

void WebGLRenderingContextScissor(WebGLRenderingContextRef handle, GLint x, GLint y, GLsizei width, GLsizei height) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->scissor(x, y, width, height);
}

void WebGLRenderingContextShaderSource(WebGLRenderingContextRef handle, WebGLShaderRef shader, const char* string) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->shaderSource(reinterpret_cast<blink::WebGLShader*>(shader), string);
}

void WebGLRenderingContextStencilFunc(WebGLRenderingContextRef handle, GLenum func, GLint ref, GLuint mask) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilFunc(func, ref, mask);
}

void WebGLRenderingContextStencilFuncSeparate(WebGLRenderingContextRef handle, GLenum face, GLenum func, GLint ref, GLuint mask) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilFuncSeparate(face, func, ref, mask);
}

void WebGLRenderingContextStencilMask(WebGLRenderingContextRef handle, GLuint mask) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilMask(mask);
}

void WebGLRenderingContextStencilMaskSeparate(WebGLRenderingContextRef handle, GLenum face, GLuint mask) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilMaskSeparate(face, mask);
}

void WebGLRenderingContextStencilOp(WebGLRenderingContextRef handle, GLenum fail, GLenum zfail, GLenum zpass) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilOp(fail, zfail, zpass);
}

void WebGLRenderingContextStencilOpSeparate(WebGLRenderingContextRef handle, GLenum face, GLenum fail, GLenum zfail, GLenum zpass) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->stencilOpSeparate(face, fail, zfail, zpass);
}

void WebGLRenderingContextTexParameterf(WebGLRenderingContextRef handle, GLenum target, GLenum name, GLfloat param) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->texParameterf(target, name, param);
}

void WebGLRenderingContextTexParameteri(WebGLRenderingContextRef handle, GLenum target, GLenum name, GLint param) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->texParameteri(target, name, param);
}

void WebGLRenderingContextTexImage2D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, DOMArrayBufferViewRef pixels) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> pixels_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl_context->texImage2D(target, level, internalformat, width, height, border, format, type, pixels_ref);
}

void WebGLRenderingContextTexImage2D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLenum format, GLenum type, WebImageDataRef pixels) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->texImage2D(target, level, internalformat, format, type, reinterpret_cast<blink::ImageData*>(pixels));
}

void WebGLRenderingContextTexImage2D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texImage2D(execution_context, target, level, internalformat, format, type, image_element, exceptionState);
}

void WebGLRenderingContextTexImage2D3(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texImage2D(execution_context, target, level, internalformat, format, type, canvas_element, exceptionState);
}

void WebGLRenderingContextTexImage2D4(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texImage2D(execution_context, target, level, internalformat, format, type, video_element, exceptionState);
}

void WebGLRenderingContextTexImage2D5(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl_context->texImage2D(target, level, internalformat, format, type, reinterpret_cast<blink::ImageBitmap*>(bitmap), exceptionState);
}

void WebGLRenderingContextTexSubImage2D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, DOMArrayBufferViewRef pixels) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data_ref);
}

void WebGLRenderingContextTexSubImage2D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, WebImageDataRef pixels) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->texSubImage2D(target, level, xoffset, yoffset, format, type, reinterpret_cast<blink::ImageData *>(pixels));
}

void WebGLRenderingContextTexSubImage2D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, format, type, image_element, exceptionState);
}

void WebGLRenderingContextTexSubImage2D3(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, format, type, canvas_element, exceptionState);
}

void WebGLRenderingContextTexSubImage2D4(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, format, type, video_element, exceptionState);
}

void WebGLRenderingContextTexSubImage2D5(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl_context->texSubImage2D(target, level, xoffset, yoffset, format, type, reinterpret_cast<blink::ImageBitmap *>(bitmap), exceptionState);
}

void WebGLRenderingContextUniform1f(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLfloat x) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform1f(reinterpret_cast<blink::WebGLUniformLocation*>(location), x);
}

void WebGLRenderingContextUniform1fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform1fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform1fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform1fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform1i(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLint x) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform1i(reinterpret_cast<blink::WebGLUniformLocation*>(location), x);
}

void WebGLRenderingContextUniform1iv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform1iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform1iv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform1iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform2f(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLfloat x, GLfloat y) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform2f(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y);
}

void WebGLRenderingContextUniform2fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform2fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform2i(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLint x, GLint y) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform2i(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y);
}

void WebGLRenderingContextUniform2iv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform2iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform2iv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform2iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform3f(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLfloat x, GLfloat y, GLfloat z) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform3f(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y, z);
}

void WebGLRenderingContextUniform3fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform3fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform3i(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLint x, GLint y, GLint z) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform3i(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y, z);
}

void WebGLRenderingContextUniform3iv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform3iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform3iv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform3iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform4f(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform4f(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y, z, w);
}

void WebGLRenderingContextUniform4fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform4fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniform4i(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLint x, GLint y, GLint z, GLint w) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->uniform4i(reinterpret_cast<blink::WebGLUniformLocation*>(location), x, y, z, w);
}

void WebGLRenderingContextUniform4iv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl_context->uniform4iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr);
}

void WebGLRenderingContextUniform4iv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl_context->uniform4iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems);
}

void WebGLRenderingContextUniformMatrix2fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl_context->uniformMatrix2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref);
}

void WebGLRenderingContextUniformMatrix2fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int arr_count, const GLfloat* array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < arr_count; ++i) {
    elems.push_back(array[i]);
  }
  gl_context->uniformMatrix2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems);
}

void WebGLRenderingContextUniformMatrix3fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl_context->uniformMatrix3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref);
}

void WebGLRenderingContextUniformMatrix3fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int arr_count, const GLfloat* array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < arr_count; ++i) {
    elems.push_back(array[i]);
  }
  gl_context->uniformMatrix3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems);
}

void WebGLRenderingContextUniformMatrix4fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl_context->uniformMatrix4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref);
}

void WebGLRenderingContextUniformMatrix4fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int arr_count, const GLfloat* array) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < arr_count; ++i) {
    elems.push_back(array[i]);
  }
  gl_context->uniformMatrix4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems);
}

void WebGLRenderingContextUseProgram(WebGLRenderingContextRef handle, WebGLProgramRef program) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->useProgram(reinterpret_cast<blink::WebGLProgram*>(program));
}

void WebGLRenderingContextValidateProgram(WebGLRenderingContextRef handle, WebGLProgramRef program) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->validateProgram(reinterpret_cast<blink::WebGLProgram*>(program));
}

void WebGLRenderingContextVertexAttrib1f(WebGLRenderingContextRef handle, GLuint index, GLfloat x) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->vertexAttrib1f(index, x);
}

void WebGLRenderingContextVertexAttrib1fv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef /*Float32Array*/ values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(values));
  gl_context->vertexAttrib1fv(index, arr_ref);
}

void WebGLRenderingContextVertexAttrib1fv1(WebGLRenderingContextRef handle, GLuint index, int values_size, const GLfloat* values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> values_vec;
  for (int i = 0; i < values_size; ++i) {
    values_vec.push_back(values[i]);
  }
  gl_context->vertexAttrib1fv(index, values_vec);
}

void WebGLRenderingContextVertexAttrib2f(WebGLRenderingContextRef handle, GLuint index, GLfloat x, GLfloat y) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->vertexAttrib2f(index, x, y);
}

void WebGLRenderingContextVertexAttrib2fv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef /*Float32Array*/ values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(values));
  gl_context->vertexAttrib2fv(index, arr_ref);
}

void WebGLRenderingContextVertexAttrib2fv1(WebGLRenderingContextRef handle, GLuint index, int values_size, const GLfloat* values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> values_vec;
  for (int i = 0; i < values_size; ++i) {
    values_vec.push_back(values[i]);
  }
  gl_context->vertexAttrib2fv(index, values_vec);
}

void WebGLRenderingContextVertexAttrib3f(WebGLRenderingContextRef handle, GLuint index, GLfloat x, GLfloat y, GLfloat z) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->vertexAttrib3f(index, x, y, z);
}

void WebGLRenderingContextVertexAttrib3fv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef /*Float32Array*/ values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(values));
  gl_context->vertexAttrib3fv(index, arr_ref);
}

void WebGLRenderingContextVertexAttrib3fv1(WebGLRenderingContextRef handle, GLuint index, int values_size, const GLfloat* values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> values_vec;
  for (int i = 0; i < values_size; ++i) {
    values_vec.push_back(values[i]);
  }
  gl_context->vertexAttrib3fv(index, values_vec);
}

void WebGLRenderingContextVertexAttrib4f(WebGLRenderingContextRef handle, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->vertexAttrib4f(index, x, y, z, w);
}

void WebGLRenderingContextVertexAttrib4fv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef /*Float32Array*/ values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(values));
  gl_context->vertexAttrib4fv(index, arr_ref);
}

void WebGLRenderingContextVertexAttrib4fv1(WebGLRenderingContextRef handle, GLuint index, int values_size, const GLfloat* values) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  Vector<GLfloat> values_vec;
  for (int i = 0; i < values_size; ++i) {
    values_vec.push_back(values[i]);
  }
  gl_context->vertexAttrib4fv(index, values_vec);
}

void WebGLRenderingContextVertexAttribPointer(WebGLRenderingContextRef handle, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->vertexAttribPointer(index, size, type, normalized, stride, offset);
}

void WebGLRenderingContextViewport(WebGLRenderingContextRef handle, GLint x, GLint y, GLsizei width, GLsizei height) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  gl_context->viewport(x, y, width, height);
}

void WebGLRenderingContextCommit(WebGLRenderingContextRef handle, WebLocalDomWindowRef window, void* state, void(*cb)(void*, void*)) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WebGLRenderingContext", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = gl_context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
      
  v8_context->Exit();
}

void WebGLRenderingContextCommitFromWorker(WebGLRenderingContextRef handle, WebWorkerRef worker, void* state, void(*cb)(void*, void*)) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WebGLRenderingContext", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = gl_context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));

  v8_context->Exit();
}

void WebGLRenderingContextCommitFromServiceWorker(WebGLRenderingContextRef handle, ServiceWorkerGlobalScopeRef scope, void* state, void(*cb)(void*, void*)) {
  blink::WebGLRenderingContext* gl_context = reinterpret_cast<blink::WebGLRenderingContext*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WebGLRenderingContext", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = gl_context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
      
  v8_context->Exit();
}


// WebGL2

void WebGL2RenderingContextBufferData3(WebGLRenderingContextRef handle, GLenum target, DOMArrayBufferViewRef srcData, GLenum usage, GLuint srcOffset, GLuint length) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  //blink::FlexibleArrayBufferView view_ref;
  //view_ref.SetFull(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  blink::MaybeShared<blink::DOMArrayBufferView> src_ref(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  gl2_context->bufferData(target, src_ref, usage, srcOffset, length);
}

void WebGL2RenderingContextBufferSubData(WebGLRenderingContextRef handle, GLenum target, GLintptr dstByteOffset, DOMArrayBufferViewRef srcData, GLuint srcOffset, GLuint length) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  //blink::FlexibleArrayBufferView view_ref;
  //view_ref.SetFull(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  blink::MaybeShared<blink::DOMArrayBufferView> src_ref(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  gl2_context->bufferSubData(target, dstByteOffset, src_ref, srcOffset, length);
}

void WebGL2RenderingContextCopyBufferSubData(WebGLRenderingContextRef handle, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}

void WebGL2RenderingContextGetBufferSubData(WebGLRenderingContextRef handle, GLenum target, GLintptr srcByteOffset, DOMArrayBufferViewRef dstData, GLuint dstOffset, GLuint length) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> dst(reinterpret_cast<blink::DOMArrayBufferView *>(dstData));
  gl2_context->getBufferSubData(target, srcByteOffset, dst, dstOffset, length);
}

GLint WebGL2RenderingContextGetFragDataLocation(WebGLRenderingContextRef handle, WebGLProgramRef program, const char* name) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->getFragDataLocation(reinterpret_cast<blink::WebGLProgram*>(program), name);
}

void WebGL2RenderingContextTexImage2D6(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texImage2D(target, level, internalformat, width, height, border, format, type, offset);
}

void WebGL2RenderingContextTexImage2D7(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, WebImageDataRef data) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texImage2D(target, level, internalformat, width, height, border, format, type, reinterpret_cast<blink::ImageData*>(data));
}

void WebGL2RenderingContextTexImage2D8(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage2D(execution_context, target, level, internalformat, width, height, border, format, type, image_element, exceptionState);
}

void WebGL2RenderingContextTexImage2D9(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage2D(execution_context, target, level, internalformat, width, height, border, format, type, canvas_element, exceptionState);
}

void WebGL2RenderingContextTexImage2D10(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage2D(execution_context, target, level, internalformat, width, height, border, format, type, video_element, exceptionState);
}

void WebGL2RenderingContextTexImage2D11(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl2_context->texImage2D(target, level, internalformat, width, height, border, format, type, reinterpret_cast<blink::ImageBitmap*>(bitmap), exceptionState);
}

void WebGL2RenderingContextTexImage2D12(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, DOMArrayBufferViewRef srcData, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  gl2_context->texImage2D(target, level, internalformat, width, height, border, format, type, data_ref, srcOffset);
}

void WebGL2RenderingContextTexSubImage2D6(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
}

void WebGL2RenderingContextTexSubImage2D7(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, WebImageDataRef data) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, reinterpret_cast<blink::ImageData *>(data));
}

void WebGL2RenderingContextTexSubImage2D8(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, width, height, format, type, image_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage2D9(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, width, height, format, type, canvas_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage2D10(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texSubImage2D(execution_context, target, level, xoffset, yoffset, width, height, format, type, video_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage2D11(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl2_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, reinterpret_cast<blink::ImageBitmap*>(bitmap), exceptionState);
}

void WebGL2RenderingContextTexSubImage2D12(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, DOMArrayBufferViewRef srcData, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(srcData));
  gl2_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data_ref, srcOffset);
}

void WebGL2RenderingContextTexStorage2D0(WebGLRenderingContextRef handle, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texStorage2D(target, levels, internalformat, width, height);
}

void WebGL2RenderingContextTexStorage3D1(WebGLRenderingContextRef handle, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texStorage3D(target, levels, internalformat, width, height, depth);
}

void WebGL2RenderingContextTexImage3D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, offset);
}

void WebGL2RenderingContextTexImage3D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, WebImageDataRef data) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, reinterpret_cast<blink::ImageData*>(data));
}

void WebGL2RenderingContextTexImage3D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage3D(execution_context, target, level, internalformat, width, height, depth, border, format, type, image_element, exceptionState);
}

void WebGL2RenderingContextTexImage3D3(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage3D(execution_context, target, level, internalformat, width, height, depth, border, format, type, canvas_element, exceptionState);
}

void WebGL2RenderingContextTexImage3D4(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texImage3D(execution_context, target, level, internalformat, width, height, depth, border, format, type, video_element, exceptionState);
}

void WebGL2RenderingContextTexImage3D5(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl2_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, reinterpret_cast<blink::ImageBitmap*>(bitmap), exceptionState);
}

void WebGL2RenderingContextTexImage3D6(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, DOMArrayBufferViewRef pixels) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl2_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, data_ref);
}

void WebGL2RenderingContextTexImage3D7(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, DOMArrayBufferViewRef pixels, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl2_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, data_ref, srcOffset);
}

void WebGL2RenderingContextTexSubImage3D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
}

void WebGL2RenderingContextTexSubImage3D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, WebImageDataRef data) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, reinterpret_cast<blink::ImageData*>(data));
}

void WebGL2RenderingContextTexSubImage3D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, WebNodeRef image) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texSubImage3D(execution_context, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, image_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage3D3(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, WebNodeRef canvas) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* canvas_element = ref->unwrap<blink::HTMLCanvasElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);

  gl2_context->texSubImage3D(execution_context, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, canvas_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage3D4(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, WebNodeRef video) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* video_element = ref->unwrap<blink::HTMLVideoElement>();
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  gl2_context->texSubImage3D(execution_context, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, video_element, exceptionState);
}

void WebGL2RenderingContextTexSubImage3D5(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, WebImageBitmapRef bitmap) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  gl2_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, reinterpret_cast<blink::ImageBitmap*>(bitmap), exceptionState);
}

void WebGL2RenderingContextTexSubImage3D6(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, DOMArrayBufferViewRef pixels, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(pixels));
  gl2_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_ref, srcOffset);
}

void WebGL2RenderingContextCopyTexSubImage3D(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

void WebGL2RenderingContextCompressedTexImage2D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, DOMArrayBufferViewRef data, GLuint srcOffset, GLuint srcLengthOverride) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl2_context->compressedTexImage2D(target, level, internalformat, width, height, border, data_ref, srcOffset, srcLengthOverride);
}

void WebGL2RenderingContextCompressedTexSubImage2D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, DOMArrayBufferViewRef data, GLuint srcOffset, GLuint srcLengthOverride) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl2_context->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data_ref, srcOffset, srcLengthOverride);
}

void WebGL2RenderingContextCompressedTexImage3D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, DOMArrayBufferViewRef data, GLuint srcOffset, GLuint srcLengthOverride) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl2_context->compressedTexImage3D(target, level, internalformat, width, height, depth, border, data_ref, srcOffset, srcLengthOverride);
}

void WebGL2RenderingContextCompressedTexSubImage3D0(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, DOMArrayBufferViewRef data, GLuint srcOffset, GLuint srcLengthOverride) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> data_ref(reinterpret_cast<blink::DOMArrayBufferView *>(data));
  gl2_context->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, data_ref, srcOffset, srcLengthOverride);
}

void WebGL2RenderingContextCompressedTexImage2D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->compressedTexImage2D(target, level, internalformat, width, height, border, imageSize, offset);
}

void WebGL2RenderingContextCompressedTexSubImage2D2(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, offset);
}

void WebGL2RenderingContextCompressedTexImage3D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->compressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, offset);
}

void WebGL2RenderingContextCompressedTexSubImage3D1(WebGLRenderingContextRef handle, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, offset);
}

void WebGL2RenderingContextVertexAttribI4i(WebGLRenderingContextRef handle, GLuint index, GLint x, GLint y, GLint z, GLint w) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->vertexAttribI4i(index, x, y, z, w);
}

void WebGL2RenderingContextVertexAttribI4iv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef/*Int32Array*/ v) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMInt32Array> arr_ref(reinterpret_cast<blink::DOMInt32Array*>(v));
  gl2_context->vertexAttribI4iv(index, arr_ref);
}

void WebGL2RenderingContextVertexAttribI4iv1(WebGLRenderingContextRef handle, GLuint index, int v_count, const GLint* v) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> values_vec;
  for (int i = 0; i < v_count; ++i) {
    values_vec.push_back(v[i]);
  }
  gl2_context->vertexAttribI4iv(index, values_vec);
}

void WebGL2RenderingContextVertexAttribI4ui(WebGLRenderingContextRef handle, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->vertexAttribI4ui(index, x, y, z, w);
}

void WebGL2RenderingContextVertexAttribI4uiv0(WebGLRenderingContextRef handle, GLuint index, DOMArrayBufferRef /*Uint32Array*/ v) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMUint32Array> arr_ref(reinterpret_cast<blink::DOMUint32Array*>(v));
  gl2_context->vertexAttribI4uiv(index, arr_ref);
}

void WebGL2RenderingContextVertexAttribI4uiv1(WebGLRenderingContextRef handle, GLuint index, int v_count, const GLuint* v) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> values_vec;
  for (int i = 0; i < v_count; ++i) {
    values_vec.push_back(v[i]);
  }
  gl2_context->vertexAttribI4uiv(index, values_vec);
}

void WebGL2RenderingContextVertexAttribIPointer(WebGLRenderingContextRef handle, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->vertexAttribIPointer(index, size, type, stride, offset);
}

void WebGL2RenderingContextUniform1ui(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLuint v0) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->uniform1ui(reinterpret_cast<blink::WebGLUniformLocation*>(location), v0);
}

void WebGL2RenderingContextUniform2ui(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLuint v0, GLuint v1) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->uniform2ui(reinterpret_cast<blink::WebGLUniformLocation*>(location), v0, v1);
}

void WebGL2RenderingContextUniform3ui(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLuint v0, GLuint v1, GLuint v2) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->uniform3ui(reinterpret_cast<blink::WebGLUniformLocation*>(location), v0, v1, v2);
}

void WebGL2RenderingContextUniform4ui(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->uniform4ui(reinterpret_cast<blink::WebGLUniformLocation*>(location), v0, v1, v2, v3);
}

void WebGL2RenderingContextUniform1fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform1fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform1fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform1fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Float32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleFloat32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLfloat* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform1iv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform1iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform1iv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform1iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2iv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform2iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2iv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform2iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3iv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform3iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4iv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform4iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4iv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLint* v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform4iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform1uiv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Uint32Array*/ v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleUint32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform1uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform1uiv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLuint* v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform1uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2uiv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Uint32Array*/ v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleUint32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform2uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform2uiv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLuint* v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform2uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3iv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Int32Array*/ v, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleInt32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform3iv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3uiv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Uint32Array*/ v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleUint32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform3uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform3uiv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLuint* v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform3uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4uiv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, DOMArrayBufferViewRef /*Uint32Array*/ v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::FlexibleUint32ArrayView arr;
  arr.SetFull(reinterpret_cast<blink::DOMArrayBufferView*>(v));
  gl2_context->uniform4uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), arr, srcOffset, srcLength);
}

void WebGL2RenderingContextUniform4uiv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, int v_count, const GLuint* v, GLuint srcOffset , GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> elems;
  for (int i = 0; i < v_count; ++i) {
    elems.push_back(v[i]);
  }
  gl2_context->uniform4uiv(reinterpret_cast<blink::WebGLUniformLocation*>(location), elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4fv2(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4fv3(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2x3fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix2x3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2x3fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix2x3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3x2fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix3x2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3x2fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix3x2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2x4fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix2x4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix2x4fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix2x4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4x2fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix4x2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4x2fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int array_count, const GLfloat* array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < array_count; ++i) {
    elems.push_back(array[i]);
  }
  gl2_context->uniformMatrix4x2fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3x4fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ value, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(value));
  gl2_context->uniformMatrix3x4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix3x4fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int value_count, const GLfloat* value, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < value_count; ++i) {
    elems.push_back(value[i]);
  }
  gl2_context->uniformMatrix3x4fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4x3fv0(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, DOMArrayBufferRef /*Float32Array*/ array, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(array));
  gl2_context->uniformMatrix4x3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, arr_ref, srcOffset, srcLength);
}

void WebGL2RenderingContextUniformMatrix4x3fv1(WebGLRenderingContextRef handle, WebGLUniformLocationRef location, GLboolean transpose, int value_count, const GLfloat* value, GLuint srcOffset, GLuint srcLength) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < value_count; ++i) {
    elems.push_back(value[i]);
  }
  gl2_context->uniformMatrix4x3fv(reinterpret_cast<blink::WebGLUniformLocation*>(location), transpose, elems, srcOffset, srcLength);
}

void WebGL2RenderingContextBlitFramebuffer(WebGLRenderingContextRef handle, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void WebGL2RenderingContextFramebufferTextureLayer(WebGLRenderingContextRef handle, GLenum target, GLenum attachment, WebGLTextureRef texture, GLint level, GLint layer) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->framebufferTextureLayer(target, attachment, reinterpret_cast<blink::WebGLTexture*>(texture), level, layer);
}

void* WebGL2RenderingContextGetInternalformatParameter(WebGLRenderingContextRef handle, GLenum target, GLenum internalformat, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

void WebGL2RenderingContextInvalidateFramebuffer(WebGLRenderingContextRef handle, GLenum target, int attachments_count, const GLenum* attachments) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLenum> elems;
  for (int i = 0; i < attachments_count; ++i) {
    elems.push_back(attachments[i]);
  }
  gl2_context->invalidateFramebuffer(target, elems);
}

void WebGL2RenderingContextInvalidateSubFramebuffer(WebGLRenderingContextRef handle, GLenum target, int attachments_count, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLenum> elems;
  for (int i = 0; i < attachments_count; ++i) {
    elems.push_back(attachments[i]);
  }
  gl2_context->invalidateSubFramebuffer(target, elems, x, y, width, height);
}

void WebGL2RenderingContextReadBuffer(WebGLRenderingContextRef handle, GLenum mode) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->readBuffer(mode);
}

void WebGL2RenderingContextRenderbufferStorageMultisample(WebGLRenderingContextRef handle, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->renderbufferStorageMultisample(target, samples, internalformat, width, height);
}

void WebGL2RenderingContextVertexAttribDivisor(WebGLRenderingContextRef handle, GLuint index, GLuint divisor) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->vertexAttribDivisor(index, divisor);
}

void WebGL2RenderingContextDrawArraysInstanced(WebGLRenderingContextRef handle, GLenum mode, GLint first, GLsizei count, GLsizei instanceCount) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->drawArraysInstanced(mode, first, count, instanceCount);
}

void WebGL2RenderingContextDrawElementsInstanced(WebGLRenderingContextRef handle, GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->drawElementsInstanced(mode, count, type, offset, instanceCount);
}

void WebGL2RenderingContextDrawRangeElements(WebGLRenderingContextRef handle, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->drawRangeElements(mode, start, end, count, type, offset);
}

void WebGL2RenderingContextDrawBuffers(WebGLRenderingContextRef handle, int buffer_count, const GLenum* buffers) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLenum> elems;
  for (int i = 0; i < buffer_count; ++i) {
    elems.push_back(buffers[i]);
  }
  gl2_context->drawBuffers(elems);
}

void WebGL2RenderingContextClearBufferiv0(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, DOMArrayBufferRef /*Int32Array*/ value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMInt32Array> arr_ref(reinterpret_cast<blink::DOMInt32Array*>(value));
  gl2_context->clearBufferiv(buffer, drawbuffer, arr_ref, srcOffset);
}

void WebGL2RenderingContextClearBufferiv1(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, int value_count, const GLint* value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLint> elems;
  for (int i = 0; i < value_count; ++i) {
    elems.push_back(value[i]);
  }
  gl2_context->clearBufferiv(buffer, drawbuffer, elems, srcOffset);
}

void WebGL2RenderingContextClearBufferuiv0(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, DOMArrayBufferRef /*Uint32Array*/ value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMUint32Array> arr_ref(reinterpret_cast<blink::DOMUint32Array*>(value));
  gl2_context->clearBufferuiv(buffer, drawbuffer, arr_ref, srcOffset);
}

void WebGL2RenderingContextClearBufferuiv1(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, int value_count, const GLuint* value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLuint> elems;
  for (int i = 0; i < value_count; ++i) {
    elems.push_back(value[i]);
  }
  gl2_context->clearBufferuiv(buffer, drawbuffer, elems, srcOffset);
}

void WebGL2RenderingContextClearBufferfv0(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer,  DOMArrayBufferRef /*Float32Array*/ value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
   blink::MaybeShared<blink::DOMFloat32Array> arr_ref(reinterpret_cast<blink::DOMFloat32Array*>(value));
  gl2_context->clearBufferfv(buffer, drawbuffer, arr_ref, srcOffset);
}

void WebGL2RenderingContextClearBufferfv1(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, int value_count, const GLfloat* value, GLuint srcOffset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<GLfloat> elems;
  for (int i = 0; i < value_count; ++i) {
    elems.push_back(value[i]);
  }
  gl2_context->clearBufferfv(buffer, drawbuffer, elems, srcOffset);
}

void WebGL2RenderingContextClearBufferfi(WebGLRenderingContextRef handle, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->clearBufferfi(buffer, drawbuffer, depth, stencil);
}

WebGLQueryRef WebGL2RenderingContextCreateQuery(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->createQuery();
}

void WebGL2RenderingContextDeleteQuery(WebGLRenderingContextRef handle, WebGLQueryRef query) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->deleteQuery(reinterpret_cast<blink::WebGLQuery*>(query));
}

GLboolean WebGL2RenderingContextIsQuery(WebGLRenderingContextRef handle, WebGLQueryRef query) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->isQuery(reinterpret_cast<blink::WebGLQuery*>(query));
}

void WebGL2RenderingContextBeginQuery(WebGLRenderingContextRef handle, GLenum target, WebGLQueryRef query) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->beginQuery(target, reinterpret_cast<blink::WebGLQuery*>(query));
}

void WebGL2RenderingContextEndQuery(WebGLRenderingContextRef handle, GLenum target) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->endQuery(target);
}

void* WebGL2RenderingContextGetQuery(WebGLRenderingContextRef handle, GLenum target, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

void* WebGL2RenderingContextGetQueryParameter(WebGLRenderingContextRef handle, WebGLQueryRef query, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

WebGLSamplerRef WebGL2RenderingContextCreateSampler(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->createSampler();
}

void WebGL2RenderingContextDeleteSampler(WebGLRenderingContextRef handle, WebGLSamplerRef sampler) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->deleteSampler(reinterpret_cast<blink::WebGLSampler*>(sampler));
}

GLboolean WebGL2RenderingContextIsSampler(WebGLRenderingContextRef handle, WebGLSamplerRef sampler) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->isSampler(reinterpret_cast<blink::WebGLSampler*>(sampler));
}

void WebGL2RenderingContextBindSampler(WebGLRenderingContextRef handle, GLuint unit, WebGLSamplerRef sampler) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->bindSampler(unit, reinterpret_cast<blink::WebGLSampler*>(sampler));
}

void WebGL2RenderingContextSamplerParameteri(WebGLRenderingContextRef handle, WebGLSamplerRef sampler, GLenum name, GLint param) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->samplerParameteri(reinterpret_cast<blink::WebGLSampler*>(sampler), name, param);
}

void WebGL2RenderingContextSamplerParameterf(WebGLRenderingContextRef handle, WebGLSamplerRef sampler, GLenum name, GLfloat param) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->samplerParameterf(reinterpret_cast<blink::WebGLSampler*>(sampler), name, param);
}

void* WebGL2RenderingContextGetSamplerParameter(WebGLRenderingContextRef handle, WebGLSamplerRef sampler, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

WebGLSyncRef WebGL2RenderingContextFenceSync(WebGLRenderingContextRef handle, GLenum condition, GLbitfield flags) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->fenceSync(condition, flags);
}

GLboolean WebGL2RenderingContextIsSync(WebGLRenderingContextRef handle, WebGLSyncRef sync) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->isSync(reinterpret_cast<blink::WebGLSync*>(sync));
}

void WebGL2RenderingContextDeleteSync(WebGLRenderingContextRef handle, WebGLSyncRef sync) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->deleteSync(reinterpret_cast<blink::WebGLSync*>(sync));
}

GLenum WebGL2RenderingContextClientWaitSync(WebGLRenderingContextRef handle, WebGLSyncRef sync, GLbitfield flags, GLuint64 timeout) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->clientWaitSync(reinterpret_cast<blink::WebGLSync*>(sync), flags, timeout);
}

void WebGL2RenderingContextWaitSync(WebGLRenderingContextRef handle, WebGLSyncRef sync, GLbitfield flags, GLint64 timeout) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->waitSync(reinterpret_cast<blink::WebGLSync*>(sync), flags, timeout);
}

void* WebGL2RenderingContextGetSyncParameter(WebGLRenderingContextRef handle, WebGLSyncRef sync, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

WebGLTransformFeedbackRef WebGL2RenderingContextCreateTransformFeedback(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->createTransformFeedback();
}

void WebGL2RenderingContextDeleteTransformFeedback(WebGLRenderingContextRef handle, WebGLTransformFeedbackRef feedback) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->deleteTransformFeedback(reinterpret_cast<blink::WebGLTransformFeedback*>(feedback));
}

GLboolean WebGL2RenderingContextIsTransformFeedback(WebGLRenderingContextRef handle, WebGLTransformFeedbackRef feedback) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->isTransformFeedback(reinterpret_cast<blink::WebGLTransformFeedback*>(feedback));
}

void WebGL2RenderingContextBindTransformFeedback(WebGLRenderingContextRef handle, GLenum target, WebGLTransformFeedbackRef feedback) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->bindTransformFeedback(target, reinterpret_cast<blink::WebGLTransformFeedback*>(feedback));
}

void WebGL2RenderingContextBeginTransformFeedback(WebGLRenderingContextRef handle, GLenum primitiveMode) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->beginTransformFeedback(primitiveMode);
}

void WebGL2RenderingContextEndTransformFeedback(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->endTransformFeedback();
}

void WebGL2RenderingContextTransformFeedbackVaryings(WebGLRenderingContextRef handle, WebGLProgramRef program, int varyingsCount, const char** varyings, GLenum bufferMode) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<String> varying_vec;
  for (int i = 0; i < varyingsCount; ++i) {
    varying_vec.push_back(String::FromUTF8(varyings[i]));
  }
  gl2_context->transformFeedbackVaryings(reinterpret_cast<blink::WebGLProgram*>(program), varying_vec, bufferMode);
}

WebGLActiveInfoRef WebGL2RenderingContextGetTransformFeedbackVarying(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint index) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->getTransformFeedbackVarying(reinterpret_cast<blink::WebGLProgram*>(program), index);
}

void WebGL2RenderingContextPauseTransformFeedback(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->pauseTransformFeedback();
}
 
void WebGL2RenderingContextResumeTransformFeedback(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->resumeTransformFeedback();
}

void WebGL2RenderingContextBindBufferBase(WebGLRenderingContextRef handle, GLenum target, GLuint index, WebGLBufferRef buffer) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->bindBufferBase(target, index, reinterpret_cast<blink::WebGLBuffer*>(buffer));
}

void WebGL2RenderingContextBindBufferRange(WebGLRenderingContextRef handle, GLenum target, GLuint index, WebGLBufferRef buffer, GLintptr offset, GLsizeiptr size) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->bindBufferRange(target, index, reinterpret_cast<blink::WebGLBuffer*>(buffer), offset, size);
}

void* WebGL2RenderingContextGetIndexedParameter(WebGLRenderingContextRef handle, GLenum target, GLuint index) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

void WebGL2RenderingContextGetUniformIndices(WebGLRenderingContextRef handle, WebGLProgramRef program, int uniformNamesCount, const char** uniformNames, GLuint* indices_out) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  Vector<String> names;
  for (int i = 0; i < uniformNamesCount; ++i) {
    names.push_back(String::FromUTF8(uniformNames[i]));
  }
  gl2_context->getUniformIndices(reinterpret_cast<blink::WebGLProgram*>(program), names);
}

void* WebGL2RenderingContextGetActiveUniforms(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint* uniformIndices, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

GLuint WebGL2RenderingContextGetUniformBlockIndex(WebGLRenderingContextRef handle, WebGLProgramRef program, const char* uniformBlockName) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->getUniformBlockIndex(reinterpret_cast<blink::WebGLProgram*>(program), uniformBlockName);
}

void* WebGL2RenderingContextGetActiveUniformBlockParameter(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint uniformBlockIndex, GLenum name) {
  //blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return nullptr;
}

char* WebGL2RenderingContextGetActiveUniformBlockName(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint uniformBlockIndex, int* len) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  String str = gl2_context->getActiveUniformBlockName(reinterpret_cast<blink::WebGLProgram*>(program), uniformBlockIndex);
  *len = str.length();
  char* result = reinterpret_cast<char *>(malloc(str.length()));
  memcpy(result, str.Utf8().data(), str.length());
  return result;
}

void WebGL2RenderingContextUniformBlockBinding(WebGLRenderingContextRef handle, WebGLProgramRef program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->uniformBlockBinding(reinterpret_cast<blink::WebGLProgram*>(program), uniformBlockIndex, uniformBlockBinding);
}

WebGLVertexArrayObjectRef WebGL2RenderingContextCreateVertexArray(WebGLRenderingContextRef handle) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->createVertexArray();
}

void WebGL2RenderingContextDeleteVertexArray(WebGLRenderingContextRef handle, WebGLVertexArrayObjectRef vertexArray) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->deleteVertexArray(reinterpret_cast<blink::WebGLVertexArrayObject*>(vertexArray));
}

GLboolean WebGL2RenderingContextIsVertexArray(WebGLRenderingContextRef handle, WebGLVertexArrayObjectRef vertexArray) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  return gl2_context->isVertexArray(reinterpret_cast<blink::WebGLVertexArrayObject*>(vertexArray));
}

void WebGL2RenderingContextBindVertexArray(WebGLRenderingContextRef handle, WebGLVertexArrayObjectRef vertexArray) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->bindVertexArray(reinterpret_cast<blink::WebGLVertexArrayObject*>(vertexArray));
}

void WebGL2RenderingContextReadPixels0(WebGLRenderingContextRef handle, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, DOMArrayBufferViewRef dstData, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  blink::MaybeShared<blink::DOMArrayBufferView> dst_ref(reinterpret_cast<blink::DOMArrayBufferView *>(dstData));
  gl2_context->readPixels(x, y, width, height, format, type, dst_ref, offset);
}

void WebGL2RenderingContextReadPixels1(WebGLRenderingContextRef handle, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset) {
  blink::WebGL2RenderingContext* gl2_context = reinterpret_cast<blink::WebGL2RenderingContext*>(handle);
  gl2_context->readPixels(x, y, width, height, format, type, offset);
}

WebNavigatorRef WebLocalDomWindowGetNavigator(WebLocalDomWindowRef handle) {
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(handle);
  return dom_window->navigator();
}

LocationRef WebLocalDomWindowGetLocation(WebLocalDomWindowRef handle) {
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(handle);
  return dom_window->location();
}

// class OffscreenCanvasScriptValueSerializer : public blink::V8ScriptValueSerializer {
// public:
//   OffscreenCanvasScriptValueSerializer(blink::ScriptState* script_state, blink::OffscreenCanvas* canvas, const blink::SerializedScriptValue::SerializeOptions& options):
//     V8ScriptValueSerializer(script_state, options),
//     canvas_(canvas) {}

//   ~OffscreenCanvasScriptValueSerializer() override {}

//   bool WriteInternalValue(v8::Local<v8::Context>) override {
//     WriteTag(blink::kOffscreenCanvasTransferTag);
//     //DLOG(INFO) << "OffscreenCanvasScriptValueSerializer:\n" << 
//      "  width: " << canvas_->width() << 
//      "  height: " << canvas_->height() << 
//      "  PlaceholderCanvasId: " << canvas_->PlaceholderCanvasId() << 
//      "  ClientId: " << canvas_->ClientId() << 
//      "  SinkId: " << canvas_->SinkId();
//     WriteUint32(canvas_->width());
//     WriteUint32(canvas_->height());
//     WriteUint32(canvas_->PlaceholderCanvasId());
//     WriteUint32(canvas_->ClientId());
//     WriteUint32(canvas_->SinkId());
//     return true;
//   }

// private: 
//   blink::OffscreenCanvas* canvas_;
// };

class OffscreenCanvasScriptValueDeserializer : public blink::V8ScriptValueDeserializer {
 public:
  OffscreenCanvasScriptValueDeserializer(scoped_refptr<blink::ScriptState> state,
                                         scoped_refptr<blink::SerializedScriptValue> serialized,
                                         const blink::V8ScriptValueDeserializer::Options& options = 
                                         blink::V8ScriptValueDeserializer::Options()):
    V8ScriptValueDeserializer(state, serialized, options) {}

  ~OffscreenCanvasScriptValueDeserializer() override {}

  blink::OffscreenCanvas* Deserialize() {
    blink::ScriptWrappable* result = ReadDOMObject(blink::kOffscreenCanvasTransferTag);
    if (!result)
      return nullptr;
    blink::OffscreenCanvas* canvas = static_cast<blink::OffscreenCanvas *>(result);
     return canvas;
  }

};


WebServiceWorkerContainerRef WebNavigatorGetServiceWorker(WebNavigatorRef handle, WebLocalDomWindowRef window) {
  blink::Navigator* navigator = reinterpret_cast<blink::Navigator*>(handle);
  blink::NonThrowableExceptionState exceptionState;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  return blink::NavigatorServiceWorker::serviceWorker(script_state, *navigator, exceptionState);
}

WebServiceWorkerRef WebServiceWorkerContainerGetController(WebServiceWorkerContainerRef handle) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  return container->controller();
}

ScriptPromiseRef WebServiceWorkerContainerRegister(WebServiceWorkerContainerRef handle, WebLocalDomWindowRef window, int script_type, const char* pattern) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  blink::RegistrationOptions options;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  String pattern_str = String::FromUTF8(pattern);
  options.setScriptType(ScriptTypeToString(script_type));
  // FIXME: if i recall correctly theres a ContextScope for this sort of thing
  v8context->Enter();
  blink::ScriptPromise promise = container->registerServiceWorker(script_state, pattern_str, options);
  v8context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WebServiceWorkerContainerRegisterWithScope(WebServiceWorkerContainerRef handle, WebLocalDomWindowRef window, int script_type, const char* pattern, const char* scope) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  blink::RegistrationOptions options;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  String pattern_str = String::FromUTF8(pattern);
  options.setScope(String::FromUTF8(scope));
  options.setScriptType(ScriptTypeToString(script_type));
  v8context->Enter();
  blink::ScriptPromise promise = container->registerServiceWorker(script_state, pattern_str, options);
  v8context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WebServiceWorkerContainerGetRegistration(WebServiceWorkerContainerRef handle, WebLocalDomWindowRef window, const char* url) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  String url_str;
  if (url != nullptr) {
    url_str = String::FromUTF8(url);
  }
  v8context->Enter();
  blink::ScriptPromise promise = container->getRegistration(script_state, url_str);
  v8context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WebServiceWorkerContainerGetRegistrations(WebServiceWorkerContainerRef handle, WebLocalDomWindowRef window) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  v8context->Enter();
  blink::ScriptPromise promise = container->getRegistrations(script_state);
  v8context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

int WebServiceWorkerContainerSetOnMessageEventListener(WebServiceWorkerContainerRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  container->setOnmessage(listener);
  //bool ok = container->addEventListener(event_type_str, listener);
  //if (ok) {
  //  ref->AddListener(event_type, listener);
  //}
  return 1;//ok ? 1 : 0;
}

//int WebServiceWorkerContainerRemoveEventListener(WebServiceWorkerContainerRef handle, const char* event_type, void* state) {
  // blink::ServiceWorkerContainer* container = reinterpret_cast<blink::ServiceWorkerContainer*>(handle);
  // WebEventListenerImpl* listener = ref->RemoveListener(event_type);
  // if (!listener) {
  //   return 0;
  // }
//  // return ref->unwrap<blink::Node>()->removeEventListener(AtomicString::FromUTF8(event_type), listener) ? 1 : 0;
//  DCHECK(false);
//  return 0;//
//}

char* WebServiceWorkerGetScriptUrl(WebServiceWorkerRef handle, int* len) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  String str = service_worker->scriptURL();
  *len = str.length();
  if (str.length() > 0) {
    char* result = reinterpret_cast<char *>(malloc(str.length()));
    memcpy(result, str.Utf8().data(), str.length());
    return result;
  }
  return nullptr;
}

void WebServiceWorkerPostMessageString(WebServiceWorkerRef handle, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, const char* message_str, int message_len) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> blob_wrapper = blink::ToV8(String::FromUTF8(message_str), v8context->Global(), v8context->GetIsolate());  
  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), blob_wrapper, options, exceptionState);

  // Transferables transferables;
  // if (info.Length() > 1) {
  //   const int transferablesArgIndex = 1;
  //   if (!SerializedScriptValue::ExtractTransferables(info.GetIsolate(), info[transferablesArgIndex], transferablesArgIndex, transferables, exceptionState)) {
  //     return;
  //   }
  // }

  // scoped_refptr<SerializedScriptValue> message;
  // if (instance->CanTransferArrayBuffersAndImageBitmaps()) {
  //   // This instance supports sending array buffers by move semantics.
  //   SerializedScriptValue::SerializeOptions options;
  //   options.transferables = &transferables;
  //   message = SerializedScriptValue::Serialize(info.GetIsolate(), info[0], options, exceptionState);
  //   if (exceptionState.HadException())
  //     return;
  // } else {
  //   // This instance doesn't support sending array buffers and image bitmaps
  //   // by move semantics. Emulate it by copy-and-neuter semantics that sends
  //   // array buffers and image bitmaps via structured clone and then neuters
  //   // the original objects

  //   // Clear references to array buffers and image bitmaps from transferables
  //   // so that the serializer can consider the array buffers as
  //   // non-transferable and serialize them into the message.
  //   ArrayBufferArray transferableArrayBuffers = SerializedScriptValue::ExtractNonSharedArrayBuffers(transferables);
  //   ImageBitmapArray transferableImageBitmaps = transferables.image_bitmaps;
  //   transferables.image_bitmaps.clear();
  //   SerializedScriptValue::SerializeOptions options;
  //   options.transferables = &transferables;
  //   message = SerializedScriptValue::Serialize(info.GetIsolate(), info[0], options, exceptionState);
  //   if (exceptionState.HadException())
  //     return;

  //   // Neuter the original array buffers on the sender context.
  //   SerializedScriptValue::TransferArrayBufferContents(info.GetIsolate(), transferableArrayBuffers, exceptionState);
  //   if (exceptionState.HadException())
  //     return;
  //   // Neuter the original image bitmaps on the sender context.
  //   SerializedScriptValue::TransferImageBitmapContents(info.GetIsolate(), transferableImageBitmaps, exceptionState);
  //   if (exceptionState.HadException())
  //     return;
  // }
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);

  v8context->Exit();
}

void WebServiceWorkerPostMessageBlob(WebServiceWorkerRef handle, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, BlobRef blob) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);
  
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::Blob* blob_handle = reinterpret_cast<blink::Blob *>(blob);
  v8::Local<v8::Value> blob_wrapper = blink::ToV8(blob_handle, v8context->Global(), v8context->GetIsolate());
  DCHECK(!blob_wrapper.IsEmpty());
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), blob_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebServiceWorkerPostMessageArrayBuffer(WebServiceWorkerRef handle, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, DOMArrayBufferRef buffer) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);
  
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::DOMArrayBuffer* array_handle = reinterpret_cast<blink::DOMArrayBuffer *>(buffer);
  v8::Local<v8::Value> array_wrapper = blink::ToV8(array_handle, v8context->Global(), v8context->GetIsolate());
  DCHECK(!array_wrapper.IsEmpty());
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), array_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebServiceWorkerPostMessageSerializedScriptValue(WebServiceWorkerRef handle, WebLocalDomWindowRef window, OwnedSerializedScriptValueRef serialized_script) {
  SerializedScriptValueWrapper* serialized_script_wrapper = reinterpret_cast<SerializedScriptValueWrapper *>(serialized_script);
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);
  
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  serialized_script_wrapper->handle->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, serialized_script_wrapper->handle, serialized_script_wrapper->transferables.message_ports, exceptionState);
  v8context->Exit();
}


void WebServiceWorkerPostMessageStringFromWorker(WebServiceWorkerRef handle, ServiceWorkerGlobalScopeRef scope, MessagePortRef* ports, int port_count, const char* message_str, int message_len) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8context = service_worker_global_scope->ScriptController()->GetContext();

  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> blob_wrapper = blink::ToV8(String::FromUTF8(message_str), v8context->Global(), v8context->GetIsolate());    
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), blob_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebServiceWorkerPostMessageBlobFromWorker(WebServiceWorkerRef handle, ServiceWorkerGlobalScopeRef scope, MessagePortRef* ports, int port_count, BlobRef blob) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8context = service_worker_global_scope->ScriptController()->GetContext();

  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::Blob* blob_handle = reinterpret_cast<blink::Blob *>(blob);
  v8::Local<v8::Value> blob_wrapper = blink::ToV8(blob_handle, v8context->Global(), v8context->GetIsolate());
  DCHECK(!blob_wrapper.IsEmpty());
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), blob_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebServiceWorkerPostMessageArrayBufferFromWorker(WebServiceWorkerRef handle, ServiceWorkerGlobalScopeRef scope, MessagePortRef* ports, int port_count, DOMArrayBufferRef buffer) {
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8context = service_worker_global_scope->ScriptController()->GetContext();

  v8context->Enter();

  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::DOMArrayBuffer* array_handle = reinterpret_cast<blink::DOMArrayBuffer *>(buffer);
  v8::Local<v8::Value> array_wrapper = blink::ToV8(array_handle, v8context->Global(), v8context->GetIsolate());
  DCHECK(!array_wrapper.IsEmpty());
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), array_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebServiceWorkerPostMessageSerializedScriptValueFromWorker(WebServiceWorkerRef handle, ServiceWorkerGlobalScopeRef scope, OwnedSerializedScriptValueRef serialized_script) {
  SerializedScriptValueWrapper* serialized_script_wrapper = reinterpret_cast<SerializedScriptValueWrapper *>(serialized_script);
  blink::ServiceWorker* service_worker = reinterpret_cast<blink::ServiceWorker*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8context = service_worker_global_scope->ScriptController()->GetContext();
  
  v8context->Enter();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "ServiceWorker", "postMessage");
  serialized_script_wrapper->handle->UnregisterMemoryAllocatedWithCurrentScriptContext();
  service_worker->postMessage(scriptState, serialized_script_wrapper->handle, serialized_script_wrapper->transferables.message_ports, exceptionState);
  v8context->Exit();
}

void WebScriptPromiseDestroy(ScriptPromiseRef handle) {
  ScriptPromiseWrapper* promise = reinterpret_cast<ScriptPromiseWrapper*>(handle);
  //DLOG(ERROR) << "WebScriptPromiseDestroy: handle " << promise;
  // in case it survives (and is not handled yet)
  promise->should_be_deleted = true;
  
  if (promise->handled || !promise->activated) {
    //DLOG(ERROR) << "WebScriptPromiseDestroy: promise->handled = " << promise->handled << " promise->activated = " << promise->activated << ". deleting handle " << promise;
    delete promise;
  }
}

ScriptPromiseRef WebScriptPromiseThen(ScriptPromiseRef handle, WebLocalDomWindowRef window, void* state, void(*resolve_cb)(void*, void*, void*), void(*reject_cb)(void*)) {
  ScriptPromiseWrapper* promise = reinterpret_cast<ScriptPromiseWrapper*>(handle);
  promise->activated = true;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  JavascriptFunctionHandler* then_handler = new JavascriptFunctionHandler(isolate, state, resolve_cb);
  JavascriptFunctionHandler* reject_handler = new JavascriptFunctionHandler(isolate, state, reject_cb);
  v8::Local<v8::Value> then_wrapper = then_handler->wrapper_.Get(isolate);
  v8::Local<v8::Value> reject_wrapper = reject_handler->wrapper_.Get(isolate);
  v8::Local<v8::Function> on_fulfilled;
  v8::Local<v8::Function> on_rejected;
  
  if (!v8::Function::New(v8context, 
                         JavascriptFunctionCallback2,
                         then_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_fulfilled)) {
    return nullptr;
  }

  if (!v8::Function::New(v8context,
                         JavascriptFunctionCallback, 
                         reject_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_rejected)) {
    return nullptr;
  }

  v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_fulfilled", v8::String::kNormalString, 12);
  v8::Local<v8::String> v8_reject_name = v8::String::NewFromUtf8(isolate, "on_rejected", v8::String::kNormalString, 10);
  on_fulfilled->SetName(v8_function_name);
  on_rejected->SetName(v8_reject_name);

  blink::ScriptPromise r_promise = promise->promise.Then(std::move(on_fulfilled), std::move(on_rejected));
  v8context->Exit();
  ScriptPromiseWrapper* new_promise = new ScriptPromiseWrapper(promise, std::move(r_promise), then_handler, reject_handler);
  new_promise->activated = true;
  return new_promise;
}

ScriptPromiseRef WebScriptPromiseThenForWorker(ScriptPromiseRef handle, WebWorkerRef worker, void* state, void(*resolve_cb)(void*, void*, void*), void(*reject_cb)(void*)) {
  ScriptPromiseWrapper* promise = reinterpret_cast<ScriptPromiseWrapper*>(handle);
  promise->activated = true;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8context = worker_shim->worker_global_scope()->ScriptController()->GetContext();

  v8context->Enter();
  JavascriptFunctionHandler* then_handler = new JavascriptFunctionHandler(isolate, state, resolve_cb);
  JavascriptFunctionHandler* reject_handler = new JavascriptFunctionHandler(isolate, state, reject_cb);
  v8::Local<v8::Value> then_wrapper = then_handler->wrapper_.Get(isolate);
  v8::Local<v8::Value> reject_wrapper = reject_handler->wrapper_.Get(isolate);
  v8::Local<v8::Function> on_fulfilled;
  v8::Local<v8::Function> on_rejected;
  
  if (!v8::Function::New(v8context, 
                         JavascriptFunctionCallback2,
                         then_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_fulfilled)) {
    return nullptr;
  }

  if (!v8::Function::New(v8context,
                         JavascriptFunctionCallback, 
                         reject_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_rejected)) {
    return nullptr;
  }

  v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_fulfilled", v8::String::kNormalString, 12);
  v8::Local<v8::String> v8_reject_name = v8::String::NewFromUtf8(isolate, "on_rejected", v8::String::kNormalString, 10);
  on_fulfilled->SetName(v8_function_name);
  on_rejected->SetName(v8_reject_name);

  blink::ScriptPromise r_promise = promise->promise.Then(std::move(on_fulfilled), std::move(on_rejected));
  v8context->Exit();
  ScriptPromiseWrapper* new_promise = new ScriptPromiseWrapper(promise, std::move(r_promise), then_handler, reject_handler);
  new_promise->activated = true;
  return new_promise;
}

// void WebScriptPromiseCatch(ScriptPromiseRef handle, WebLocalDomWindowRef window, void* state, void(*cb)(void*)) {
//   ScriptPromiseWrapper* promise = reinterpret_cast<ScriptPromiseWrapper*>(handle);
//   v8::Isolate* isolate = v8::Isolate::GetCurrent();
//   v8::Isolate::Scope isolate_scope(isolate);
//   v8::HandleScope handle_scope(isolate);
//   blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
//   blink::LocalFrame* local_frame = dom_window->GetFrame();
//   blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
//   v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
//   V8FunctionHandler* handler = new V8FunctionHandler(isolate, state, cb);
//   v8::Local<v8::Value> wrapper = handler->wrapper_.Get(isolate);
//   v8::Local<v8::Function> on_exception;
  
//   if (!v8::Function::New(v8context, 
//                          V8FunctionCallback, 
//                          wrapper, 
//                          0,
//                          v8::ConstructorBehavior::kThrow, 
//                          v8::SideEffectType::kHasSideEffect).ToLocal(&on_exception)) {
//     return;
//   }

//   v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_exception", v8::String::kNormalString, 12);
//   on_exception->SetName(v8_function_name);

//   blink::ScriptPromise r_promise = promise->promise.Catch(std::move(on_exception));
// }

WebWorkerRef WebWorkerCreate(WebLocalDomWindowRef window, const char* url) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kConstructionContext, "Worker");

  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);

  String script_url = String::FromUTF8(url);
  blink::WorkerOptions options;
  
  blink::DedicatedWorker* worker = blink::DedicatedWorker::Create(execution_context, script_url, options, exceptionState);
  if (exceptionState.HadException()) {
    return nullptr;
  }
  v8context->Exit();
  return new WebWorkerShim(kWebWorkerClassic, worker, {}, std::string(url));
}

WebWorkerRef WebWorkerCreateNative(WebLocalDomWindowRef window, void* state, WorkerNativeClientCallbacks callbacks) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  //v8context->Enter();

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kConstructionContext, "Worker");

  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);

  String script_url = String::FromUTF8("native.js");
  blink::WorkerOptions options;
  options.setType("native");

  std::unique_ptr<WorkerNativeClientImpl> client = std::make_unique<WorkerNativeClientImpl>(kWorkerNativeClientTypeWorker, state, callbacks);
  
  blink::DedicatedWorker* worker = blink::DedicatedWorker::Create(execution_context, script_url, options, exceptionState, client.get());
  if (exceptionState.HadException()) {
    return nullptr;
  }

  //v8context->Exit();
  return new WebWorkerShim(kWebWorkerNative, worker, std::move(client), std::string());
}

void WebWorkerDestroy(WebWorkerRef reference) {
  delete reinterpret_cast<WebWorkerShim *>(reference);
}

int WebWorkerSetOnMessageEventListener(WebWorkerRef reference, void* state, void(*on_event)(void*,void*)) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  worker_shim->worker()->setOnmessage(listener);
  return 1;
}

void WebWorkerTerminate(WebWorkerRef reference) {
  reinterpret_cast<WebWorkerShim *>(reference)->Terminate();
}

void WebWorkerPostMessageString(WebWorkerRef reference, WebLocalDomWindowRef window, const char* message_str) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "Worker", "postMessage");

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> str_wrapper = blink::ToV8(String::FromUTF8(message_str), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), str_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  worker_shim->worker()->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);

  v8context->Exit();
}

void WebWorkerPostMessageBlob(WebWorkerRef reference, WebLocalDomWindowRef window, BlobRef blob) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "Worker", "postMessage");

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::Blob* blob_handle = reinterpret_cast<blink::Blob *>(blob);
  v8::Local<v8::Value> blob_wrapper = blink::ToV8(blob_handle, v8context->Global(), v8context->GetIsolate());

  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), blob_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  worker_shim->worker()->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);

  v8context->Exit();
}

void WebWorkerPostMessageArrayBuffer(WebWorkerRef handle, WebLocalDomWindowRef window, DOMArrayBufferRef buffer) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  blink::Transferables transferables;

  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "Worker", "postMessage");

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  blink::DOMArrayBuffer* array_handle = reinterpret_cast<blink::DOMArrayBuffer *>(buffer);
  v8::Local<v8::Value> array_wrapper = blink::ToV8(array_handle, v8context->Global(), v8context->GetIsolate());

  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), array_wrapper, options, exceptionState);
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  worker_shim->worker()->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);

  v8context->Exit();
}

void WebWorkerPostMessageSerializedScriptValue(WebWorkerRef handle, WebLocalDomWindowRef window, OwnedSerializedScriptValueRef serialized_script) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  
  v8context->Enter();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  
  blink::ExceptionState exceptionState(v8context->GetIsolate(), blink::ExceptionState::kExecutionContext, "Worker", "postMessage");

  SerializedScriptValueWrapper* serialized_script_wrapper = reinterpret_cast<SerializedScriptValueWrapper *>(serialized_script);

  serialized_script_wrapper->handle->UnregisterMemoryAllocatedWithCurrentScriptContext();
  worker_shim->worker()->postMessage(scriptState, serialized_script_wrapper->handle, serialized_script_wrapper->transferables.message_ports, exceptionState);
  v8context->Exit();
}

int WebWorkerEvaluateScriptSource(WebWorkerRef reference, const char* script_str) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  blink::WorkerOrWorkletScriptController* script_controller = worker_shim->worker_global_scope()->ScriptController();
  blink::ScriptSourceCode source_code(String::FromUTF8(script_str));
  return script_controller->Evaluate(source_code) ? 1 : 0;
}

int WebWorkerGetThreadId(WebWorkerRef reference) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  return worker_shim->GetThreadId();
}

int WebWorkerGetType(WebWorkerRef reference) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  return worker_shim->GetType();
}

void WebWorkerPostTask(WebWorkerRef reference, int64_t microseconds, void* state, void(*cb)(void*)) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  scoped_refptr<base::SingleThreadTaskRunner> task_runner = worker_shim->worker()->GetTaskRunner(blink::TaskType::kUnthrottled);
  task_runner->PostDelayedTask(
    FROM_HERE, 
    base::BindOnce(&WebWorkerPostTaskCallback, 
      base::Unretained(state), 
      base::Unretained(cb)), 
      microseconds == 0 ? base::TimeDelta() : base::TimeDelta::FromMicroseconds(microseconds));
}

JavascriptContextRef WebWorkerGetV8Context(WebWorkerRef reference) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  v8::Local<v8::Context> v8context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  return new mumba::V8Context(isolate, v8context);
}

JavascriptDataRef WebWorkerGetV8Global(WebWorkerRef reference) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  v8::Local<v8::Context> v8context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  // global proxy
  v8::Local<v8::Object> global_proxy = v8context->Global();
  // global
  //v8::Local<v8::Object> global_object = global_proxy->GetPrototype().As<v8::Object>();
  return new mumba::V8Value(isolate, global_proxy);
}

JavascriptDataRef WebWorkerGetV8GlobalWithContext(WebWorkerRef reference, JavascriptContextRef context) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  v8::Local<v8::Context> v8context = reinterpret_cast<mumba::V8Context *>(context)->GetLocal();
  // global proxy
  v8::Local<v8::Object> global_proxy = v8context->Global();
  // global
  //v8::Local<v8::Object> global_object = global_proxy->GetPrototype().As<v8::Object>();
  return new mumba::V8Value(isolate, global_proxy);
}

class RequestAnimationFrameFunction final : public blink::ScriptFunction {
 public:
  static v8::Local<v8::Function> CreateFunction(
      blink::ScriptState* script_state,
      void* state, 
      void(*cb)(void*, double)) {
    RequestAnimationFrameFunction* self =
        new RequestAnimationFrameFunction(script_state, state, cb);
    return self->BindToV8Function();
  }

  void Trace(blink::Visitor* visitor) override {
    blink::ScriptFunction::Trace(visitor);
  }

 private:
  RequestAnimationFrameFunction(blink::ScriptState* script_state,
               void* state, void(*cb)(void*, double))
      : blink::ScriptFunction(script_state),
        state_(state),
        callback_(cb) {}

  blink::ScriptValue Call(blink::ScriptValue value) override {
    if (value.IsEmpty()) {
      callback_(state_, 0.0);
    } else {
      v8::Isolate* isolate = v8::Isolate::GetCurrent();
      v8::HandleScope handle_scope(isolate);
      v8::Local<v8::Value> v8_value = value.V8Value();
      if (v8_value->IsNull() || v8_value->IsUndefined()) {
        callback_(state_, 0.0);
        return value;
      }
      v8::Maybe<double> highres = v8_value->NumberValue(isolate->GetCurrentContext());
      callback_(state_, highres.ToChecked());
    }
    return value;
  }
  void* state_;
  void(*callback_)(void*, double);
};

void WebWorkerRequestAnimationFrame(WebWorkerRef reference, void* state, void(*cb)(void*, double)) {
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  v8context->Enter();
  v8::Local<v8::Function> function = RequestAnimationFrameFunction::CreateFunction(script_state, state, cb); 
  blink::V8FrameRequestCallback* callback = blink::V8FrameRequestCallback::Create(function);
  worker_shim->worker_global_scope()->requestAnimationFrame(callback);
  v8context->Exit();
}

WorkletRef PaintWorkletCreate(WebLocalDomWindowRef window) {
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  DCHECK(local_frame);
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  blink::PaintWorklet* worklet = static_cast<blink::PaintWorklet*>(blink::CSSPaintWorklet::paintWorklet(script_state));
  // force the creation of scopes
  worklet->GetAvailableGlobalScope();
  return new PaintWorkletShim(worklet, dom_window);
  //return new PaintWorkletShim(blink::PaintWorklet::Create(local_frame), dom_window);
}

void PaintWorkletDestroy(WorkletRef reference) {
  PaintWorkletShim* shim = reinterpret_cast<PaintWorkletShim*>(reference);
  delete shim;
}

ScriptPromiseRef PaintWorkletAddModule(WorkletRef reference, const char* module_url) {
  PaintWorkletShim* shim = reinterpret_cast<PaintWorkletShim*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = shim->window;
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  blink::WorkletOptions options;
  blink::ScriptPromise promise = shim->worklet->addModule(
    script_state,
    String::FromUTF8(module_url),
    options);
  return new ScriptPromiseWrapper(std::move(promise));
}

WorkletGlobalScopeRef PaintWorkletGetAvailablePaintWorkletGlobalScope(WorkletRef reference) {
  PaintWorkletShim* shim = reinterpret_cast<PaintWorkletShim*>(reference);
  return shim->worklet->GetAvailableGlobalScope();
}

WorkletGlobalScopeRef PaintWorkletGetPaintWorkletGlobalScopeAt(WorkletRef reference, int index) {
  PaintWorkletShim* shim = reinterpret_cast<PaintWorkletShim*>(reference);
  blink::PaintWorkletGlobalScopeProxy* scope_proxy = static_cast<blink::PaintWorkletGlobalScopeProxy*>(shim->worklet->GetGlobalScope(index));
  return scope_proxy;
}

int PaintWorkletGetPaintWorkletGlobalScopeCount(WorkletRef reference) {
  PaintWorkletShim* shim = reinterpret_cast<PaintWorkletShim*>(reference);
  return shim->worklet->GetNumberOfGlobalScopes();
}

double PaintWorkletGlobalScopeGetDevicePixelRatio(WorkletGlobalScopeRef reference) {
  blink::PaintWorkletGlobalScopeProxy* scope_proxy = reinterpret_cast<blink::PaintWorkletGlobalScopeProxy*>(reference);
  return scope_proxy->global_scope()->devicePixelRatio();
}

// class PaintFunction final : public blink::ScriptFunction {
//  public:
//   static v8::Local<v8::Function> CreateFunction(
//       blink::ScriptState* script_state,
//       void* state, 
//       void(*cb)(void*, void*, void*, void*, const void*)) {
//     PaintFunction* self =
//         new PaintFunction(script_state, state, cb);
//     return self->BindToV8Function();
//   }

//   void Trace(blink::Visitor* visitor) override {
//     blink::ScriptFunction::Trace(visitor);
//   }

//  private:
//   PaintFunction(blink::ScriptState* script_state,
//                void* state, void(*cb)(void*, void*, void*, void*, const void*))
//       : blink::ScriptFunction(script_state),
//         state_(state),
//         callback_(cb) {}

//   blink::ScriptValue Call(blink::ScriptValue value) override {
//     DCHECK(!value.IsEmpty());
//     DCHECK(!v8_value->IsNull());
//     v8::Isolate* isolate = v8::Isolate::GetCurrent();
//     v8::HandleScope handle_scope(isolate);
//     v8::Local<v8::Value> v8_value = value.V8Value();
//     //mumba::V8Value scoped_wrapper(isolate, v8_value);
//     //callback_(state_, &scoped_wrapper);
//     return value;
//   }
//   void* state_;
//   void(*callback_)(void*, void*, void*, void*, const void*);
// };

// void PaintWorkletGlobalScopeRegisterPaint(WorkletGlobalScopeRef reference, WebLocalDomWindowRef window, const char* name, void* state, void(*paintcb)(void*, void*, void*, void*, const void*)) {
//   blink::PaintWorkletGlobalScopeProxy* scope_proxy = reinterpret_cast<blink::PaintWorkletGlobalScopeProxy*>(reference);
//   blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
//   v8::Isolate* isolate = v8::Isolate::GetCurrent();
//   v8::HandleScope handleScope(isolate);
//   blink::LocalFrame* local_frame = dom_window->GetFrame();
//   blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
//   v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
//   blink::ScriptState* script_state = blink::ScriptState::From(v8context);
//   blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "PaintWorkletGlobalScope", "registerPaint");
//   v8::Local<v8::Value> paint_fn = PaintFunction::CreateFunction(script_state, state, paintcb);
//   blink::ScriptValue paint_constructor(script_state, paint_fn);
//   scope_proxy->global_scope()->registerPaint(String::FromUTF8(name),
//                        paint_constructor,
//                        exceptionState);
// }

void PaintWorkletGlobalScopeRegisterPaintNative(WorkletGlobalScopeRef reference, WebLocalDomWindowRef window, const char* name, void* state, void(*paintcb)(void*, void*, void*, void*, const void*)) {
  blink::PaintWorkletGlobalScopeProxy* scope_proxy = reinterpret_cast<blink::PaintWorkletGlobalScopeProxy*>(reference);
  scope_proxy->global_scope()->registerPaint(
    String::FromUTF8(name),
    state,
    paintcb);
}

void PaintSizeGet(PaintSizeRef handle, int* w, int* h) {
  *w = static_cast<int>(reinterpret_cast<blink::PaintSize *>(handle)->width());
  *h = static_cast<int>(reinterpret_cast<blink::PaintSize *>(handle)->height());
}

MessageChannelRef MessageChannelCreate(WebLocalDomWindowRef window) {
  //v8::Isolate* isolate = v8::Isolate::GetCurrent();
  //blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  //blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  blink::NonThrowableExceptionState exceptionState;
  blink::RegistrationOptions options;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handleScope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8context);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  blink::MessageChannel* channel = blink::MessageChannel::Create(execution_context);
  return new MessageChannelWrapper(channel);
}

void MessageChannelDestroy(MessageChannelRef handle) {
  delete reinterpret_cast<MessageChannelWrapper *>(handle);
}

MessagePortRef MessageChannelGetPort1(MessageChannelRef handle) {
  MessageChannelWrapper* wrapper = reinterpret_cast<MessageChannelWrapper*>(handle);
  blink::MessagePort* port = wrapper->channel->port1();
  return port;
}

MessagePortRef MessageChannelGetPort2(MessageChannelRef handle) {
  MessageChannelWrapper* wrapper = reinterpret_cast<MessageChannelWrapper*>(handle);
  blink::MessagePort* port = wrapper->channel->port2();
  return port;
}

OwnedMessagePortRef MessagePortCreateOwning(MessagePortRef ref) {
  return new MessagePortWrapper(reinterpret_cast<blink::MessagePort *>(ref));
}

MessagePortRef MessagePortGetReference(OwnedMessagePortRef owned) {
  return reinterpret_cast<MessagePortWrapper *>(owned)->port;
}

OwnedMessagePortRef MessagePortCreate() {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  blink::ExecutionContext* execution_context = blink::ExecutionContext::From(script_state);
  return new MessagePortWrapper(blink::MessagePort::Create(*execution_context));
}

void MessagePortDestroy(OwnedMessagePortRef handle) {
  delete reinterpret_cast<MessagePortWrapper *>(handle);
}

int MessagePortSetOnMessageEventListener(MessagePortRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
  //AtomicString event_type_str = AtomicString::FromUTF8(event_type);
  // TODO: check if this is not leaking ot going away (this is being managed by oilpan once we set it right?)
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  //bool ok = port->addEventListener(event_type_str, listener);
  //if (ok) {
  //  ref->AddListener(event_type, listener);
  //}
  port->setOnmessage(listener);
  return 1;
}

//int MessagePortRemoveEventListener(MessagePortRef handle, const char* event_type, void* state) {
//  DCHECK(false);
  //blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
  //WebEventListenerImpl* listener = ref->RemoveListener(event_type);
  //if (!listener) {
//  return 0;
  //}
  //return ref->unwrap<blink::Node>()->removeEventListener(AtomicString::FromUTF8(event_type), listener) ? 1 : 0;
//}

void MessagePortPostMessageString(MessagePortRef handle, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, const char* str, int len) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();

  blink::Transferables transferables;

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> str_wrapper = blink::ToV8(String::FromUTF8(str), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), str_wrapper, options, exceptionState);
  
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageStringFromWorker(MessagePortRef handle, WebWorkerRef worker_ref, MessagePortRef* ports, int port_count, const char* str, int len) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  WebWorkerShim* worker = reinterpret_cast<WebWorkerShim*>(worker_ref);
  v8::Local<v8::Context> v8context = worker->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();

  blink::Transferables transferables;

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> str_wrapper = blink::ToV8(String::FromUTF8(str), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), str_wrapper, options, exceptionState);
  
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageStringFromServiceWorker(MessagePortRef handle, ServiceWorkerGlobalScopeRef global_scope, MessagePortRef* ports, int port_count, const char* str, int len) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(global_scope);
  v8::Local<v8::Context> v8context = service_worker_global_scope->ScriptController()->GetContext();
  v8context->Enter();

  blink::Transferables transferables;

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;

  v8::Local<v8::Value> str_wrapper = blink::ToV8(String::FromUTF8(str), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), str_wrapper, options, exceptionState);
  
  message->UnregisterMemoryAllocatedWithCurrentScriptContext();
  
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageBlob(MessagePortRef reference, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, BlobRef blob) {
  blink::Transferables transferables;
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(reference);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  
  v8::Local<v8::Value> value_wrapper = blink::ToV8(reinterpret_cast<blink::Blob *>(blob), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), value_wrapper, options, exceptionState);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageBlobFromWorker(MessagePortRef reference, WebWorkerRef worker, MessagePortRef* ports, int port_count, BlobRef blob) {
  blink::Transferables transferables;
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(reference);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  WebWorkerShim* worker_ref = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8context = worker_ref->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;
  
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  v8::Local<v8::Value> value_wrapper = blink::ToV8(reinterpret_cast<blink::Blob *>(blob), v8context->Global(), v8context->GetIsolate());   
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), value_wrapper, options, exceptionState);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageArrayBuffer(MessagePortRef handle, WebLocalDomWindowRef window, MessagePortRef* ports, int port_count, DOMArrayBufferRef buffer) {
  blink::Transferables transferables;
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  v8::Local<v8::Value> value_wrapper = blink::ToV8(reinterpret_cast<blink::DOMArrayBuffer *>(buffer), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), value_wrapper, options, exceptionState);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageArrayBufferFromWorker(MessagePortRef handle, WebWorkerRef worker, MessagePortRef* ports, int port_count, DOMArrayBufferRef buffer) {
  blink::Transferables transferables;
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  WebWorkerShim* worker_ref = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8context = worker_ref->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();
  for (int i = 0; i < port_count; i++) {
    blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(ports[i]);
    transferables.message_ports.push_back(port);
  }

  blink::SerializedScriptValue::SerializeOptions options;
  options.transferables = &transferables;
  
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  v8::Local<v8::Value> value_wrapper = blink::ToV8(reinterpret_cast<blink::DOMArrayBuffer *>(buffer), v8context->Global(), v8context->GetIsolate());  
  scoped_refptr<blink::SerializedScriptValue> message = blink::SerializedScriptValue::Serialize(v8context->GetIsolate(), value_wrapper, options, exceptionState);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, std::move(message), transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageSerializedScriptValue(MessagePortRef handle, WebLocalDomWindowRef window, OwnedSerializedScriptValueRef serialized_script) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  
  SerializedScriptValueWrapper* message_wrapper = reinterpret_cast<SerializedScriptValueWrapper*>(serialized_script);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, message_wrapper->handle, message_wrapper->transferables.message_ports, exceptionState);
  v8context->Exit();
}

void MessagePortPostMessageSerializedScriptValueFromWorker(MessagePortRef handle, WebWorkerRef worker, OwnedSerializedScriptValueRef serialized_script) {
  blink::MessagePort* port = reinterpret_cast<blink::MessagePort *>(handle);
 
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  WebWorkerShim* worker_ref = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8context = worker_ref->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "MessagePort", "postMessage");
  SerializedScriptValueWrapper* message_wrapper = reinterpret_cast<SerializedScriptValueWrapper*>(serialized_script);
  blink::ScriptState* scriptState = blink::ScriptState::From(v8context);
  port->postMessage(scriptState, message_wrapper->handle, message_wrapper->transferables.message_ports, exceptionState);
  v8context->Exit();
}

void ExtendableMessageEventGetPorts(ExtendableMessageEventRef reference, MessagePortRef* port_refs, int* port_count) {
  //blink::ExtendableMessageEvent* event = reinterpret_cast<blink::ExtendableMessageEvent *>(reference);
}

SerializedScriptValueRef ExtendableMessageEventGetSerializedData(ExtendableMessageEventRef reference) {
  blink::ExtendableMessageEvent* event = reinterpret_cast<blink::ExtendableMessageEvent *>(reference);
  return event->SerializedData();
}

char* ExtendableMessageEventGetDataString(SerializedScriptValueRef reference, WebLocalDomWindowRef window, int* len) {
  blink::ExtendableMessageEvent* event = reinterpret_cast<blink::ExtendableMessageEvent *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handleScope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();

  v8context->Enter();

  auto private_cached_data =
    blink::V8PrivateProperty::GetMessageEventCachedData(isolate);
  v8::Local<v8::Value> result;
  if (private_cached_data.GetOrUndefined(v8context->Global()).ToLocal(&result) &&
      !result->IsUndefined()) {
    return StringifyV8Value(isolate, result, len);
  }

  v8::Local<v8::Value> data;
  if (blink::SerializedScriptValue* serialized_value = event->SerializedData()) {
    blink::MessagePortArray ports = event->ports();
    blink::SerializedScriptValue::DeserializeOptions options;
    options.message_ports = &ports;
    data = serialized_value->Deserialize(isolate, options);
  } else if (blink::DOMWrapperWorld::Current(isolate).IsIsolatedWorld()) {
    //DLOG(ERROR) << "event->SerializedData() IS NULL and we dont have access to MainWorldWrapper()";
  //   v8::Local<v8::Object> main_world_data = blink::V8PrivatePropertyImpl::MainWorldWrapper(isolate, event);
  //   if (!main_world_data.IsEmpty()) {
  //     // TODO(bashi): Enter the main world's ScriptState::Scope while
  //     // serializing the main world's value.
  //     event->SetSerializedData(
  //         blink::SerializedScriptValue::SerializeAndSwallowExceptions(
  //             isolate, main_world_data));
  //     data = event->SerializedData()->Deserialize(isolate);
  //   }
  // }
  } else {
    //DLOG(ERROR) << "event->SerializedData() IS NULL";
  }
  //if (data.IsEmpty())
  //  data = v8::Null(isolate);
  //private_cached_data.Set(v8context->Global(), data);
  
  v8context->Exit();

  return StringifyV8Value(isolate, data, len);
}

void ExtendableEventWaitUntil(WebDOMEventRef handle, ServiceWorkerGlobalScopeRef scope, ScriptPromiseRef promise_ref) {
  blink::ExtendableEvent* event = reinterpret_cast<blink::ExtendableEvent *>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  ScriptPromiseWrapper* promise_wrapper = reinterpret_cast<ScriptPromiseWrapper*>(promise_ref);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ExtendableEvent", "WaitUntil");
  v8_context->Enter();
  event->waitUntil(script_state, promise_wrapper->promise, exceptionState);
  v8_context->Exit();
}

int MessageEventGetDataType(WebDOMEventRef reference) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  return static_cast<int>(event->GetDataType());
}

char* MessageEventGetDataAsString(WebDOMEventRef reference, int* len) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  const String& str = event->DataAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

SerializedScriptValueRef MessageEventGetDataAsSerializedScriptValue(WebDOMEventRef reference) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  return event->DataAsSerializedScriptValue();
}

UnpackedSerializedScriptValueRef MessageEventGetDataAsUnpackedSerializedScriptValue(WebDOMEventRef reference) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  return event->DataAsUnpackedSerializedScriptValue();
}

BlobRef MessageEventGetDataAsBlob(WebDOMEventRef reference) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  return event->DataAsBlob();
}

DOMArrayBufferRef MessageEventGetDataAsArrayBuffer(WebDOMEventRef reference) {
  blink::MessageEvent* event = reinterpret_cast<blink::MessageEvent *>(reference);
  return event->DataAsArrayBuffer();
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateString(WebLocalDomWindowRef window, const char* str, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  String value = String::FromUTF8(str);
  result->Serialize(reinterpret_cast<blink::LocalDOMWindow*>(window), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateStringForWorker(WebWorkerRef worker, const char* str, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  String value = String::FromUTF8(str);
  result->Serialize(reinterpret_cast<WebWorkerShim*>(worker), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateStringForServiceWorker(ServiceWorkerGlobalScopeRef scope, const char* str, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int images_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, images_count);
  String value = String::FromUTF8(str);
  result->Serialize(reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateBlob(WebLocalDomWindowRef window, BlobRef blob, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  blink::Blob* value = reinterpret_cast<blink::Blob *>(blob);
  result->Serialize(reinterpret_cast<blink::LocalDOMWindow*>(window), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateBlobForWorker(WebWorkerRef worker, BlobRef blob, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  blink::Blob* value = reinterpret_cast<blink::Blob *>(blob);
  result->Serialize(reinterpret_cast<WebWorkerShim*>(worker), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateArrayBuffer(WebLocalDomWindowRef window, DOMArrayBufferRef buffer, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  blink::DOMArrayBuffer* value = reinterpret_cast<blink::DOMArrayBuffer *>(buffer);
  result->Serialize(reinterpret_cast<blink::LocalDOMWindow*>(window), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateArrayBufferForWorker(WebWorkerRef worker, DOMArrayBufferRef buffer, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvas, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvas, canvas_count, ports, port_count, images, image_count);
  blink::DOMArrayBuffer* value = reinterpret_cast<blink::DOMArrayBuffer *>(buffer);
  result->Serialize(reinterpret_cast<WebWorkerShim*>(worker), value);
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateOffscreenCanvas(WebLocalDomWindowRef window, OffscreenCanvasRef canvas, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvases, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvases, canvas_count, ports, port_count, images, image_count);
  OffscreenCanvasWrapper* value = reinterpret_cast<OffscreenCanvasWrapper *>(canvas);
  result->Serialize(reinterpret_cast<blink::LocalDOMWindow*>(window), value->canvas.Get());
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateOffscreenCanvasForWorker(WebWorkerRef worker, OffscreenCanvasRef canvas, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvases, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvases, canvas_count, ports, port_count, images, image_count);
  OffscreenCanvasWrapper* value = reinterpret_cast<OffscreenCanvasWrapper *>(canvas);
  result->Serialize(reinterpret_cast<WebWorkerShim*>(worker), value->canvas.Get());
  return result;
}

OwnedSerializedScriptValueRef SerializedScriptValueCreateOffscreenCanvasForServiceWorker(ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef canvas, DOMArrayBufferRef const* arrays, int array_count, OffscreenCanvasRef const* canvases, int canvas_count, MessagePortRef const* ports, int port_count, WebImageBitmapRef const* images, int image_count) {
  SerializedScriptValueWrapper* result = new SerializedScriptValueWrapper(arrays, array_count, canvases, canvas_count, ports, port_count, images, image_count);
  OffscreenCanvasWrapper* value = reinterpret_cast<OffscreenCanvasWrapper *>(canvas);
  result->Serialize(reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope), value->canvas.Get());
  return result;
}

SerializedScriptValueRef SerializedScriptValueFromOwned(OwnedSerializedScriptValueRef owned_ref) {
  return reinterpret_cast<SerializedScriptValueWrapper *>(owned_ref)->handle.get();
}

void SerializedScriptValueDestroy(OwnedSerializedScriptValueRef owned) {
  delete reinterpret_cast<SerializedScriptValueWrapper *>(owned);
}

const uint8_t* SerializedScriptValueGetData(SerializedScriptValueRef reference) {
  return reinterpret_cast<blink::SerializedScriptValue *>(reference)->Data();
}

int SerializedScriptValueGetDataLength(SerializedScriptValueRef reference) {
  return reinterpret_cast<blink::SerializedScriptValue *>(reference)->DataLengthInBytes(); 
}

char* SerializedScriptValueGetString(SerializedScriptValueRef reference, WebLocalDomWindowRef window, int* len) {
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);
  char* result = nullptr;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  result = StringifyV8Value(isolate, v8_value, len);
  v8context->Exit();
  return result;
}

char* SerializedScriptValueGetStringForWorker(SerializedScriptValueRef reference, WebWorkerRef worker_ref, int* len) {
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);
  char* result = nullptr;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  WebWorkerShim* worker = reinterpret_cast<WebWorkerShim*>(worker_ref);
  v8::Local<v8::Context> v8context = worker->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  result = StringifyV8Value(isolate, v8_value, len);
  v8context->Exit();
  return result;
}

char* SerializedScriptValueGetStringForServiceWorker(SerializedScriptValueRef reference, ServiceWorkerGlobalScopeRef scope, int* len) {
  char* result = nullptr;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  DCHECK(isolate);
  v8::HandleScope handle_scope(isolate);
  
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);

  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  
  blink::WorkerOrWorkletScriptController* script_controller = service_worker_global_scope->ScriptController();
  v8::Local<v8::Context> v8_context = script_controller->GetContext();

  v8_context->Enter();
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  result = StringifyV8Value(isolate, v8_value, len);
  v8_context->Exit();

  return result;
}

OffscreenCanvasRef SerializedScriptValueGetOffscreenCanvas(SerializedScriptValueRef reference, WebLocalDomWindowRef window) {
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8context = proxy->ContextIfInitialized();
  v8context->Enter();
  //blink::ScriptState* state = blink::ScriptState::From(v8context);
  //OffscreenCanvasScriptValueDeserializer deserializer(state, serialized_script);
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  if (v8_value.IsEmpty() || v8_value->IsUndefined() || v8_value->IsNull()) {
    //DLOG(ERROR) << "SerializedScriptValueGetOffscreenCanvas: Deserializing offscreen canvas failed";
    v8context->Exit();
    return nullptr;
  }
  blink::OffscreenCanvas* result = blink::V8OffscreenCanvas::ToImpl(v8_value.As<v8::Object>());
  v8context->Exit();
  return new OffscreenCanvasWrapper(result);
}

OffscreenCanvasRef SerializedScriptValueGetOffscreenCanvasForWorker(SerializedScriptValueRef reference, WebWorkerRef worker) {
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  v8context->Enter();
  
  //blink::ScriptState* state = blink::ScriptState::From(v8context);
  //OffscreenCanvasScriptValueDeserializer deserializer(state, serialized_script);
  //blink::OffscreenCanvas* result = deserializer.Deserialize();
  //if (!result) {
  //  //DLOG(ERROR) << "SerializedScriptValueGetOffscreenCanvasForWorker: Deserializing offscreen canvas failed";
  //  v8context->Exit();
  //  return nullptr;
  //}
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  if (v8_value.IsEmpty() || v8_value->IsUndefined() || v8_value->IsNull()) {
    //DLOG(ERROR) << "SerializedScriptValueGetOffscreenCanvas: Deserializing offscreen canvas failed";
    v8context->Exit();
    return nullptr;
  }
  blink::OffscreenCanvas* result = blink::V8OffscreenCanvas::ToImpl(v8_value.As<v8::Object>());
  OffscreenCanvasWrapper* canvas = new OffscreenCanvasWrapper(result);
  v8context->Exit();
  return canvas;
}

OffscreenCanvasRef SerializedScriptValueGetOffscreenCanvasForServiceWorker(SerializedScriptValueRef reference, ServiceWorkerGlobalScopeRef scope) {
  blink::SerializedScriptValue* serialized_script = reinterpret_cast<blink::SerializedScriptValue *>(reference);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();

  v8_context->Enter();
   
  v8::Local<v8::Value> v8_value = serialized_script->Deserialize(isolate);
  if (v8_value.IsEmpty() || v8_value->IsUndefined() || v8_value->IsNull()) {
    //DLOG(ERROR) << "SerializedScriptValueGetOffscreenCanvas: Deserializing offscreen canvas failed";
    v8_context->Exit();
    return nullptr;
  }
  blink::OffscreenCanvas* result = blink::V8OffscreenCanvas::ToImpl(v8_value.As<v8::Object>());
  OffscreenCanvasWrapper* canvas = new OffscreenCanvasWrapper(result);
  v8_context->Exit();
  return canvas;
}

char* UnpackedSerializedScriptValueReadString(UnpackedSerializedScriptValueRef reference, int* len) {
  blink::UnpackedSerializedScriptValue* unserialized_script = reinterpret_cast<blink::UnpackedSerializedScriptValue *>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);

  v8::Local<v8::Value> v8_value = unserialized_script->Deserialize(isolate);
  return StringifyV8Value(isolate, v8_value, len);
}

WebServiceWorkerRegistrationRef WebServiceWorkerRegistrationFromJavascriptValue(JavascriptContextRef context, JavascriptDataRef value) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(value)->GetLocal(isolate);
  return blink::V8ServiceWorkerRegistration::ToImpl(v8value.As<v8::Object>());
}

WebServiceWorkerRef WebServiceWorkerRegistrationGetInstalling(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  return registration->installing();
}

WebServiceWorkerRef WebServiceWorkerRegistrationGetWaiting(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  return registration->waiting();
}

WebServiceWorkerRef WebServiceWorkerRegistrationGetActive(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  return registration->active();
}

char* WebServiceWorkerRegistrationGetScope(WebServiceWorkerRegistrationRef handle, int* len) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  char* result = (char*)malloc(registration->scope().Utf8().length());
  memcpy(result, registration->scope().Utf8().data(), registration->scope().Utf8().length());
  *len = registration->scope().Utf8().length();
  return result;
}

ScriptPromiseRef WebServiceWorkerRegistrationUpdate(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  v8::Isolate* isolate = blink::ToIsolate(registration->GetExecutionContext());
  blink::ScriptState* script_state = blink::ScriptState::From(isolate->GetCurrentContext());
  blink::ScriptPromise promise = registration->update(script_state);
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WebServiceWorkerRegistrationUnregister(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  v8::Isolate* isolate = blink::ToIsolate(registration->GetExecutionContext());
  blink::ScriptState* script_state = blink::ScriptState::From(isolate->GetCurrentContext());
  blink::ScriptPromise promise = registration->unregister(script_state);
  return new ScriptPromiseWrapper(std::move(promise));
}

WebNavigationPreloadManagerRef WebServiceWorkerRegistrationGetNavigationPreload(WebServiceWorkerRegistrationRef handle) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  return registration->navigationPreload();
}

char*  WebServiceWorkerRegistrationGetUpdateViaCache(WebServiceWorkerRegistrationRef handle, int* len) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  char* result = (char*)malloc(registration->updateViaCache().Utf8().length());
  memcpy(result, registration->updateViaCache().Utf8().data(), registration->updateViaCache().Utf8().length());
  *len = registration->updateViaCache().Utf8().length();
  return result;
}

void WebServiceWorkerRegistrationAddOnUpdateFoundEventListener(WebServiceWorkerRegistrationRef handle, void* state, void(*on_updatefound)(void*,void*)) {
  blink::ServiceWorkerRegistration* registration = reinterpret_cast<blink::ServiceWorkerRegistration *>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_updatefound);
  registration->setOnupdatefound(listener);
}

int PromiseBooleanFromJavascriptValue(JavascriptContextRef contextref, JavascriptDataRef valueref) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(valueref)->GetLocal(isolate);
  return v8value.As<v8::Boolean>()->Value();
}

char* PromiseStringFromJavascriptValue(JavascriptContextRef contextref, JavascriptDataRef valueref, int* len) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(valueref)->GetLocal(isolate);
  return StringifyV8Value(isolate, v8value, len);
}

DOMArrayBufferRef PromiseArrayBufferFromJavascriptValue(JavascriptContextRef contextref, JavascriptDataRef valueref) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);  
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(valueref)->GetLocal(isolate);
  blink::DOMArrayBuffer* impl = blink::V8ArrayBuffer::ToImpl(v8::Local<v8::Object>::Cast(v8value));
  return impl;
}

FormDataRef PromiseFormDataFromJavascriptValue(JavascriptContextRef contextref, JavascriptDataRef valueref) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(valueref)->GetLocal(isolate);
  blink::FormData* impl = blink::V8FormData::ToImpl(v8::Local<v8::Object>::Cast(v8value));
  return impl;
}

BlobRef PromiseBlobFromJavascriptValue(JavascriptContextRef contextref, JavascriptDataRef valueref) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> v8value = reinterpret_cast<mumba::V8Value *>(valueref)->GetLocal(isolate);
  blink::Blob* impl = blink::V8Blob::ToImpl(v8::Local<v8::Object>::Cast(v8value));
  return impl;
}

void FetchFromWindow(WebLocalDomWindowRef window, const char* url, void* state, void(*cb)(void*, void*)) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Global", "fetch");

  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();

  blink::RequestInfo info = blink::RequestOrUSVString::FromUSVString(String::FromUTF8(url));
  blink::RequestInit init;

  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise fetch_promise = blink::GlobalFetch::fetch(
    script_state,
    *dom_window,
    info,
    init,
    exceptionState);

  JavascriptFunctionHandler* then_handler = new JavascriptFunctionHandler(isolate, state, cb);
  JavascriptFunctionHandler* reject_handler = new JavascriptFunctionHandler(isolate, state, cb);
  v8::Local<v8::Value> then_wrapper = then_handler->wrapper_.Get(isolate);
  v8::Local<v8::Value> reject_wrapper = reject_handler->wrapper_.Get(isolate);
  v8::Local<v8::Function> on_fulfilled;
  v8::Local<v8::Function> on_rejected;
  
  if (!v8::Function::New(v8_context, 
                         JavascriptFunctionResponseCallback,
                         then_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_fulfilled)) {
    DCHECK(false);
    return;
  }

  if (!v8::Function::New(v8_context,
                         JavascriptFunctionResponseCallback, 
                         reject_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_rejected)) {
    DCHECK(false);
    return;
  }

  v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_fulfilled", v8::String::kNormalString, 12);
  v8::Local<v8::String> v8_reject_name = v8::String::NewFromUtf8(isolate, "on_rejected", v8::String::kNormalString, 10);
  on_fulfilled->SetName(v8_function_name);
  on_rejected->SetName(v8_reject_name);

  blink::ScriptPromise r_promise = fetch_promise.Then(std::move(on_fulfilled), std::move(on_rejected));

  v8_context->Exit();
}

void FetchFromWorker(WebWorkerRef worker_ref, const char* url, void* state, void(*cb)(void*, void*)) {
  WebWorkerShim* worker = reinterpret_cast<WebWorkerShim*>(worker_ref);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Global", "fetch");

  blink::RequestInfo info = blink::RequestOrUSVString::FromUSVString(String::FromUTF8(url));
  blink::RequestInit init;
  v8::Local<v8::Context> v8_context = worker->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise fetch_promise = blink::GlobalFetch::fetch(
    script_state,
    *worker->worker_global_scope(),
    info,
    init,
    exceptionState);

  JavascriptFunctionHandler* then_handler = new JavascriptFunctionHandler(isolate, state, cb);
  JavascriptFunctionHandler* reject_handler = new JavascriptFunctionHandler(isolate, state, cb);
  v8::Local<v8::Value> then_wrapper = then_handler->wrapper_.Get(isolate);
  v8::Local<v8::Value> reject_wrapper = reject_handler->wrapper_.Get(isolate);
  v8::Local<v8::Function> on_fulfilled;
  v8::Local<v8::Function> on_rejected;
  
  if (!v8::Function::New(v8_context, 
                         JavascriptFunctionResponseCallback,
                         then_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_fulfilled)) {
    DCHECK(false);
    return;
  }

  if (!v8::Function::New(v8_context,
                         JavascriptFunctionResponseCallback, 
                         reject_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_rejected)) {
    DCHECK(false);
    return;
  }

  v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_fulfilled", v8::String::kNormalString, 12);
  v8::Local<v8::String> v8_reject_name = v8::String::NewFromUtf8(isolate, "on_rejected", v8::String::kNormalString, 10);
  on_fulfilled->SetName(v8_function_name);
  on_rejected->SetName(v8_reject_name);

  blink::ScriptPromise r_promise = fetch_promise.Then(std::move(on_fulfilled), std::move(on_rejected));
    
  v8_context->Exit();
}

char* HeadersGet(HeadersRef reference, const char* key, int* len) {
  blink::Headers* headers = reinterpret_cast<blink::Headers*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Headers", "get");
  String str = headers->get(String::FromUTF8(key), exceptionState);
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void HeadersSet(HeadersRef reference, const char* key, const char* value) {
  blink::Headers* headers = reinterpret_cast<blink::Headers*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Headers", "set");
  headers->set(String::FromUTF8(key), String::FromUTF8(value), exceptionState);
}

int HeadersHas(HeadersRef reference, const char* key) {
  blink::Headers* headers = reinterpret_cast<blink::Headers*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Headers", "has");
  return headers->has(String::FromUTF8(key), exceptionState) ? 1 : 0;
}

void HeadersAppend(HeadersRef reference, const char* key, const char* value) {
  blink::Headers* headers = reinterpret_cast<blink::Headers*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Headers", "append");
  headers->append(String::FromUTF8(key), String::FromUTF8(value), exceptionState);
}

void HeadersRemove(HeadersRef reference, const char* key) {
  blink::Headers* headers = reinterpret_cast<blink::Headers*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Headers", "remove");
  headers->remove(String::FromUTF8(key), exceptionState);
}

ScriptPromiseRef ReadableStreamReaderClosed(ReadableStreamReaderRef reference, WebWorkerRef worker) {
  blink::ReadableStreamReader* reader = reinterpret_cast<blink::ReadableStreamReader*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = reader->closed(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef ReadableStreamReaderCancel(ReadableStreamReaderRef reference, WebWorkerRef worker) {
  blink::ReadableStreamReader* reader = reinterpret_cast<blink::ReadableStreamReader*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = reader->cancel(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef ReadableStreamReaderRead(ReadableStreamReaderRef reference, WebWorkerRef worker) {
  blink::ReadableStreamReader* reader = reinterpret_cast<blink::ReadableStreamReader*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = reader->read(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

void ReadableStreamReaderReleaseLock(ReadableStreamReaderRef reference, WebWorkerRef worker) {
  blink::ReadableStreamReader* reader = reinterpret_cast<blink::ReadableStreamReader*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "lock");
  reader->releaseLock(state, exceptionState);
}

ReadableStreamReaderRef ReadableStreamGetReader(ReadableStreamRef reference, WebWorkerRef worker) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "getReader");
  blink::ScriptValue result = stream->getReader(state, exceptionState);
  
  blink::ReadableStreamReader* result_stream = blink::V8ReadableStreamDefaultReader::ToImpl(result.V8Value().As<v8::Object>());
  if (exceptionState.HadException()) {
    return nullptr;
  }
  return result_stream;
}

ScriptPromiseRef ReadableStreamCancel(ReadableStreamRef reference, WebWorkerRef worker) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "cancel");
  v8_context->Enter();
  blink::ScriptPromise promise = stream->cancel(state, exceptionState);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ReadableStreamRef ReadableStreamPipeThrough(ReadableStreamRef reference, WebWorkerRef worker, TransformStreamRef transformStream) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  blink::TransformStream* transform = reinterpret_cast<blink::TransformStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "pipeThrough");
  v8::Local<v8::Value> v8Value(blink::ToV8(transform, v8_context->Global(), isolate));
  blink::ScriptValue transform_stream(state, v8Value);
  blink::ScriptValue result = stream->pipeThrough(state,
                                                  transform_stream,
                                                  exceptionState);
  blink::ReadableStream* result_stream = blink::V8ReadableStream::ToImpl(result.V8Value().As<v8::Object>());
  if (exceptionState.HadException()) {
    return nullptr;
  }
  return result_stream;
}

ScriptPromiseRef ReadableStreamPipeTo(ReadableStreamRef reference, WebWorkerRef worker, const char* destination) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "pipeTo");
  v8::Local<v8::Value> destination_wrapper(blink::ToV8(String::FromUTF8(destination), v8_context->Global(), v8_context->GetIsolate()));
  blink::ScriptValue destination_value(state, destination_wrapper);
  v8_context->Enter();
  blink::ScriptPromise promise = stream->pipeTo(state,
                                                destination_value,
                                                exceptionState);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

void ReadableStreamTee(ReadableStreamRef reference, WebWorkerRef worker, ReadableStreamRef* a, ReadableStreamRef* b) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "tee");
  v8_context->Enter();
  stream->Tee(state,
              reinterpret_cast<blink::ReadableStream**>(&a),
              reinterpret_cast<blink::ReadableStream**>(&b),
              exceptionState);
  v8_context->Exit();
}

int ReadableStreamLocked(ReadableStreamRef reference, WebWorkerRef worker) {
  blink::ReadableStream* stream = reinterpret_cast<blink::ReadableStream*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ReadableStream", "locked");
  return stream->locked(state, exceptionState) ? 1 : 0;
}

ScriptPromiseRef WritableStreamWriterClosed(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->closed(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(promise);
}

int WritableStreamWriterGetDesiredSize(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStreamWriter", "desiredSize");
  return writer->desiredSize(state, exceptionState).V8Value().As<v8::Number>()->Value();
}

ScriptPromiseRef WritableStreamWriterReady(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->ready(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WritableStreamWriterAbort(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->abort(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WritableStreamWriterClose(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->close(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

void WritableStreamWriterReleaseLock(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  writer->releaseLock(state);
}

ScriptPromiseRef WritableStreamWriterWrite(WritableStreamWriterRef reference, WebWorkerRef worker) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->write(state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

ScriptPromiseRef WritableStreamWriterWriteChunk(WritableStreamWriterRef reference, WebWorkerRef worker, const uint8_t* bytes, int size) {
  blink::WritableStreamDefaultWriter* writer = reinterpret_cast<blink::WritableStreamDefaultWriter*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8::Local<v8::ArrayBuffer> array_buffer = v8::ArrayBuffer::New(isolate, const_cast<uint8_t*>(bytes), size, v8::ArrayBufferCreationMode::kInternalized);
  v8_context->Enter();
  blink::ScriptPromise promise = writer->write(state, blink::ScriptValue(state, array_buffer));
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

int WritableStreamIsLocked(WritableStreamRef reference, WebWorkerRef worker) {
  blink::WritableStreamNative* stream = reinterpret_cast<blink::WritableStreamNative*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
   blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "locked");
  v8_context->Enter();
  bool r = stream->locked(state, exceptionState);
  v8_context->Exit();
  return r ? 1 : 0;
}

WritableStreamWriterRef WritableStreamGetWriter(WritableStreamRef reference, WebWorkerRef worker) {
  blink::WritableStreamNative* stream = reinterpret_cast<blink::WritableStreamNative*>(reference);
  return const_cast<blink::WritableStreamDefaultWriter *>(stream->Writer());
}

ScriptPromiseRef WritableStreamAbort(WritableStreamRef reference, WebWorkerRef worker) {
  blink::WritableStreamNative* stream = reinterpret_cast<blink::WritableStreamNative*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "abort");
  v8_context->Enter();
  blink::ScriptPromise promise = stream->abort(state, exceptionState);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

void WritableStreamSerialize(WritableStreamRef reference, WebWorkerRef worker, MessagePortRef port) {
  blink::WritableStreamNative* stream = reinterpret_cast<blink::WritableStreamNative*>(reference);
  blink::MessagePort* message_port = reinterpret_cast<blink::MessagePort*>(port);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "serialize");
  v8_context->Enter();
  stream->Serialize(state, message_port, exceptionState);
  v8_context->Exit();
}

WritableStreamRef WritableStreamDeserialize(WebWorkerRef worker, MessagePortRef port) {
  blink::MessagePort* message_port = reinterpret_cast<blink::MessagePort*>(port);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "deserialize");
  v8_context->Enter();
  blink::WritableStreamNative* handle = blink::WritableStreamNative::Deserialize(state, message_port, exceptionState);
  v8_context->Exit();
  return handle;
}

int TransformStreamControllerGetDesiredSize(TransformStreamControllerRef reference, WebWorkerRef worker, int* value) {
  blink::TransformStreamDefaultController* controller = reinterpret_cast<blink::TransformStreamDefaultController*>(reference);
  bool is_null = false;
  double r = controller->desiredSize(is_null);
  if (is_null) {
    *value = 0;
    return 0;
  }
  r = r + 0.5 - (r < 0);
  *value = static_cast<int>(r);
  return 1;
}

void TransformStreamControllerEnqueue(TransformStreamControllerRef reference, WebWorkerRef worker) {
  blink::TransformStreamDefaultController* controller = reinterpret_cast<blink::TransformStreamDefaultController*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "deserialize");
  v8_context->Enter();
  controller->enqueue(state, exceptionState);
  v8_context->Exit();
}

void TransformStreamControllerEnqueueChunk(TransformStreamControllerRef reference, WebWorkerRef worker, const uint8_t* chunk, int chunk_size) {
  blink::TransformStreamDefaultController* controller = reinterpret_cast<blink::TransformStreamDefaultController*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8::Local<v8::ArrayBuffer> array_buffer = v8::ArrayBuffer::New(isolate, const_cast<uint8_t*>(chunk), chunk_size, v8::ArrayBufferCreationMode::kInternalized);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "WritableStream", "deserialize");
  v8_context->Enter();
  controller->enqueue(state, blink::ScriptValue(state, array_buffer), exceptionState);
  v8_context->Exit();
}

void TransformStreamControllerError(TransformStreamControllerRef reference, WebWorkerRef worker) {
  blink::TransformStreamDefaultController* controller = reinterpret_cast<blink::TransformStreamDefaultController*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  controller->error(state);
  v8_context->Exit();
}

void TransformStreamControllerTerminate(TransformStreamControllerRef reference, WebWorkerRef worker) {
  blink::TransformStreamDefaultController* controller = reinterpret_cast<blink::TransformStreamDefaultController*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  controller->terminate(state);
  v8_context->Exit();
}

class TransformStreamWrapper : public blink::TransformStreamTransformer {
public: 
  TransformStreamWrapper(
    scoped_refptr<blink::ScriptState> script_state, 
    blink::TransformStream* stream,
    void* state,
    void(*transform)(void*, const uint8_t*, int, void*), 
    void(*flush)(void*, void*)): 
    stream_(stream), 
    script_state_(script_state),
    state_(state), 
    transform_(transform),
    flush_(flush) {
    
  }

  ~TransformStreamWrapper() override {}
    
  void Transform(v8::Local<v8::Value> value,
                 blink::TransformStreamDefaultControllerInterface* controller,
                 blink::ExceptionState&exception_state ) override {
    const uint8_t* bytes = nullptr;
    transform_(state_, bytes, 0, controller);
  }
  
  void Flush(blink::TransformStreamDefaultControllerInterface* controller,
             blink::ExceptionState& exception_state) override {
    flush_(state_, controller);
  }

  blink::TransformStream* stream() const { return stream_.Get(); }
  
  blink::ScriptState* GetScriptState() override { return script_state_.get(); }
  
  void Trace(blink::Visitor* visitor) override {
    //visitor->Trace(script_state_.get());
  }

private:
  // FIXME: the header on TransformStreamTransformer says its not supposed to hold strong
  //        references no anything
  blink::Member<blink::TransformStream> stream_;
  scoped_refptr<blink::ScriptState> script_state_;
  void* state_;
  void(*transform_)(void*, const uint8_t*, int, void*);
  void(*flush_)(void*, void*);
};

TransformStreamRef TransformStreamCreate(WebWorkerRef worker, void* state, void(*transform)(void*, const uint8_t*, int, void*), void(*flush)(void*, void*)) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  scoped_refptr<blink::ScriptState> script_state(blink::ScriptState::From(v8_context));
  blink::TransformStream* stream = new blink::TransformStream();
  TransformStreamWrapper* wrapper = new TransformStreamWrapper(script_state, stream, state, transform, flush);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "TransformStream", "init");
  wrapper->stream()->Init(wrapper, script_state.get(), exceptionState);
  return wrapper;
}

TransformStreamRef TransformStreamCreateStreams(WebWorkerRef worker, void* state, ReadableStreamRef readable, WritableStreamRef writable, void(*transform)(void*, const uint8_t*, int, void*), void(*flush)(void*, void*)) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  scoped_refptr<blink::ScriptState> script_state(blink::ScriptState::From(v8_context));
  blink::TransformStream* stream = new blink::TransformStream(static_cast<blink::ReadableStream*>(readable), static_cast<blink::WritableStream*>(writable));
  TransformStreamWrapper* wrapper = new TransformStreamWrapper(script_state, stream, state, transform, flush);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "TransformStream", "init");
  wrapper->stream()->Init(wrapper, script_state.get(), exceptionState);
  return wrapper;
}

void TransformStreamDestroy(TransformStreamRef reference) {
  //delete reinterpret_cast<TransformStreamWrapper*>(reference);
}

ReadableStreamRef TransformStreamGetReadable(TransformStreamRef reference, WebWorkerRef worker) {
  TransformStreamWrapper* stream_wrapper = reinterpret_cast<TransformStreamWrapper*>(reference);
  return stream_wrapper->stream()->readable();
}

WritableStreamRef TransformStreamGetWritable(TransformStreamRef reference, WebWorkerRef worker) {
  TransformStreamWrapper* stream_wrapper = reinterpret_cast<TransformStreamWrapper*>(reference);
  return stream_wrapper->stream()->writable();
}

ScriptPromiseRef RequestGetArrayBuffer(RequestRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "arrayBuffer");
  blink::ScriptPromise result = request->arrayBuffer(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef RequestGetBlob(RequestRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "blob");
  blink::ScriptPromise result = request->blob(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef RequestGetFormData(RequestRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "formData");
  blink::ScriptPromise result = request->formData(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef RequestGetJson(RequestRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "json");
  blink::ScriptPromise result = request->json(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef RequestGetText(RequestRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "text");
  blink::ScriptPromise result_promise = request->text(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef RequestGetArrayBufferFromServiceWorker(RequestRef reference, ServiceWorkerGlobalScopeRef scope) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::ServiceWorkerGlobalScope* global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Local<v8::Context> v8_context = global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "arrayBuffer");
  blink::ScriptPromise result_promise = request->arrayBuffer(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef RequestGetBlobFromServiceWorker(RequestRef reference, ServiceWorkerGlobalScopeRef scope) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::ServiceWorkerGlobalScope* global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Local<v8::Context> v8_context = global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "blob");
  blink::ScriptPromise result_promise = request->blob(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef RequestGetFormDataFromServiceWorker(RequestRef reference, ServiceWorkerGlobalScopeRef scope) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::ServiceWorkerGlobalScope* global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Local<v8::Context> v8_context = global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "formData");
  blink::ScriptPromise result_promise = request->formData(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef RequestGetJsonFromServiceWorker(RequestRef reference, ServiceWorkerGlobalScopeRef scope) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::ServiceWorkerGlobalScope* global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Local<v8::Context> v8_context = global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "json");
  blink::ScriptPromise result_promise = request->json(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef RequestGetTextFromServiceWorker(RequestRef reference, ServiceWorkerGlobalScopeRef scope) {
  v8::Local<v8::Value> result_value;
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::ServiceWorkerGlobalScope* global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Local<v8::Context> v8_context = global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Request", "text");
  blink::ScriptPromise result_promise = request->text(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ReadableStreamRef RequestGetReadableBodyStream(RequestRef reference) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  return request->BodyBuffer()->Stream();
}

int RequestHasBody(RequestRef reference) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  return request->HasBody() ? 1 : 0;
}

char* RequestGetMethod(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->method();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetUrl(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->url().GetString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

HeadersRef RequestGetHeaders(RequestRef reference) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  return request->getHeaders();
}

char* RequestGetDestination(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->destination();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetReferrer(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->referrer();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetReferrerPolicy(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->getReferrerPolicy();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetMode(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->mode();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetCredentials(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->credentials();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetCache(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->cache();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetRedirect(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->redirect();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* RequestGetIntegrity(RequestRef reference, int* len) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  String str = request->integrity();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int RequestKeepalive(RequestRef reference) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  return request->keepalive() ? 1 : 0;
}

int RequestIsHistoryNavigation(RequestRef reference) {
  blink::Request* request = reinterpret_cast<blink::Request*>(reference);
  return request->isHistoryNavigation() ? 1 : 0;
}

ScriptPromiseRef ResponseGetArrayBuffer(ResponseRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Response", "arrayBuffer");
  blink::ScriptPromise result = response->arrayBuffer(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef ResponseGetBlob(ResponseRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Response", "blob");
  blink::ScriptPromise result = response->blob(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef ResponseGetFormData(ResponseRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Response", "formData");
  blink::ScriptPromise result = response->formData(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result));
}

ScriptPromiseRef ResponseGetJson(ResponseRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Response", "json");
  blink::ScriptPromise result_promise = response->json(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ScriptPromiseRef ResponseGetText(ResponseRef reference, WebWorkerRef worker) {
  v8::Local<v8::Value> result_value;
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "Response", "text");
  blink::ScriptPromise result_promise = response->text(scriptState, exceptionState);
  return new ScriptPromiseWrapper(std::move(result_promise));
}

ReadableStreamRef ResponseGetBody(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->BodyBuffer()->Stream();
}

char* ResponseGetContentType(ResponseRef reference, int* len) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  String str = response->ContentType();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* ResponseGetMimeType(ResponseRef reference, int* len) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  String str = response->MimeType();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int ResponseGetOk(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->ok() ? 1 : 0;
}

char* ResponseGetStatusText(ResponseRef reference, int* len) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  String str = response->statusText();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

HeadersRef ResponseGetHeaders(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->headers();
}

int ResponseHasBody(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->HasBody() ? 1 : 0;
}

char* ResponseGetType(ResponseRef reference, int* len) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference); 
  String str = response->type();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* ResponseGetUrl(ResponseRef reference, int* len) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  String str = response->url();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int ResponseRedirected(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->redirected() ? 1 : 0;
}

uint16_t ResponseGetStatus(ResponseRef reference) {
  blink::Response* response = reinterpret_cast<blink::Response*>(reference);
  return response->status();
}


WebNavigatorRef ServiceWorkerGlobalScopeGetNavigator(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  v8_context->Enter();
  blink::Navigator* navigator = blink::V8Navigator::ToImpl(v8_context->Global());
  v8_context->Exit();
  return navigator;
}

WebServiceWorkerContainerRef ServiceWorkerGlobalScopeGetServiceWorkerContainer(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  v8_context->Enter();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ServiceWorkerGlobalScope", "GetServiceWorkerContainer");
  blink::Navigator* navigator = blink::V8Navigator::ToImpl(v8_context->Global());
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Exit();
  return blink::NavigatorServiceWorker::serviceWorker(script_state, *navigator, exceptionState);
}

WebServiceWorkerRef ServiceWorkerGlobalScopeGetServiceWorker(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  v8_context->Enter();
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ServiceWorkerGlobalScope", "GetServiceWorkerContainer");
  blink::Navigator* navigator = blink::V8Navigator::ToImpl(v8_context->Global());
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ServiceWorkerContainer* container = blink::NavigatorServiceWorker::serviceWorker(script_state, *navigator, exceptionState);
  v8_context->Exit();
  return container->controller();
}
WebServiceWorkerClientsRef ServiceWorkerGlobalScopeGetClients(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  v8_context->Enter();
  blink::ServiceWorkerClients* impl = blink::V8Clients::ToImpl(v8_context->Global());
  v8_context->Exit();
  return impl;
}

ScriptPromiseRef ServiceWorkerGlobalScopeSkipWaiting(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise result_promise = service_worker_global_scope->skipWaiting(script_state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(result_promise));
}

int ServiceWorkerGlobalScopeIsInstalling(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  return service_worker_global_scope->IsInstalling() ? 1 : 0;
}

void ServiceWorkerGlobalScopeFetch(ServiceWorkerGlobalScopeRef handle, const char* url, void* state, void(*cb)(void*, void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ServiceWorkerGlobalScope", "fetch");
  blink::RequestInfo info = blink::RequestOrUSVString::FromUSVString(String::FromUTF8(url));
  blink::Dictionary init;

  v8_context->Enter();

  blink::ScriptPromise fetch_promise = 
    service_worker_global_scope->fetch(script_state,
                                       info,
                                       init,
                                       exceptionState);

  JavascriptFunctionHandler* then_handler = new JavascriptFunctionHandler(isolate, state, cb);
  JavascriptFunctionHandler* reject_handler = new JavascriptFunctionHandler(isolate, state, cb);
  v8::Local<v8::Value> then_wrapper = then_handler->wrapper_.Get(isolate);
  v8::Local<v8::Value> reject_wrapper = reject_handler->wrapper_.Get(isolate);
  v8::Local<v8::Function> on_fulfilled;
  v8::Local<v8::Function> on_rejected;
  
  if (!v8::Function::New(v8_context, 
                         JavascriptFunctionResponseCallback,
                         then_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_fulfilled)) {
    DCHECK(false);
    return;
  }

  if (!v8::Function::New(v8_context,
                         JavascriptFunctionResponseCallback, 
                         reject_wrapper, 
                         0,
                         v8::ConstructorBehavior::kThrow, 
                         v8::SideEffectType::kHasSideEffect).ToLocal(&on_rejected)) {
    DCHECK(false);
    return;
  }

  v8::Local<v8::String> v8_function_name = v8::String::NewFromUtf8(isolate, "on_fulfilled", v8::String::kNormalString, 12);
  v8::Local<v8::String> v8_reject_name = v8::String::NewFromUtf8(isolate, "on_rejected", v8::String::kNormalString, 10);
  on_fulfilled->SetName(v8_function_name);
  on_rejected->SetName(v8_reject_name);

  blink::ScriptPromise r_promise = fetch_promise.Then(std::move(on_fulfilled), std::move(on_rejected));
    
  v8_context->Exit();
}

void ServiceWorkerGlobalScopeEvaluateScriptSource(ServiceWorkerGlobalScopeRef handle, const char* script_str) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  std::unique_ptr<Vector<char>> cached_meta_data;
  blink::KURL script_url(blink::WebString::FromUTF8("_ServiceWorkerGlobalScopeEvaluateScriptSource_"));
  String source_code = String::FromUTF8(script_str);
  service_worker_global_scope->EvaluateClassicScript(script_url, source_code, std::move(cached_meta_data));
}

int ServiceWorkerGlobalScopeSetOnMessageEventListener(ServiceWorkerGlobalScopeRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  service_worker_global_scope->setOnmessage(listener);
  return 1;
}

int ServiceWorkerGlobalScopeSetOnInstallEventListener(ServiceWorkerGlobalScopeRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  service_worker_global_scope->setOninstall(listener);
  return 1;
}

int ServiceWorkerGlobalScopeSetOnActivateEventListener(ServiceWorkerGlobalScopeRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  service_worker_global_scope->setOnactivate(listener);
  return 1;
}

int ServiceWorkerGlobalScopeSetOnFetchEventListener(ServiceWorkerGlobalScopeRef handle, void* state, void(*on_event)(void*,void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  WebEventListenerImpl* listener = new WebEventListenerImpl(state, on_event);
  service_worker_global_scope->setOnfetch(listener);
  return 1;
}

JavascriptContextRef ServiceWorkerGlobalScopeGetJavascriptContext(ServiceWorkerGlobalScopeRef handle) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  return new mumba::V8Context(isolate, v8_context);
}

void ServiceWorkerGlobalScopePostTask(ServiceWorkerGlobalScopeRef handle, int64_t microseconds, void* state, void(*cb)(void*)) {
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(handle);
  scoped_refptr<base::SingleThreadTaskRunner> task_runner = service_worker_global_scope->GetTaskRunner(blink::TaskType::kUnthrottled);
  task_runner->PostDelayedTask(
    FROM_HERE, 
    base::BindOnce(&WebWorkerPostTaskCallback, 
      base::Unretained(state), 
      base::Unretained(cb)), 
      microseconds == 0 ? base::TimeDelta() : base::TimeDelta::FromMicroseconds(microseconds));
}

void WebServiceWorkerClientsGet(WebServiceWorkerClientsRef handle, ServiceWorkerGlobalScopeRef scope, const char* id, void* state, void(*cb)(void*, void*)) {
  blink::ServiceWorkerClients* clients = reinterpret_cast<blink::ServiceWorkerClients*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise script_promise = clients->get(script_state, String::FromUTF8(id));
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
  v8_context->Exit();
}

void WebServiceWorkerClientsMatchAll(WebServiceWorkerClientRef handle, ServiceWorkerGlobalScopeRef scope, WebServiceWorkerClientRef*, int* count) {
  // blink::ServiceWorkerClients* clients = reinterpret_cast<blink::ServiceWorkerClients*>(handle);
  // blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  // v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  // v8::HandleScope handle_scope(isolate);
  // v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  // v8_context->Enter();
  // v8_context->Exit();
}

void WebServiceWorkerClientsClaim(WebServiceWorkerClientRef handle, ServiceWorkerGlobalScopeRef scope, void* state, void(*cb)(void*, void*)) {
  blink::ServiceWorkerClients* clients = reinterpret_cast<blink::ServiceWorkerClients*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise script_promise = clients->claim(script_state);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
  v8_context->Exit();
}

ScriptPromiseRef WebServiceWorkerClientsClaimPromise(WebServiceWorkerClientRef handle, ServiceWorkerGlobalScopeRef scope) {
  blink::ServiceWorkerClients* clients = reinterpret_cast<blink::ServiceWorkerClients*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise script_promise = clients->claim(script_state);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(script_promise));
}

void WebServiceWorkerClientPostMessage(WebServiceWorkerClientRef handle, ServiceWorkerGlobalScopeRef scope, OwnedSerializedScriptValueRef serialized_script) {
   blink::ServiceWorkerClient* client = reinterpret_cast<blink::ServiceWorkerClient*>(handle);
   blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
   SerializedScriptValueWrapper* serialized_script_wrapper = reinterpret_cast<SerializedScriptValueWrapper *>(serialized_script);
   v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
   blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
   blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ServiceWorkerClient", "postMessage");
   v8_context->Enter();
   serialized_script_wrapper->handle->UnregisterMemoryAllocatedWithCurrentScriptContext();
   client->postMessage(scriptState, serialized_script_wrapper->handle, serialized_script_wrapper->transferables.message_ports, exceptionState);
   v8_context->Exit();
}

RequestRef FetchEventGetRequest(WebDOMEventRef reference) {
  blink::FetchEvent* event = reinterpret_cast<blink::FetchEvent*>(reference);
  return event->request();
}

char* FetchEventGetClientId(WebDOMEventRef reference, int* size) {
  blink::FetchEvent* event = reinterpret_cast<blink::FetchEvent*>(reference);
  String str = event->clientId();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *size = str.Utf8().length();
  return result;
}

int FetchEventIsReload(WebDOMEventRef reference) {
  blink::FetchEvent* event = reinterpret_cast<blink::FetchEvent*>(reference);
  return event->isReload();
}

void FetchEventRespondWith(WebDOMEventRef reference, ServiceWorkerGlobalScopeRef scope, ScriptPromiseRef promise_ref) {
  blink::FetchEvent* event = reinterpret_cast<blink::FetchEvent*>(reference);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  ScriptPromiseWrapper* promise_wrapper = reinterpret_cast<ScriptPromiseWrapper*>(promise_ref);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "ServiceWorkerClient", "postMessage");
  v8_context->Enter();
  event->respondWith(scriptState, promise_wrapper->promise, exceptionState);
  v8_context->Exit();
}

ScriptPromiseRef FetchEventPreloadResponse(WebDOMEventRef reference, ServiceWorkerGlobalScopeRef scope) {
  blink::FetchEvent* event = reinterpret_cast<blink::FetchEvent*>(reference);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* scriptState = blink::ScriptState::From(v8_context);
  v8_context->Enter();
  blink::ScriptPromise promise = event->preloadResponse(scriptState);
  v8_context->Exit();
  return new ScriptPromiseWrapper(std::move(promise));
}

OffscreenCanvasRef OffscreenCanvasCreate(int width, int height) {
  blink::OffscreenCanvas* canvas = blink::OffscreenCanvas::Create(width, height); 
  return new OffscreenCanvasWrapper(canvas);
}

void OffscreenCanvasDestroy(OffscreenCanvasRef handle) {
  delete reinterpret_cast<OffscreenCanvasWrapper *>(handle); 
}

int OffscreenCanvasGetWidth(OffscreenCanvasRef handle) {
  return reinterpret_cast<OffscreenCanvasWrapper *>(handle)->canvas->width();
}

int OffscreenCanvasGetHeight(OffscreenCanvasRef handle) {
  return reinterpret_cast<OffscreenCanvasWrapper *>(handle)->canvas->height();
}

OffscreenCanvasRenderingContext2dRef OffscreenCanvasCreateContext(OffscreenCanvasRef handle, WebLocalDomWindowRef window, const char* type) {
  OffscreenCanvasWrapper* ref = reinterpret_cast<OffscreenCanvasWrapper *>(handle);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::CanvasContextCreationAttributesCore attr;
  blink::CanvasRenderingContext* context = ref->canvas->GetCanvasRenderingContext(
    local_frame->GetDocument(),
    String::FromUTF8(type),
    attr);
  return context;
}

OffscreenCanvasRenderingContext2dRef OffscreenCanvasCreateContextFromWorker(OffscreenCanvasRef handle, WebWorkerRef worker, const char* type) {
  OffscreenCanvasWrapper* ref = reinterpret_cast<OffscreenCanvasWrapper *>(handle);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  blink::CanvasContextCreationAttributesCore attr;
  blink::OffscreenCanvasRenderingContext2D* context = static_cast<blink::OffscreenCanvasRenderingContext2D*>(ref->canvas->GetCanvasRenderingContext(
    worker_shim->worker_global_scope()->GetExecutionContext(),
    String::FromUTF8(type),
    attr));
  // force the creation of the inner Canvas2dResourceProvider
  DCHECK(context->CanCreateCanvas2dResourceProvider());
  return context;
}

OffscreenCanvasRenderingContext2dRef OffscreenCanvasCreateContextFromServiceWorker(OffscreenCanvasRef handle, ServiceWorkerGlobalScopeRef scope, const char* type) {
  OffscreenCanvasWrapper* ref = reinterpret_cast<OffscreenCanvasWrapper *>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  blink::CanvasContextCreationAttributesCore attr;
  blink::OffscreenCanvasRenderingContext2D* context = static_cast<blink::OffscreenCanvasRenderingContext2D*>(ref->canvas->GetCanvasRenderingContext(
    service_worker_global_scope->GetExecutionContext(),
    String::FromUTF8(type),
    attr));
  // force the creation of the inner Canvas2dResourceProvider
  DCHECK(context->CanCreateCanvas2dResourceProvider());
  return context;
}

// void OffscreenCanvasRenderingContext2dDestroy(CanvasRenderingContext2dRef handle) {
  
// }

DisplayItemListRef OffscreenCanvasRenderingContext2dGetDisplayItemList(OffscreenCanvasRenderingContext2dRef handle) {
  cc::PaintRecorder* paint_recorder = GetOffscreenPaintRecorder(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  if (!paint_recorder) {
    DCHECK(false);
    return nullptr;
  }
  return new _DisplayItemList(paint_recorder);
}

int OffscreenCanvasRenderingContext2dGetSaveCount(OffscreenCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->getSaveCount();
}

int OffscreenCanvasRenderingContext2dGetLocalClipBounds(OffscreenCanvasRenderingContext2dRef handle, float* x, float* y, float* width, float* height) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect bounds;
  bool result = canvas->getLocalClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int OffscreenCanvasRenderingContext2dGetDeviceClipBounds(OffscreenCanvasRenderingContext2dRef handle, int* x, int* y, int* width, int* height) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkIRect bounds;
  bool result = canvas->getDeviceClipBounds(&bounds);
  *x = bounds.x();
  *y = bounds.y();
  *width = bounds.width();
  *height = bounds.height();
  return result;
}

int OffscreenCanvasRenderingContext2dIsClipEmpty(OffscreenCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->isClipEmpty();
}

int OffscreenCanvasRenderingContext2dIsClipRect(OffscreenCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->isClipRect();
}

MatrixRef OffscreenCanvasRenderingContext2dTotalMatrix(OffscreenCanvasRenderingContext2dRef handle) {
  return nullptr;
}

void OffscreenCanvasRenderingContext2dFlush(OffscreenCanvasRenderingContext2dRef handle) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->flush();
}

int OffscreenCanvasRenderingContext2dSave(OffscreenCanvasRenderingContext2dRef handle) {
  blink::PaintRenderingContext2D* context = reinterpret_cast<blink::PaintRenderingContext2D *>(handle);
  context->save();
  return 1;
}

int OffscreenCanvasRenderingContext2dSaveLayerRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  return canvas->saveLayer(&rect, flags);
}

int OffscreenCanvasRenderingContext2dSaveLayer(OffscreenCanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  return canvas->saveLayer(nullptr, flags);
}

int OffscreenCanvasRenderingContext2dSaveLayerAlpha(OffscreenCanvasRenderingContext2dRef handle, int alpha) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->saveLayerAlpha(nullptr, alpha, true);
}

int OffscreenCanvasRenderingContext2dSaveLayerAlphaRect(OffscreenCanvasRenderingContext2dRef handle, int alpha, float rx, float ry, float rw, float rh) {
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  return canvas->saveLayerAlpha(&rect,
                                alpha,
                                true);
}

int OffscreenCanvasRenderingContext2dSaveLayerPreserveLCDTextRequestsRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

int OffscreenCanvasRenderingContext2dSaveLayerPreserveLCDTextRequests(OffscreenCanvasRenderingContext2dRef handle, PaintFlagsRef paint) {
  DCHECK(false);
  return 0;
}

void OffscreenCanvasRenderingContext2dRestore(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->restore();
}

void OffscreenCanvasRenderingContext2dRestoreToCount(OffscreenCanvasRenderingContext2dRef handle, int save_count) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->restoreToCount(save_count);
}

void OffscreenCanvasRenderingContext2dTranslate(OffscreenCanvasRenderingContext2dRef handle, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->translate(x, y);
}

void OffscreenCanvasRenderingContext2dScale(OffscreenCanvasRenderingContext2dRef handle, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->scale(x, y);
}

void OffscreenCanvasRenderingContext2dRotate(OffscreenCanvasRenderingContext2dRef handle, float radians) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->rotate(radians);
}

void OffscreenCanvasRenderingContext2dConcatHandle(OffscreenCanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->concat(*m);
}

void OffscreenCanvasRenderingContext2dSetMatrixHandle(OffscreenCanvasRenderingContext2dRef handle, MatrixRef matrix) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkMatrix* m = reinterpret_cast<SkMatrix *>(matrix);
  canvas->setMatrix(*m);
}

void OffscreenCanvasRenderingContext2dClearRect(OffscreenCanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->clearRect(rx, ry, rw, rh);
}

void OffscreenCanvasRenderingContext2dClipRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->clipRect(rect, static_cast<SkClipOp>(clip), anti_alias);
}

void OffscreenCanvasRenderingContext2dClipRRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->clipRRect(r, static_cast<SkClipOp>(clip), anti_alias);
}

void OffscreenCanvasRenderingContext2dClipPath(OffscreenCanvasRenderingContext2dRef handle, PathRef path, int clip, int anti_alias) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->clipPath(reinterpret_cast<SkiaPath*>(path)->ref(), static_cast<SkClipOp>(clip), anti_alias);
}

void OffscreenCanvasRenderingContext2dDrawColor(OffscreenCanvasRenderingContext2dRef handle, int a, int r, int g, int b, int mode) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->drawColor(SkColorSetARGB(a, r, g, b), static_cast<SkBlendMode>(mode));
}

void OffscreenCanvasRenderingContext2dDrawLine(OffscreenCanvasRenderingContext2dRef handle, float sx, float sy, float ex, float ey, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->drawLine(sx, sy, ex, ey, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
} 

void OffscreenCanvasRenderingContext2dDrawIRect(OffscreenCanvasRenderingContext2dRef handle, int rx, int ry, int rw, int rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkIRect rect = SkIRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawIRect(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawOval(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawOval(rect, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawRRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRRect r = SkRRect::MakeRect(SkRect::MakeXYWH(rx, ry, rw, rh));
  canvas->drawRRect(r, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawDRRect(OffscreenCanvasRenderingContext2dRef handle, float ox, float oy, float ow, float oh, float ix, float iy, float iw, float ih, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRRect outer = SkRRect::MakeRect(SkRect::MakeXYWH(ox, oy, ow, oh));
  SkRRect inner = SkRRect::MakeRect(SkRect::MakeXYWH(ix, iy, iw, ih));
  canvas->drawDRRect(outer, inner, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawRoundRect(OffscreenCanvasRenderingContext2dRef handle, float rx, float ry, float rw, float rh, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect rect = SkRect::MakeXYWH(int(rx), int(ry), int(rw), int(rh));
  canvas->drawRoundRect(rect, x, y, reinterpret_cast<PaintFlags *>(paint)->const_ref());
}

void OffscreenCanvasRenderingContext2dDrawPath(OffscreenCanvasRenderingContext2dRef handle, PathRef path, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->drawPath(reinterpret_cast<SkiaPath*>(path)->ref(), reinterpret_cast<PaintFlags *>(paint)->const_ref()); 
}

void OffscreenCanvasRenderingContext2dDrawImage(OffscreenCanvasRenderingContext2dRef handle, ImageRef image, float x, float y, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();
  canvas->drawImage(
    paint_image,
    x, y,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr); 
}

void OffscreenCanvasRenderingContext2dDrawImageRect(
  OffscreenCanvasRenderingContext2dRef handle, 
  ImageRef image, 
  float sx, float sy, float sw, float sh,
  float dx, float dy, float dw, float dh,
  int src_rect_constraint, 
  PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkRect src = SkRect::MakeXYWH(int(sx), int(sy), int(sw), int(sh));
  SkRect dst = SkRect::MakeXYWH(int(dx), int(dy), int(dw), int(dh));
  SkImage* sk_img = reinterpret_cast<SkiaImage*>(image)->handle();
  cc::PaintImage paint_image = cc::PaintImageBuilder::WithDefault()
                        .set_id(cc::PaintImage::GetNextId()) // TODO: fix
                        .set_image(sk_ref_sp(sk_img), cc::PaintImage::GetNextContentId())
                        .TakePaintImage();

  canvas->drawImageRect(
    paint_image, 
    src, 
    dst,
    paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr, 
    static_cast<cc::PaintCanvas::SrcRectConstraint>(src_rect_constraint));
}

void OffscreenCanvasRenderingContext2dDrawBitmap(OffscreenCanvasRenderingContext2dRef handle, BitmapRef bitmap, float left, float top, PaintFlagsRef paint) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  SkBitmap* sk_bmp = reinterpret_cast<SkBitmap *>(bitmap);
  const cc::PaintFlags* flags = paint ? reinterpret_cast<PaintFlags *>(paint)->const_ptr() : nullptr;
  canvas->drawBitmap(
    *sk_bmp,
    left, top,
    flags);
}

void OffscreenCanvasRenderingContext2dDrawTextBlob(OffscreenCanvasRenderingContext2dRef handle, PaintTextBlobRef text, float x, float y, PaintFlagsRef paint) {
  PaintTextBlob* text_blob = reinterpret_cast<PaintTextBlob *>(text);
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  const cc::PaintFlags& local_flags = reinterpret_cast<PaintFlags *>(paint)->const_ref();
  
  canvas->drawTextBlob(
    text_blob->handle(),
    x, y, local_flags);
}

void OffscreenCanvasRenderingContext2dDrawPicture(OffscreenCanvasRenderingContext2dRef handle, PaintRecordRef record) {
  blink::PaintCanvas* canvas = GetOffscreenCanvas(reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle));
  canvas->drawPicture(reinterpret_cast<PaintRecord *>(record)->ref());
}


char* OffscreenCanvasRenderingContext2dGetFillStyle(OffscreenCanvasRenderingContext2dRef handle, int* len) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern fill_result;
  context->fillStyle(fill_result);
  String str = fill_result.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void OffscreenCanvasRenderingContext2dSetFillStyle(OffscreenCanvasRenderingContext2dRef handle, const char* style) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern canvas_style;
  canvas_style.SetString(String::FromUTF8(style));
  context->setFillStyle(canvas_style);
}

void OffscreenCanvasRenderingContext2dFillRect(OffscreenCanvasRenderingContext2dRef handle, int x, int y, int w, int h) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fillRect(x, y, w, h);
}

void OffscreenCanvasRenderingContext2dCommit(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, void* state, void(*cb)(void*, void*)) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "OffscreenCanvasRenderingContext2D", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
  v8_context->Exit();
}

void OffscreenCanvasRenderingContext2dCommitFromWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, void* state, void(*cb)(void*, void*)) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "OffscreenCanvasRenderingContext2D", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
  v8_context->Exit();
}

void OffscreenCanvasRenderingContext2dCommitFromServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, void* state, void(*cb)(void*, void*)) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);

  blink::ExceptionState exceptionState(isolate, blink::ExceptionState::kExecutionContext, "OffscreenCanvasRenderingContext2D", "commit");
  
  v8_context->Enter();
  
  blink::ScriptPromise script_promise = context->commit(script_state, exceptionState);
  script_promise.Then(
      ThenFunction::CreateFunction(script_state, state, cb),
      ThenFunction::CreateFunction(script_state, state, cb));
  
  v8_context->Exit();
}

double OffscreenCanvasRenderingContext2dGetLineWidth(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->lineWidth();
}
int OffscreenCanvasRenderingContext2dGetLineCap(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String cap = context->lineCap();
  if (cap == "butt")
    return 0;
  if (cap == "round")
    return 1;
  if (cap == "square")
    return 2;

  return 0;
}

int OffscreenCanvasRenderingContext2dGetLineJoin(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String join = context->lineJoin();
  if (join == "round")
    return 0;
  if (join == "bevel")
    return 1;
  if (join == "miter")
    return 2;

  return 0;
}

double OffscreenCanvasRenderingContext2dGetMiterLimit(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->miterLimit();
}

void OffscreenCanvasRenderingContext2dGetLineDash(OffscreenCanvasRenderingContext2dRef handle, double** values, int* value_count) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  const Vector<double> dashes = context->getLineDash();
  *values = reinterpret_cast<double*>(malloc(sizeof(double) * dashes.size()));
  for (size_t i = 0; i < dashes.size(); ++i) {
    *values[i] = dashes[i];
  }
  *value_count = dashes.size();
}

void OffscreenCanvasRenderingContext2dSetLineDash(OffscreenCanvasRenderingContext2dRef handle, double* values, int value_count) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  Vector<double> dashes;
  for (size_t i = 0; i < dashes.size(); ++i) {
    dashes.push_back(values[i]);
  }
  context->setLineDash(dashes);
}

double OffscreenCanvasRenderingContext2dGetLineDashOffset(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->lineDashOffset();
}

char* OffscreenCanvasRenderingContext2dGetFont(OffscreenCanvasRenderingContext2dRef handle, int* len) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String str = context->font();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int OffscreenCanvasRenderingContext2dGetTextAlign(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String align = context->textAlign();
  if (align == "start")
    return 0;
  if (align == "end")
    return 1;
  if (align == "left")
    return 2;
  if (align == "right")
    return 3;
  if (align == "center")
    return 4;

  return 0;
}

int OffscreenCanvasRenderingContext2dGetTextBaseline(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String baseline = context->textBaseline();
  if (baseline == "top")
    return 0;
  if (baseline == "hanging")
    return 1;
  if (baseline == "middle")
    return 2;
  if (baseline == "alphabetic")
    return 3;
  if (baseline == "ideographic")
    return 4;
  if (baseline == "bottom")
    return 5;

  return 0;
}

int OffscreenCanvasRenderingContext2dGetTextDirection(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String direction = context->direction();
  if (direction == "inherit")
    return 0;
  if (direction == "rtl")
    return 1;
  if (direction == "ltr")
    return 2;

  return 0;
}

double OffscreenCanvasRenderingContext2dGetGlobalAlpha(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->globalAlpha();
}

void OffscreenCanvasRenderingContext2dSetGlobalAlpha(OffscreenCanvasRenderingContext2dRef handle, double alpha) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setGlobalAlpha(alpha);
}

int OffscreenCanvasRenderingContext2dGetGlobalCompositeOperation(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String composite = context->globalCompositeOperation();

  if (composite == "clear")
    return 0;
  if (composite == "copy")
    return 1;
  if (composite == "source-over")
    return 3;
  if (composite == "source-in")
    return 5;
  if (composite == "source-out")
    return 7;
  if (composite == "source-atop")
    return 9;
  if (composite == "destination-over")
    return 5;
  if (composite == "destination-in")
    return 6;
  if (composite == "destination-out")
    return 8;
  if (composite == "destination-atop")
    return 10;
  if (composite == "xor")
    return 11;
  if (composite == "lighter")
    return 12;
  if (composite == "normal")
    return 3;
  if (composite == "multiply")
    return 24;
  if (composite == "screen")
    return 14;
  if (composite == "overlay")
    return 15;
  if (composite == "darken")
    return 16;
  if (composite == "lighten")
    return 17;
  if (composite == "color-dodge")
    return 18;
  if (composite == "color-burn")
    return 19;
  if (composite == "hard-light")
    return 20;
  if (composite == "soft-light")
    return 21;
  if (composite == "difference")
    return 22;
  if (composite == "exclusion")
    return 23;
  if (composite == "hue")
    return 25;
  if (composite == "saturation")
    return 26;
  if (composite == "color")
    return 27;
  if (composite == "luminosity") 
    return 28;

  return 3;
}

char* OffscreenCanvasRenderingContext2dGetFilter(OffscreenCanvasRenderingContext2dRef handle, int* len) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String str = context->filter();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

int OffscreenCanvasRenderingContext2dImageSmoothingEnabled(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->imageSmoothingEnabled() ? 1 : 0;
}

void OffscreenCanvasRenderingContext2dSetImageSmoothingEnabled(OffscreenCanvasRenderingContext2dRef handle, int value) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setImageSmoothingEnabled(value != 0);
}

int OffscreenCanvasRenderingContext2dGetImageSmoothingQuality(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String quality = context->imageSmoothingQuality();
  if (quality == "low")
    return 0;
  if (quality == "medium")
    return 1;
  if (quality == "high")
    return 2;
  
  return 0;
}

void OffscreenCanvasRenderingContext2dSetImageSmoothingQuality(OffscreenCanvasRenderingContext2dRef handle, int value) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String quality = String::FromUTF8("low");
  switch (value) {
    case 1:
      quality = String::FromUTF8("medium");
      break;
    case 2:
      quality = String::FromUTF8("high");
      break;
  }

  return context->setImageSmoothingQuality(quality);
}

char* OffscreenCanvasRenderingContext2dGetStrokeStyle(OffscreenCanvasRenderingContext2dRef handle, int* len) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  context->strokeStyle(stroke_style);
  String str = stroke_style.GetAsString();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void OffscreenCanvasRenderingContext2dSetStrokeStyle(OffscreenCanvasRenderingContext2dRef handle, const char* style) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::StringOrCanvasGradientOrCanvasPattern stroke_style;
  stroke_style.SetString(String::FromUTF8(style));
  context->setStrokeStyle(stroke_style);
}

double OffscreenCanvasRenderingContext2dGetShadowOffsetX(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->shadowOffsetX();
}

void OffscreenCanvasRenderingContext2dSetShadowOffsetX(OffscreenCanvasRenderingContext2dRef handle, double value) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setShadowOffsetX(value);
}

double OffscreenCanvasRenderingContext2dGetShadowOffsetY(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->shadowOffsetY();
}

void OffscreenCanvasRenderingContext2dSetShadowOffsetY(OffscreenCanvasRenderingContext2dRef handle, double value) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setShadowOffsetX(value);
}

double OffscreenCanvasRenderingContext2dGetShadowBlur(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->shadowBlur();
}

void OffscreenCanvasRenderingContext2dSetShadowBlur(OffscreenCanvasRenderingContext2dRef handle, double value) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setShadowBlur(value);
}

char* OffscreenCanvasRenderingContext2dGetShadowColor(OffscreenCanvasRenderingContext2dRef handle, int* len) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  String str = context->shadowColor();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void OffscreenCanvasRenderingContext2dSetShadowColor(OffscreenCanvasRenderingContext2dRef handle, const char* color) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setShadowColor(String::FromUTF8(color));
}

void OffscreenCanvasRenderingContext2dTransform(OffscreenCanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->transform(a, b, c, d, e, f);
}

void OffscreenCanvasRenderingContext2dSetTransform(OffscreenCanvasRenderingContext2dRef handle, double a, double b, double c, double d, double e, double f) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->setTransform(a, b, c, d, e, f);
}

void OffscreenCanvasRenderingContext2dResetTransform(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->resetTransform();
}

CanvasGradientRef OffscreenCanvasRenderingContext2dCreateLinearGradient(OffscreenCanvasRenderingContext2dRef handle, double x0, double y0, double x1, double y1) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->createLinearGradient(x0, y0, x1, y1);
}

CanvasGradientRef OffscreenCanvasRenderingContext2dCreateRadialGradient(OffscreenCanvasRenderingContext2dRef handle, double x0, double y0, double r0, double x1, double y1, double r1) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  return context->createRadialGradient(x0, y0, r0, x1, y1, r1, state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternImageBitmap(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternImageBitmapForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternImageBitmapForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternCSSImageValue(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternCSSImageValueForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternCSSImageValueForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlImageElement(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlImageElementForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlImageElementForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternSVGImageElement(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternSVGImageElementForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternSVGImageElementForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlCanvasElement(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlCanvasElementForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlCanvasElementForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternOffscreenCanvas(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternOffscreenCanvasForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternOffscreenCanvasForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlVideoElement(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlVideoElementForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

CanvasPatternRef OffscreenCanvasRenderingContext2dCreatePatternHtmlVideoElementForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, const char* repetition_type) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  return context->createPattern(
    script_state,
    image_ref, 
    String::FromUTF8(repetition_type),
    state);
}

void OffscreenCanvasRenderingContext2dStrokeRect(OffscreenCanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->strokeRect(x, y, width, height);
}

void OffscreenCanvasRenderingContext2dBeginPath(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->beginPath();
}

void OffscreenCanvasRenderingContext2dFillWithWinding(OffscreenCanvasRenderingContext2dRef handle, int w) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fill(w == 0 ? "nonzero" : "evenodd");
}

void OffscreenCanvasRenderingContext2dFill(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fill();
}

void OffscreenCanvasRenderingContext2dFillWithPathAndWinding(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path, int w) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path), w == 0 ? "nonzero" : "evenodd");
}

void OffscreenCanvasRenderingContext2dFillWithPath(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fill(reinterpret_cast<blink::Path2D*>(path));
}

void OffscreenCanvasRenderingContext2dStroke(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->stroke();
}

void OffscreenCanvasRenderingContext2dStrokeWithPath(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->stroke(reinterpret_cast<blink::Path2D*>(path));
}

void OffscreenCanvasRenderingContext2dClip(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->clip();
}

void OffscreenCanvasRenderingContext2dClipWithPath(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->clip(reinterpret_cast<blink::Path2D*>(path));
}

int OffscreenCanvasRenderingContext2dIsPointInPathWithWinding(OffscreenCanvasRenderingContext2dRef handle, double x, double y, int w) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->isPointInPath(x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int OffscreenCanvasRenderingContext2dIsPointInPath(OffscreenCanvasRenderingContext2dRef handle, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->isPointInPath(x, y) ? 1 : 0;
}

int OffscreenCanvasRenderingContext2dIsPointInPathWithPathAndWinding(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path, double x, double y, int w) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y, w == 0 ? "nonzero" : "evenodd") ? 1 : 0;
}

int OffscreenCanvasRenderingContext2dIsPointInPathWithPath(OffscreenCanvasRenderingContext2dRef handle, Path2dRef path, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->isPointInPath(reinterpret_cast<blink::Path2D*>(path), x, y) ? 1 : 0;
}

int OffscreenCanvasRenderingContext2dIsPointInStroke(OffscreenCanvasRenderingContext2dRef handle, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  return context->isPointInStroke(x, y) ? 1 : 0;
}
//int OffscreenCanvasRenderingContext2dIsPointInStroke(OffscreenCanvasRenderingContext2dRef handle, int x, int y) {}
void OffscreenCanvasRenderingContext2dFillTextWithWidth(OffscreenCanvasRenderingContext2dRef handle, const char* text, double x, double y, double width) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fillText(String::FromUTF8(text), x, y, width);
}

void OffscreenCanvasRenderingContext2dFillText(OffscreenCanvasRenderingContext2dRef handle, const char* text, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->fillText(String::FromUTF8(text), x, y);
}

void OffscreenCanvasRenderingContext2dStrokeTextWithWidth(OffscreenCanvasRenderingContext2dRef handle, const char* text, double x, double y, double width) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->strokeText(String::FromUTF8(text), x, y, width);
}

void OffscreenCanvasRenderingContext2dStrokeText(OffscreenCanvasRenderingContext2dRef handle, const char* text, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->strokeText(String::FromUTF8(text), x, y);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmap(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  blink::ScriptState* script_state = blink::ScriptState::Current(isolate);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageBitmapSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebImageBitmapRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetImageBitmap(reinterpret_cast<blink::ImageBitmap*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImage(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageCSSImageSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, CSSImageValueRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetCSSImageValue(reinterpret_cast<blink::CSSStyleImageValue*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImage(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLImageSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLImageElement(reinterpret_cast<blink::HTMLImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImage(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageSVGImageSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetSVGImageElement(reinterpret_cast<blink::SVGImageElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvas(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLCanvasSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLCanvasElement(reinterpret_cast<blink::HTMLCanvasElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvas(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageOffscreenCanvasSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, OffscreenCanvasRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetOffscreenCanvas(reinterpret_cast<OffscreenCanvasWrapper *>(image)->canvas);
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideo(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoWH(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoSrcDst(OffscreenCanvasRenderingContext2dRef handle, WebLocalDomWindowRef window, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::LocalDOMWindow* dom_window = reinterpret_cast<blink::LocalDOMWindow*>(window);
  blink::LocalFrame* local_frame = dom_window->GetFrame();
  blink::LocalWindowProxy* proxy = local_frame->GetScriptController().WindowProxy(blink::DOMWrapperWorld::MainWorld());
  v8::Local<v8::Context> v8_context = proxy->ContextIfInitialized();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoWHForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoSrcDstForWorker(OffscreenCanvasRenderingContext2dRef handle, WebWorkerRef worker, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoWHForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double x, double y, double width, double height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dDrawImageHTMLVideoSrcDstForServiceWorker(OffscreenCanvasRenderingContext2dRef handle, ServiceWorkerGlobalScopeRef scope, WebNodeRef image, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::CanvasImageSourceUnion image_ref;
  image_ref.SetHTMLVideoElement(reinterpret_cast<blink::HTMLVideoElement*>(image));
  blink::NonThrowableExceptionState state;
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  context->drawImage(script_state, image_ref, sx, sy, sw, sh, dx, dy, dw, dh, state);
}

WebImageDataRef OffscreenCanvasRenderingContext2dCreateImageData(OffscreenCanvasRenderingContext2dRef handle, int width, int height, int color_format, int storage_format) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(width, height, settings, state);
}

WebImageDataRef OffscreenCanvasRenderingContext2dCreateImageDataWithImageData(OffscreenCanvasRenderingContext2dRef handle, WebImageDataRef data) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  return context->createImageData(reinterpret_cast<blink::ImageData*>(data), state);
}

WebImageDataRef OffscreenCanvasRenderingContext2dCreateImageDataWithBytes(OffscreenCanvasRenderingContext2dRef handle, int width, int height, const uint8_t* data, int count, int color_format, int storage_format) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(blink::DOMUint8ClampedArray::Create(data, count)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef OffscreenCanvasRenderingContext2dCreateImageDataWithUint8Array(OffscreenCanvasRenderingContext2dRef handle, int width, int height, DOMArrayBufferRef data, int color_format, int storage_format) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  blink::ImageDataArray array;
  array.SetUint8ClampedArray(blink::NotShared<blink::DOMUint8ClampedArray>(reinterpret_cast<blink::DOMUint8ClampedArray *>(data)));
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(color_format));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return context->createImageData(array, width, height, settings, state);
}

WebImageDataRef OffscreenCanvasRenderingContext2dGetImageData(OffscreenCanvasRenderingContext2dRef handle, int x, int y, int width, int height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  return context->getImageData(x, y, width, height, state);
}

void OffscreenCanvasRenderingContext2dPutImageData(OffscreenCanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, state);
}

void OffscreenCanvasRenderingContext2dPutImageDataWithDamage(OffscreenCanvasRenderingContext2dRef handle, WebImageDataRef data, int x, int y, int dirty_x, int dirty_y, int dirty_width, int dirty_height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  context->putImageData(reinterpret_cast<blink::ImageData*>(data), x, y, dirty_x, dirty_y, dirty_width, dirty_height, state);
}

void OffscreenCanvasRenderingContext2dClosePath(OffscreenCanvasRenderingContext2dRef handle) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->closePath();
}

void OffscreenCanvasRenderingContext2dMoveTo(OffscreenCanvasRenderingContext2dRef handle, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->moveTo(x, y);
}

void OffscreenCanvasRenderingContext2dLineTo(OffscreenCanvasRenderingContext2dRef handle, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->lineTo(x, y);
}

void OffscreenCanvasRenderingContext2dQuadraticCurveTo(OffscreenCanvasRenderingContext2dRef handle, float cpx, float cpy, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->quadraticCurveTo(cpx, cpy, x, y);
}

void OffscreenCanvasRenderingContext2dBezierCurveTo(OffscreenCanvasRenderingContext2dRef handle, float cp1x, float cp1y, float cp2x, float cp2y, float x, float y) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

void OffscreenCanvasRenderingContext2dArcTo(OffscreenCanvasRenderingContext2dRef handle, float x1, float y1, float x2, float y2, float radius) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  context->arcTo(x1, y1, x2, y2, radius, state);
}

void OffscreenCanvasRenderingContext2dRect(OffscreenCanvasRenderingContext2dRef handle, float x, float y, float width, float height) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  context->rect(x, y, width, height);
}

void OffscreenCanvasRenderingContext2dArc(OffscreenCanvasRenderingContext2dRef handle, float x, float y, float radius, float startAngle, float endAngle, int anticlockwise) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  context->arc(x, y, radius, startAngle, endAngle, anticlockwise != 0, state);
}

void OffscreenCanvasRenderingContext2dEllipse(OffscreenCanvasRenderingContext2dRef handle, float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, int anticlockwise) {
  blink::OffscreenCanvasRenderingContext2D* context = reinterpret_cast<blink::OffscreenCanvasRenderingContext2D*>(handle);
  blink::NonThrowableExceptionState state;
  context->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise != 0, state);
}

Path2dOwnedRef Path2dCreate() {
  return new Path2dWrapper(blink::Path2D::Create());
}

Path2dOwnedRef Path2dCreateWithString(const char* data) {
  return new Path2dWrapper(blink::Path2D::Create(data));
}

void Path2dDestroy(Path2dOwnedRef handle) {
  Path2dWrapper* path = reinterpret_cast<Path2dWrapper*>(handle);
  delete path;
}

Path2dRef Path2dFromOwned(Path2dOwnedRef owned) {
  Path2dWrapper* path = reinterpret_cast<Path2dWrapper*>(owned);
  return path->path.Get();
}

void Path2dAddPath(Path2dRef handle, Path2dRef other_path) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::Path2D* other = reinterpret_cast<blink::Path2D*>(other_path);
  path->addPath(other);
}

void Path2dAddPathWithTransform(Path2dRef handle, Path2dRef other_path, SVGMatrixRef transform) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::Path2D* other = reinterpret_cast<blink::Path2D*>(other_path);
  path->addPath(other, reinterpret_cast<blink::SVGMatrixTearOff*>(transform));
}

void Path2dClosePath(Path2dRef handle) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->closePath();
}

void Path2dMoveTo(Path2dRef handle, float x, float y) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->moveTo(x, y);
}

void Path2dLineTo(Path2dRef handle, float x, float y) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->lineTo(x, y);
}

void Path2dQuadraticCurveTo(Path2dRef handle, float cpx, float cpy, float x, float y) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->quadraticCurveTo(cpx, cpy, x, y);
}

void Path2dBezierCurveTo(Path2dRef handle, float cp1x, float cp1y, float cp2x, float cp2y, float x, float y) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
}

void Path2dArcTo(Path2dRef handle, float x0, float y0, float x1, float y1, float radius) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::NonThrowableExceptionState state;
  path->arcTo(x0, y0, x1, y1, radius, state);
}

void Path2dArc(Path2dRef handle, float x, float y, float radius, float startAngle, float endAngle) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::NonThrowableExceptionState state;
  path->arc(x, y, radius, startAngle, endAngle, false, state);
}

void Path2dArcWithParams(Path2dRef handle, float x, float y, float radius, float startAngle, float endAngle, int anticlockwise) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::NonThrowableExceptionState state;
  path->arc(x, y, radius, startAngle, endAngle, anticlockwise != 0, state);
}

void Path2dEllipse(Path2dRef handle, float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float endAngle) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::NonThrowableExceptionState state;
  path->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, false, state);
}

void Path2dEllipseWithParams(Path2dRef handle, float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, int anticlockwise) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  blink::NonThrowableExceptionState state;
  path->ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise != 0, state);
}

void Path2dRect(Path2dRef handle, float x, float y, float width, float height) {
  blink::Path2D* path = reinterpret_cast<blink::Path2D*>(handle);
  path->rect(x, y, width, height);
}

WebImageDataOwnedRef _WebImageDataCreateSize(int width, int height, int colorspace, int storage_format) {
  blink::ImageDataColorSettings settings;
  settings.setColorSpace(CanvasColorSpaceToString(colorspace));
  settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  return new ImageDataWrapper(blink::ImageData::Create(blink::IntSize(width, height), &settings));
}

WebImageDataOwnedRef _WebImageDataCreateUint8Array(DOMArrayBufferRef bytes, int width, int height, int colorspace, int storage_format) {
  //blink::ImageDataColorSettings settings;
  //settings.setColorSpace(CanvasColorSpaceToString(colorspace));
  //settings.setStorageFormat(CanvasStorageFormatToString(storage_format));
  blink::NonThrowableExceptionState state;
  return new ImageDataWrapper(blink::ImageData::Create(blink::NotShared<blink::DOMUint8ClampedArray>(reinterpret_cast<blink::DOMUint8ClampedArray *>(bytes)), width, height, state));
}

WebImageDataOwnedRef _WebImageDataCreateBytes(const uint8_t* bytes, int bytes_size, int width, int height, int colorspace, int storage_format) {
  blink::NonThrowableExceptionState state;
  return new ImageDataWrapper(blink::ImageData::Create(blink::NotShared<blink::DOMUint8ClampedArray>(blink::DOMUint8ClampedArray::Create(bytes, bytes_size)), width, height, state));
}

void _WebImageDataDestroy(WebImageDataOwnedRef handle) {
  delete reinterpret_cast<ImageDataWrapper *>(handle);
}

void _WebImageDataGetSize(WebImageDataRef reference, int* w, int* h) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  *w = data->width();
  *h = data->height();
}

int _WebImageDataGetWidth(WebImageDataRef reference) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  return data->width();
}

int _WebImageDataGetHeight(WebImageDataRef reference) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  return data->height();
}

int _WebImageDataGetImageDataStorageFormat(WebImageDataRef reference) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  blink::ImageDataStorageFormat format = data->GetImageDataStorageFormat();
  return static_cast<int>(format);
}

DOMArrayBufferRef _WebImageDataGetData(WebImageDataRef reference) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  return data->data();
}

WebImageDataRef _WebImageDataCropRect(WebImageDataRef reference, int width, int height, int flip_y) {
  blink::ImageData* data = reinterpret_cast<blink::ImageData*>(reference);
  return data->CropRect(blink::IntRect(0, 0, width, height), flip_y != 0);
}

// WebImage
WebImageBitmapOwnedRef _WebImageBitmapCreateFromImage(ImageRef image) {
  SkiaImage* skia_image = reinterpret_cast<SkiaImage *>(image);
  return new ImageBitmapWrapper(blink::ImageBitmap::Create(
    blink::StaticBitmapImage::Create(skia_image->ref())));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLImageElementWithRect(WebNodeRef image, WebNodeRef document, int width, int height) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      blink::IntRect(0, 0, width, height),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLImageElement(WebNodeRef image, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(image);
  blink::HTMLImageElement* image_element = ref->unwrap<blink::HTMLImageElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      base::Optional<blink::IntRect>(),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromSVGImageElementWithRect(WebNodeRef svg, WebNodeRef document, int width, int height) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(svg);
  blink::SVGImageElement* image_element = ref->unwrap<blink::SVGImageElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      blink::IntRect(0, 0, width, height),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromSVGImageElement(WebNodeRef svg, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(svg);
  blink::SVGImageElement* image_element = ref->unwrap<blink::SVGImageElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      base::Optional<blink::IntRect>(),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLVideoElementWithRect(WebNodeRef video, WebNodeRef document, int width, int height) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* image_element = ref->unwrap<blink::HTMLVideoElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      blink::IntRect(0, 0, width, height),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLVideoElement(WebNodeRef video, WebNodeRef document) {
  WebNodeWrapper* doc_ref = reinterpret_cast<WebNodeWrapper *>(document);
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(video);
  blink::HTMLVideoElement* image_element = ref->unwrap<blink::HTMLVideoElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      base::Optional<blink::IntRect>(),
      doc_ref->unwrap<blink::Document>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLCanvasElementWithRect(WebNodeRef canvas, int width, int height) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* image_element = ref->unwrap<blink::HTMLCanvasElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      blink::IntRect(0, 0, width, height)));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromHTMLCanvasElement(WebNodeRef canvas) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(canvas);
  blink::HTMLCanvasElement* image_element = ref->unwrap<blink::HTMLCanvasElement>();
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      image_element,
      base::Optional<blink::IntRect>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromOffscreenCanvasWithRect(OffscreenCanvasRef canvas, int width, int height) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<OffscreenCanvasWrapper *>(canvas)->canvas,
      blink::IntRect(0, 0, width, height)));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromOffscreenCanvas(OffscreenCanvasRef canvas) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<OffscreenCanvasWrapper *>(canvas)->canvas,
      base::Optional<blink::IntRect>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromImageDataWithRect(WebImageDataRef data, int width, int height) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<blink::ImageData*>(data),
      blink::IntRect(0, 0, width, height)));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromImageData(WebImageDataRef data) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<blink::ImageData*>(data),
      base::Optional<blink::IntRect>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromImageBitmapWithRect(WebImageBitmapRef bitmap, int width, int height) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<blink::ImageBitmap*>(bitmap),
      blink::IntRect(0, 0, width, height)));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromImageBitmap(WebImageBitmapRef bitmap) {
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      reinterpret_cast<blink::ImageBitmap*>(bitmap),
      base::Optional<blink::IntRect>()));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromUint8Array(
      DOMArrayBufferRef bytes, 
      int width, 
      int height,
      int is_premultiplied, 
      int is_originClean,
      int pixel_format,
      int color_space) {
  blink::CanvasColorParams params;
  params.SetCanvasColorSpace(static_cast<blink::CanvasColorSpace>(color_space));
  params.SetCanvasPixelFormat(static_cast<blink::CanvasPixelFormat>(pixel_format));
  
  blink::DOMUint8ClampedArray* array = reinterpret_cast<blink::DOMUint8ClampedArray *>(bytes);
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      array->Data(),
      width,
      height,
      is_premultiplied != 0,
      is_originClean != 0,
      params));
}

WebImageBitmapOwnedRef _WebImageBitmapCreateFromBytes(
      const uint8_t* bytes, 
      int byteSize,
      int width, 
      int height,
      int is_premultiplied, 
      int is_originClean,
      int pixel_format,
      int color_space) {
  blink::CanvasColorParams params;
  params.SetCanvasColorSpace(static_cast<blink::CanvasColorSpace>(color_space));
  params.SetCanvasPixelFormat(static_cast<blink::CanvasPixelFormat>(pixel_format));
  return new ImageBitmapWrapper(
    blink::ImageBitmap::Create(
      bytes,
      width,
      height,
      is_premultiplied != 0,
      is_originClean != 0,
      params));
}

void _WebImageBitmapDestroy(WebImageBitmapOwnedRef handle) {
  delete reinterpret_cast<ImageBitmapWrapper *>(handle);
}

int _WebImageBitmapGetWidth(WebImageBitmapRef reference)  {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  return bitmap->width();
}

int _WebImageBitmapGetHeight(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  return bitmap->height();
}

void _WebImageBitmapGetSize(WebImageBitmapRef reference, int* w, int* h) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  *w = bitmap->width();
  *h = bitmap->height();
}

int _WebImageBitmapIsNeutered(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  return bitmap->IsNeutered() ? 1 : 0;
}

int _WebImageBitmapIsOriginClean(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  return bitmap->OriginClean() ? 1 : 0;
}

int _WebImageBitmapIsPremultiplied(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  return bitmap->IsPremultiplied() ? 1 : 0;
}

Uint8ArrayBufferRef _WebImageBitmapCopyBitmapData(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  scoped_refptr<WTF::Uint8Array> data = bitmap->CopyBitmapData();
  return new Uint8ArrayWrapper(std::move(data));
}

Uint8ArrayBufferRef _WebImageBitmapCopyBitmapDataWithOptions(WebImageBitmapRef reference, int disposition, int color_type) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  scoped_refptr<WTF::Uint8Array> data = bitmap->CopyBitmapData(static_cast<blink::AlphaDisposition>(disposition),
                                                                 static_cast<blink::DataU8ColorType>(color_type));
  return new Uint8ArrayWrapper(std::move(data));                                                       
}

void _WebImageBitmapClose(WebImageBitmapRef reference) {
  blink::ImageBitmap* bitmap = reinterpret_cast<blink::ImageBitmap*>(reference);
  bitmap->close();
}

WebImageDataRef _WebImageDataFromOwned(WebImageDataOwnedRef handle) {
  return reinterpret_cast<ImageDataWrapper *>(handle)->data.Get();
}

WebImageBitmapRef _WebImageBitmapFromOwned(WebImageBitmapOwnedRef handle) {
  return reinterpret_cast<ImageBitmapWrapper *>(handle)->bmp.Get();
}

void Uint8ArrayBufferDestroy(Uint8ArrayBufferRef handle) {
  delete reinterpret_cast<Uint8ArrayWrapper *>(handle);
}

SVGMatrixOwnedRef SVGMatrixCreate(double a, double b, double c, double d, double e, double f) {
  return new SVGMatrixWrapper(blink::SVGMatrixTearOff::Create(blink::AffineTransform(a, b, c, d, e, f)));
}

void SVGMatrixDestroy(SVGMatrixOwnedRef handle) {
  delete reinterpret_cast<SVGMatrixWrapper *>(handle);
}

SVGMatrixRef SVGMatrixFromOwned(SVGMatrixOwnedRef handle) {
  return reinterpret_cast<SVGMatrixWrapper *>(handle)->matrix.Get();
}

class WebSocketChannelClientImpl : public blink::GarbageCollectedFinalized<WebSocketChannelClientImpl>,
                                   public blink::WebSocketChannelClient {
 USING_GARBAGE_COLLECTED_MIXIN(WebSocketChannelClientImpl)
 public:
  WebSocketChannelClientImpl(
    void* state,
    WebSocketCallbacks callbacks):
   state_(state),
   callbacks_(std::move(callbacks)) {

  }

  ~WebSocketChannelClientImpl() override {}

  const String& subprotocol() const {
    return subprotocol_;
  }

  void DidConnect(const String& subprotocol, const String& extensions) override {
    subprotocol_ = subprotocol;
    callbacks_.on_connect(state_, subprotocol.Utf8().data(), extensions.Utf8().data());
  }

  void DidReceiveTextMessage(const String& message) override {
    callbacks_.on_receive_text_message(state_, message.Utf8().data());
  }

  void DidReceiveBinaryMessage(std::unique_ptr<Vector<char>> message) override {
    data_vec_lock_.Acquire();
    Vector<char>* bytes = message.get();
    data_vec_.push_back(std::move(message));
    callbacks_.on_receive_binary_message(state_, bytes->data(), bytes->size());
    data_vec_lock_.Release();
  }

  void DidError() override {
    callbacks_.on_error(state_);
  }

  void DidConsumeBufferedAmount(uint64_t consumed) override {
    callbacks_.on_consume_buffered_amount(state_, consumed);
  }

  void DidStartClosingHandshake() override {
    callbacks_.on_start_closing_handshake(state_);
  }

  void DidClose(ClosingHandshakeCompletionStatus,
                unsigned short code,
                const String& reason) override {
    callbacks_.on_close(state_, code, reason.Utf8().data());
  }

  void ReleaseBinaryMessage(const char* bytes) {
    data_vec_lock_.Acquire();
    for (auto it = data_vec_.begin(); it != data_vec_.end(); ++ it) {
      // just compare the top address as they should match
      if (bytes == it->get()->data()) {
        data_vec_.erase(it);
        break;
      }
    }
    data_vec_lock_.Release();
  }

  void Trace(blink::Visitor* visitor) override {
    WebSocketChannelClient::Trace(visitor);
  }
  
  void* state_;
  WebSocketCallbacks callbacks_;
  String subprotocol_;
  std::vector<std::unique_ptr<Vector<char>>> data_vec_;
  base::Lock data_vec_lock_;
};

class WebSocketShim {
 public:
  WebSocketShim(
    blink::WebSocketChannel* socket,
    WebSocketChannelClientImpl* client): 
      socket_(socket),
      client_(client) {

  }
  ~WebSocketShim() {}

  WebSocketChannelClientImpl* client() const {
    return client_.Get();
  }

  blink::WebSocketChannel* socket() const {
    return socket_.Get();
  }

  blink::Persistent<blink::WebSocketChannel> socket_;
  blink::Persistent<WebSocketChannelClientImpl> client_;
};

// 
WebSocketRef WebSocketCreate(
  WebNodeRef document_ref,
  void* state, 
  WebSocketCallbacks callbacks) {
  WebNodeWrapper* ref = reinterpret_cast<WebNodeWrapper *>(document_ref);
  blink::Document* document = ref->unwrap<blink::Document>();
  WebSocketChannelClientImpl* client = new WebSocketChannelClientImpl(
    state, 
    std::move(callbacks));
  blink::WebSocketChannel* socket = 
    blink::WebSocketChannelImpl::Create(document, 
                                        client,
                                        blink::SourceLocation::Capture());
  return new WebSocketShim(socket, client);
}

WebSocketRef WebSocketCreateForWorker(
  WebWorkerRef worker,
  void* state, 
  WebSocketCallbacks callbacks) {

  WebWorkerShim* worker_shim = reinterpret_cast<WebWorkerShim*>(worker);
  v8::Local<v8::Context> v8_context = worker_shim->worker_global_scope()->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ExecutionContext* context = blink::ExecutionContext::From(script_state);
  WebSocketChannelClientImpl* client = new WebSocketChannelClientImpl(
    state, 
    std::move(callbacks));
  blink::WebSocketChannel* socket = 
    blink::WebSocketChannelImpl::Create(context, 
                                        client,
                                        blink::SourceLocation::Capture());

  return new WebSocketShim(socket, client);
}

WebSocketRef WebSocketCreateForServiceWorker(
  ServiceWorkerGlobalScopeRef scope,
  void* state, 
  WebSocketCallbacks callbacks) {
  
  blink::ServiceWorkerGlobalScope* service_worker_global_scope = reinterpret_cast<blink::ServiceWorkerGlobalScope*>(scope);
  v8::Isolate* isolate = blink::ToIsolate(service_worker_global_scope->GetExecutionContext());
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> v8_context = service_worker_global_scope->ScriptController()->GetContext();
  blink::ScriptState* script_state = blink::ScriptState::From(v8_context);
  blink::ExecutionContext* context = blink::ExecutionContext::From(script_state);
  
  WebSocketChannelClientImpl* client = new WebSocketChannelClientImpl(
    state, 
    std::move(callbacks));
  blink::WebSocketChannel* socket = 
    blink::WebSocketChannelImpl::Create(context, 
                                        client,
                                        blink::SourceLocation::Capture());
  return new WebSocketShim(socket, client);

}

void WebSocketDestroy(WebSocketRef reference) {
  delete reinterpret_cast<WebSocketShim *>(reference);
}

char* WebSocketGetSubprotocol(WebSocketRef reference, int* len) {
  String str = reinterpret_cast<WebSocketShim *>(reference)->client()->subprotocol();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

void WebSocketConnect(WebSocketRef reference, const char* curl, const char* purl) {
  blink::KURL connect_url(String::FromUTF8(curl));
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Connect(connect_url, String::FromUTF8(purl));
}

void WebSocketSendText(WebSocketRef reference, const char* text) {
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Send(CString(text));
}

void WebSocketSendArrayBuffer(WebSocketRef reference, DOMArrayBufferRef array_buffer, size_t offset, size_t lenght) {
  blink::DOMArrayBuffer* buffer = reinterpret_cast<blink::DOMArrayBuffer*>(array_buffer);
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Send(*buffer, offset, lenght);
}

void WebSocketClose(WebSocketRef reference, int code, const char* reason) {
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Close(code, String::FromUTF8(reason));
}

void WebSocketFail(WebSocketRef reference, const char* reason) {
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Fail(
    String::FromUTF8(reason),
    blink::kErrorMessageLevel,
    blink::SourceLocation::Create(String(), 0, 0, nullptr));
}

void WebSocketDisconnect(WebSocketRef reference) {
  reinterpret_cast<WebSocketShim *>(reference)->socket()->Disconnect();
}

void WebSocketReleaseBinaryMessage(WebSocketRef reference, void* ptr, int size) {
  reinterpret_cast<WebSocketShim *>(reference)->client()->ReleaseBinaryMessage(static_cast<char*>(ptr));
}

char* LocationGetProtocol(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->protocol();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetHost(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->host();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetHostname(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->hostname();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetPort(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->port();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetPathname(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->pathname();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetSearch(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->search();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetHash(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->hash();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}

char* LocationGetOrigin(LocationRef reference, int* len) {
  String str = reinterpret_cast<blink::Location *>(reference)->origin();
  if (str.Utf8().length() == 0) {
    return nullptr;
  }
  char* result = (char*)malloc(str.Utf8().length());
  memcpy(result, str.Utf8().data(), str.Utf8().length());
  *len = str.Utf8().length();
  return result;
}
