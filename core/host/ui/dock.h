// Copyright (c) 2019 Mumba. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MUMBA_HOST_UI_UBER_WINDOW_H_
#define MUMBA_HOST_UI_UBER_WINDOW_H_

#include <string>

#include "base/macros.h"
#include "base/uuid.h"
#include "core/host/application/application_contents_delegate.h"
#include "core/host/ui/tablist/tablist_model.h"
#include "core/host/ui/tablist/tablist_model_observer.h"
#include "core/host/ui/tablist/core_tab_helper_delegate.h"
#include "core/host/ui/dock_application_modal_dialog_manager_delegate.h"
#include "core/host/ui/exclusive_access/exclusive_access_manager.h"
#include "core/host/ui/navigator_params.h"
#include "core/host/notification_observer.h"
#include "core/host/notification_registrar.h"
#include "components/zoom/zoom_observer.h"
#include "ui/base/page_transition_types.h"
#include "ui/base/ui_base_types.h"
#include "ui/base/window_open_disposition.h"
#include "ui/gfx/geometry/rect.h"

namespace gfx {
class Image;
}

namespace host {
class DockWindow;
class DockCommandController;
class PictureInPictureWindowController;
class Workspace;
class DockTablistModelDelegate;

/*
 * Dock is doing the role of the 'Browser' object
 * on the original Chrome
 */
class Dock : public ApplicationContentsDelegate,
             public NotificationObserver,
             public TablistModelObserver,
             public CoreTabHelperDelegate,
             public DockApplicationModalDialogManagerDelegate,
             public zoom::ZoomObserver {
public:
  // SessionService::WindowType mirrors these values.  If you add to this
  // enum, look at SessionService::WindowType to see if it needs to be
  // updated.
  enum Type {
    // If you add a new type, consider updating the test
    // BrowserTest.StartMaximized.
    TYPE_TABBED = 1,
    TYPE_POPUP = 2
  };

  // Possible elements of the Browser window.
  enum WindowFeature {
    FEATURE_NONE = 0,
    FEATURE_TITLEBAR = 1,
    FEATURE_TABSTRIP = 2,
    FEATURE_TOOLBAR = 4,
    FEATURE_LOCATIONBAR = 8,
    FEATURE_BOOKMARKBAR = 16,
    FEATURE_INFOBAR = 32,
    FEATURE_DOWNLOADSHELF = 64,
  };

  // The context for a download blocked notification from
  // OkToCloseWithInProgressDownloads.
  enum DownloadClosePreventionType {
    // Browser close is not blocked by download state.
    DOWNLOAD_CLOSE_OK,

    // The browser is shutting down and there are active downloads
    // that would be cancelled.
    DOWNLOAD_CLOSE_BROWSER_SHUTDOWN,

    // There are active downloads associated with this incognito profile
    // that would be canceled.
    DOWNLOAD_CLOSE_LAST_WINDOW_IN_INCOGNITO_PROFILE,
  };

  struct CreateParams {
    explicit CreateParams(scoped_refptr<Workspace> workspace, const GURL& url, bool user_gesture);
    CreateParams(Type type, scoped_refptr<Workspace> workspace, const GURL& url, bool user_gesture);
    CreateParams(
      Type type, 
      scoped_refptr<Workspace> workspace, 
      const GURL& url, 
      const gfx::Rect& window_bounds, 
      ui::WindowShowState show_state,
      bool user_gesture);
    CreateParams(const CreateParams& other);

    static CreateParams CreateForApp(const std::string& app_name,
                                      const std::string& page_name,
                                     bool trusted_source,
                                     const gfx::Rect& window_bounds,
                                     scoped_refptr<Workspace> workspace,
                                     bool user_gesture);

    //static CreateParams CreateForDevTools(Profile* profile);

    // The browser type.
    Type type = TYPE_POPUP;//TYPE_TABBED;

    // The associated profile.
    //Profile* profile;
    scoped_refptr<Workspace> workspace;

    // Specifies the browser is_trusted_source_ value.
    bool trusted_source = false;

    // flag that signals if its grouped for apps
    bool is_grouped_by_app = true;

    // The bounds of the window to open.
    gfx::Rect initial_bounds = gfx::Rect(800, 600);

    // The workspace the window should open in, if the platform supports it.
    std::string initial_workspace;

    std::string scheme;

    //ui::WindowShowState initial_show_state = ui::SHOW_STATE_DEFAULT;

    ui::WindowShowState initial_show_state = ui::SHOW_STATE_MAXIMIZED;

    bool is_session_restore = false;

    bool tabs_hidden = false;

    // Whether this browser was created by a user gesture. We track this
    // specifically for the multi-user case in chromeos where we can portal
    // windows generated by user gestures differently from ones
    // programmatically created.
    bool user_gesture = false;

    // Supply a custom BrowserWindow implementation, to be used instead of the
    // default. Intended for testing.
    DockWindow* window = nullptr;

   private:
    friend class Dock;

    // The application name that is also the name of the window to the shell.
    // Do not set this value directly, use CreateForApp.
    // This name will be set for:
    // 1) v1 applications launched via an application shortcut or extension API.
    // 2) undocked devtool windows.
    // 3) popup windows spawned from v1 applications.
    std::string app_name;
    std::string page_name;

  };

  static void AttachTabHelpers(ApplicationContents* contents);

  static Dock* GetOrCreate(
    const GURL& url, 
    const CreateParams& params);

  explicit Dock(const CreateParams& params);
  ~Dock() override;

  ui::WindowShowState initial_show_state() const { return initial_show_state_; }
  void set_initial_show_state(ui::WindowShowState initial_show_state) {
    initial_show_state_ = initial_show_state;
  }

  scoped_refptr<Workspace> workspace() const;

  DockWindow* window() const { 
    return window_; 
  }

  Type type() const { 
    return type_; 
  }

  const std::string& scheme() const {
    return scheme_;
  }

  const std::string& app_name() const { 
    return app_name_; 
  }

  const std::string& page_name() const { 
    return page_name_; 
  }

  bool is_grouped_by_app() const {
    return is_grouped_by_app_;
  }

  gfx::Rect override_bounds() const { return override_bounds_; }
  void set_override_bounds(const gfx::Rect& bounds) {
    override_bounds_ = bounds;
  }

  DockCommandController* command_controller() {
    return command_controller_.get();
  }

  TablistModel* tablist_model() {
    return tablist_model_.get();
  }

  ExclusiveAccessManager* exclusive_access_manager() {
    return exclusive_access_manager_.get();
  }

  bool is_type_tabbed() const { return type_ == TYPE_TABBED; }
  bool is_type_popup() const { return type_ == TYPE_POPUP; }

  // Prepares a title string for display (removes embedded newlines, etc).
  static void FormatTitleForDisplay(base::string16* title);

  // Gets the Favicon of the page in the selected tab.
  gfx::Image GetCurrentPageIcon() const;

  // Overridden from TablistModelObserver:
  void TabInsertedAt(TablistModel* tablist_model,
                     ApplicationContents* contents,
                     int index,
                     bool foreground) override;
  void TabClosingAt(TablistModel* tablist_model,
                    ApplicationContents* contents,
                    int index) override;
  void TabDetachedAt(ApplicationContents* contents, int index) override;
  void TabDeactivated(ApplicationContents* contents) override;
  void ActiveTabChanged(ApplicationContents* old_contents,
                        ApplicationContents* new_contents,
                        int index,
                        int reason) override;
  void TabMoved(ApplicationContents* contents,
                int from_index,
                int to_index) override;
  void TabReplacedAt(TablistModel* tablist_model,
                     ApplicationContents* old_contents,
                     ApplicationContents* new_contents,
                     int index) override;
  void TabPinnedStateChanged(TablistModel* tablist_model,
                             ApplicationContents* contents,
                             int index) override;
  void TablistEmpty() override;
  void TablistColorChanged(TablistModel* tablist_model, SkColor color, int tab_index) override;

  // Overridden from ApplicationContents:
  bool CanOverscrollContent() const override;
  KeyboardEventProcessingResult PreHandleKeyboardEvent(
      ApplicationContents* source,
      const NativeWebKeyboardEvent& event) override;
  void HandleKeyboardEvent(
      ApplicationContents* source,
      const NativeWebKeyboardEvent& event) override;
  bool PreHandleGestureEvent(ApplicationContents* source,
                             const blink::WebGestureEvent& event) override;
  bool CanDragEnter(ApplicationContents* source,
                    const common::DropData& data,
                    blink::WebDragOperationsMask operations_allowed) override;
  void OnAudioStateChanged(ApplicationContents* web_contents,
                           bool is_audible) override;
  void UpdatePictureInPictureSurfaceId(const viz::SurfaceId& surface_id,
                                       const gfx::Size& natural_size) override;
  void ExitPictureInPicture() override;

  void OnWindowClosing();

  bool IsMouseLocked() const;

  void UpdateUIForNavigationInTab(ApplicationContents* contents,
                                  ui::PageTransition transition,
                                  NavigateParams::WindowAction action,
                                  bool user_initiated);

  bool TryToCloseWindow(bool skip_beforeunload,
                        const base::Callback<void(bool)>& on_close_confirmed);
  void ResetTryToCloseWindow();
private:
  friend class DockTablistModelDelegate;
  friend class DockWindow;

  class InterstitialObserver;

  // Used to describe why a tab is being detached. This is used by
  // TabDetachedAtImpl.
  enum DetachType {
    // Result of TabDetachedAt.
    DETACH_TYPE_DETACH,

    // Result of TabReplacedAt.
    DETACH_TYPE_REPLACE,

    // Result of the tab strip not having any significant tabs.
    DETACH_TYPE_EMPTY
  };

  void Init(const CreateParams& params);
  void CloseFrame();
  void SetAsDelegate(ApplicationContents* app_contents, bool set_delegate);
  void TabDetachedAtImpl(ApplicationContents* contents,
                         int index,
                         DetachType type);

  void UpdateWindowForLoadingStateChanged(ApplicationContents* source,
                                          bool to_different_document);

    // Overridden from content::ApplicationContentsDelegate:
  ApplicationContents* OpenURL(
    ApplicationContents* source,
    const OpenURLParams& params) override;
  void NavigationStateChanged(ApplicationContents* source,
                              InvalidateTypes changed_flags) override;
  void VisibleSecurityStateChanged(ApplicationContents* source) override;
  void AddNewContents(const std::string& app_name,
                      ApplicationContents* source,
                      ApplicationContents* new_contents,
                      WindowOpenDisposition disposition,
                      const gfx::Rect& initial_rect,
                      bool user_gesture,
                      bool* was_blocked) override;
  void ActivateContents(ApplicationContents* contents) override;
  void LoadingStateChanged(ApplicationContents* source,
                           bool to_different_document) override;
  void CloseContents(ApplicationContents* source) override;
  void MoveContents(ApplicationContents* source,
                    const gfx::Rect& pos) override;
  bool IsPopupOrPanel(const ApplicationContents* source) const override;
  void UpdateTargetURL(ApplicationContents* source, const GURL& url) override;
  void ContentsMouseEvent(ApplicationContents* source,
                          bool motion,
                          bool exited) override;
  void ContentsZoomChange(bool zoom_in) override;
  bool TakeFocus(ApplicationContents* source, bool reverse) override;
  void BeforeUnloadFired(ApplicationContents* source,
                         bool proceed,
                         bool* proceed_to_fire_unload) override;
  bool ShouldFocusLocationBarByDefault(ApplicationContents* source) override;
  bool ShouldCreateApplicationContents(
      ApplicationContents* application_contents,
      ApplicationWindowHost* opener,
      int32_t route_id,
      int32_t main_frame_route_id,
      int32_t main_frame_widget_route_id,
      common::mojom::WindowContainerType window_container_type,
      const GURL& opener_url,
      const std::string& frame_name,
      const GURL& target_url) override;
  void ApplicationContentsCreated(ApplicationContents* source_contents,
                          int opener_render_process_id,
                          int opener_render_frame_id,
                          const std::string& frame_name,
                          const GURL& target_url,
                          ApplicationContents* new_contents) override;
  void ApplicationUnresponsive(
    ApplicationContents* source,
    ApplicationWindowHost* application_host_window) override;
  void ApplicationResponsive(
    ApplicationContents* source,
    ApplicationWindowHost* application_host_window) override;
  void DidNavigateMainFramePostCommit(
      ApplicationContents* app_contents) override;
  bool EmbedsFullscreenWindow() const override;
  void EnterFullscreenMode(ApplicationContents* app_contents) override;
  void ExitFullscreenMode(ApplicationContents* app_contents) override;
  bool IsFullscreenOrPending(
      const ApplicationContents* app_contents) const override;
  blink::WebDisplayMode GetDisplayMode(
      const ApplicationContents* app_contents) const override;
  void RegisterProtocolHandler(ApplicationContents* app_contents,
                               const std::string& protocol,
                               const GURL& url,
                               bool user_gesture) override;
  void UnregisterProtocolHandler(ApplicationContents* app_contents,
                                 const std::string& protocol,
                                 const GURL& url,
                                 bool user_gesture) override;
  void FindReply(ApplicationContents* app_contents,
                 int request_id,
                 int number_of_matches,
                 const gfx::Rect& selection_rect,
                 int active_match_ordinal,
                 bool final_update) override;
  void RequestToLockMouse(ApplicationContents* app_contents,
                          bool user_gesture,
                          bool last_unlocked_by_target) override;
  void LostMouseLock() override;
  void RequestKeyboardLock(ApplicationContents* app_contents,
                           bool esc_key_locked) override;
  void CancelKeyboardLockRequest(ApplicationContents* app_contents) override;
  void RequestMediaAccessPermission(
      ApplicationContents* app_contents,
      const common::MediaStreamRequest& request,
      const common::MediaResponseCallback& callback) override;
  bool CheckMediaAccessPermission(ApplicationWindowHost* app_dock_window,
                                  const GURL& security_origin,
                                  common::MediaStreamType type) override;
  std::string GetDefaultMediaDeviceID(ApplicationContents* app_contents,
                                      common::MediaStreamType type) override;
  gfx::Size GetSizeForNewApplicationWindow(
      ApplicationContents* app_contents) const override;

  // Overridden from NotificationObserver:
  void Observe(int type,
               const NotificationSource& source,
               const NotificationDetails& details) override;

  // ZoomObserver
  void OnZoomChanged(const zoom::ZoomController::ZoomChangedEventData& data) override;

  void ScheduleUIUpdate(ApplicationContents* source,
                        unsigned changed_flags);
  void ProcessPendingUIUpdates();
  void RemoveScheduledUpdatesFor(ApplicationContents* contents);

  void WindowFullscreenStateWillChange();
  void WindowFullscreenStateChanged();

  void OnWindowDidShow();

  void UpdateToolbar(bool should_restore_state);

  NotificationRegistrar registrar_;
  //std::string name_;
  scoped_refptr<Workspace> workspace_;
  DockWindow* window_;
  std::string app_name_;
  std::string page_name_;
  gfx::Rect override_bounds_;
  ui::WindowShowState initial_show_state_;
  const std::string initial_workspace_;

  std::unique_ptr<TablistModelDelegate> tablist_model_delegate_;
  std::unique_ptr<TablistModel> tablist_model_;

  std::vector<InterstitialObserver*> interstitial_observers_;

  const Type type_;

  typedef std::map<const ApplicationContents*, int> UpdateMap;

  // Maps from WebContents to pending UI updates that need to be processed.
  // We don't update things like the URL or tab title right away to avoid
  // flickering and extra painting.
  // See ScheduleUIUpdate and ProcessPendingUIUpdates.
  UpdateMap scheduled_updates_;

  bool window_has_shown_;

  bool is_grouped_by_app_;

  std::string scheme_;

  std::unique_ptr<DockCommandController> command_controller_;

  std::unique_ptr<PictureInPictureWindowController> pip_window_controller_;

  std::unique_ptr<ExclusiveAccessManager> exclusive_access_manager_;

  // The following factory is used for update coalescing.
  base::WeakPtrFactory<Dock> dock_updater_factory_;

  base::WeakPtrFactory<Dock> weak_factory_;

  DISALLOW_COPY_AND_ASSIGN(Dock);
};

void Navigate(NavigateParams* params);
void LoadURLInContents(ApplicationContents* target_contents,
                       const GURL& url,
                       const NavigateParams& params);

}

#endif
