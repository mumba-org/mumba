// Copyright 2021 Mumba. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ml;

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
enum Version {
  // proto3 requires the first enum value to be zero.
  // We add this just to appease the compiler.
  _START_VERSION = 0,
  // The version field is always serialized and we will use it to store the
  // version that the  graph is generated from. This helps us set up version
  // control. 
  // For the IR, we are using simple numbers starting with with 0x00000001, 
  // which was the version we published on Oct 10, 2017.
  IR_VERSION_2017_10_10 = 0x0000000000000001,

  // IR_VERSION 2 published on Oct 30, 2017
  // - Added type discriminator to AttributeProto to support proto3 users
  IR_VERSION_2017_10_30 = 0x0000000000000002,

  // IR VERSION 3 published on Nov 3, 2017
  // - For operator versioning:
  //    - Added new message OperatorSetIdProto
  //    - Added opset_import in ModelProto
  // - For vendor extensions, added domain in NodeProto
  IR_VERSION_2017_11_3 = 0x0000000000000003,

  // IR VERSION 4 published on Jan 22, 2019
  // - Relax constraint that initializers should be a subset of graph inputs
  // - Add type BFLOAT16
  IR_VERSION_2019_1_22 = 0x0000000000000004,

  // IR VERSION 5 published on March 18, 2019
  // - Add message TensorAnnotation.
  // - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
  IR_VERSION_2019_3_18 = 0x0000000000000005,

  // IR VERSION 6 published on Sep 19, 2019
  // - Add support for sparse tensor constants stored in model.
  //   - Add message SparseTensorProto
  //   - Add sparse initializers
  IR_VERSION = 0x0000000000000006
};

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
enum AttributeType {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  SPARSE_TENSOR = 11,

  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSORS = 12
};

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
struct Attribute {
  // The name field MUST be present for this version of the IR.
  string name;          // namespace Attribute
 
  // if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
  // In this case, this AttributeProto does not contain data, and it's a reference of attribute
  // in parent scope.
  // NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
  string ref_attr_name;

  // A human-readable documentation for this attribute. Markdown is allowed.
  string doc_string;

  // The type field MUST be present for this version of the IR.
  // For 0.0.1 versions of the IR, this field was not defined, and
  // implementations needed to use has_field hueristics to determine
  // which value field was in use.  For IR_VERSION 0.0.2 or later, this
  // field MUST be set and match the f|i|s|t|... field in use.  This
  // change was made to accomodate proto3 implementations.
  AttributeType type;   // discriminator that indicates which field below is in use

  // Exactly ONE of the following fields must be present for this version of the IR
  float f;               // float
  int64 i;               // int
  uint8 s;               // UTF-8 string
  Tensor t;         // tensor value
  Graph g;          // graph
  SparseTensor sparse_tensor;  // sparse tensor value
  // Do not use field below, it's deprecated.
  // ValueProto v = 12;         // value - subsumes everything but graph

  float floats;          // list of floats
  int64 ints;            // list of ints
  uint8 strings;         // list of UTF-8 strings
  Tensor tensors;  // list of tensors
  Graph graphs;    // list of graph
  SparseTensor sparse_tensors; // list of sparse tensors
};

// Defines information on value, including the name, the type, and
// the shape of the value.
struct ValueInfo {
  // This field MUST be present in this version of the IR.
  string name;     // namespace Value
  // This field MUST be present in this version of the IR for
  // inputs and outputs of the top-level graph.
  Type type;
  // A human-readable documentation for this value. Markdown is allowed.
  string doc_string;
};

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter 
// tensor and a bias tensor, and produces the convolved output.
struct Node {
  string input;    // namespace Value
  string output;   // namespace Value

  // An identifier for this node in a graph.
  // This field MAY be absent in ths version of the IR.
  string name;     // namespace Node

  // The symbolic identifier of the Operator to execute.
  string op_type;  // namespace Operator
  // The domain of the OperatorSet that specifies the operator named by op_type.
  string domain;   // namespace Domain

  // Additional named attributes.
  Attribute attribute;

  // A human-readable documentation for this node. Markdown is allowed.
  string doc_string;
};

// Tensors
//

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
struct Segment {
  int64 begin;
  int64 end;
};  

enum DataType {
  UNDEFINED = 0,
  // Basic types.
  FLOAT = 1,   // float
  UINT8 = 2,   // uint8_t
  INT8 = 3,    // int8_t
  UINT16 = 4,  // uint16_t
  INT16 = 5,   // int16_t
  INT32 = 6,   // int32_t
  INT64 = 7,   // int64_t
  STRING = 8,  // string
  BOOL = 9,    // bool

  // IEEE754 half-precision floating-point format (16 bits wide).
  // This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
  FLOAT16 = 10,

  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,     // complex with float32 real and imaginary components
  COMPLEX128 = 15,    // complex with float64 real and imaginary components

  // Non-IEEE floating-point format based on IEEE754 single-precision
  // floating-point number truncated to 16 bits.
  // This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
  BFLOAT16 = 16

  // Future extensions go here.
};

// Location of the data for this tensor. MUST be one of:
// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
// - EXTERNAL - data stored in an external location as described by external_data field.
enum DataLocation {
  DEFAULT = 0,
  EXTERNAL = 1
};

// A serialized tensor value.
struct Tensor {
  // The shape of the tensor.
  int64 dims;

  // The data type of the tensor.
  // This field MUST have a valid TensorProto.DataType value
  int32 data_type;

  
  Segment segment;

  // Tensor content must be organized in row-major order.
  //
  // Depending on the data_type field, exactly one of the fields below with
  // name ending in _data is used to store the elements of the tensor.

  // For float and complex64 values
  // Complex64 tensors are encoded as a single array of floats,
  // with the real components appearing in odd numbered positions,
  // and the corresponding imaginary component apparing in the
  // subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  // is encoded as [1.0, 2.0 ,3.0 ,4.0]
  // When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
  float float_data;

  // For int32, uint8, int8, uint16, int16, bool, and float16 values
  // float16 values must be bit-wise converted to an uint16_t prior
  // to writing to the buffer.
  // When this field is present, the data_type field MUST be
  // INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
  int32 int32_data;

  // For strings.
  // Each element of string_data is a UTF-8 encoded Unicode
  // string. No trailing null, no leading BOM. The protobuf "string"
  // scalar type is not used to match ML community conventions.
  // When this field is present, the data_type field MUST be STRING
  uint8 string_data;

  // For int64.
  // When this field is present, the data_type field MUST be INT64
  int64 int64_data;

  // Optionally, a name for the tensor.
  string name; // namespace Value

  // A human-readable documentation for this tensor. Markdown is allowed.
  string doc_string;

  // Serializations can either use one of the fields above, or use this
  // raw bytes field. The only exception is the string case, where one is
  // required to store the content in the bytes string_data field.
  //
  // When this raw_data field is used to store tensor value, elements MUST
  // be stored in as fixed-width, little-endian order.
  // Floating-point data types MUST be stored in IEEE 754 format.
  // Complex64 elements must be written as two consecutive FLOAT values, real component first.
  // Complex128 elements must be written as two consecutive DOUBLE values, real component first.
  // Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
  //
  // Note: the advantage of specific field rather than the raw_data field is
  // that in some cases (e.g. int data), protobuf does a better packing via
  // variable length storage, and may lead to smaller binary footprint.
  // When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
  uint8 raw_data;

  // Data can be stored inside the protobuf file using type-specific fields or raw_data.
  // Alternatively, raw bytes data can be stored in an external file, using the external_data field.
  // external_data stores key-value pairs describing data location. Recognized keys are:
  // - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
  //                           protobuf model was stored
  // - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
  //                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
  // - "length" (optional) - number of bytes containing data. Integer stored as string.
  // - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
  StringStringEntry external_data;

  // If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
  DataLocation data_location;

  // For double
  // Complex128 tensors are encoded as a single array of doubles,
  // with the real components appearing in odd numbered positions,
  // and the corresponding imaginary component apparing in the
  // subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  // is encoded as [1.0, 2.0 ,3.0 ,4.0]
  // When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
  double double_data;

  // For uint64 and uint32 values
  // When this field is present, the data_type field MUST be
  // UINT32 or UINT64
  uint64 uint64_data;
};

// A serialized sparse-tensor value
struct SparseTensor {
  // The sequence of non-default values are encoded as a tensor of shape [NNZ].
  // The default-value is zero for numeric tensors, and empty-string for string tensors.
  Tensor values;

  // The indices of the non-default values, which may be stored in one of two formats.
  // (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
  // corresponding to the j-th index of the i-th value (in the values tensor).
  // (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
  // must be the linearized-index of the i-th value (in the values tensor).
  // The linearized-index can be converted into an index tuple (k_1,...,k_rank)
  // using the shape provided below.
  // The indices must appear in ascending order without duplication.
  // In the first format, the ordering is lexicographic-ordering:
  // e.g., index-value [1,4] must appear before [2,1]
  Tensor indices;

  // The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
  int64 dims;
};

union DimensionValue {
  int64 dim_value;
  string dim_param;   // namespace Shape
};

struct Dimension {
  DimensionValue value;
  // Standard denotation can optionally be used to denote tensor
  // dimensions with standard semantic descriptions to ensure
  // that operations are applied to the correct axis of a tensor.
  // Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
  // for pre-defined dimension denotations.
  string denotation;
};

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
struct TensorShape {
  Dimension dim;
};

// Types
//
// The standard ONNX data types.
struct TensorType {
  // This field MUST NOT have the value of UNDEFINED
  // This field MUST have a valid TensorProto.DataType value
  // This field MUST be present for this version of the IR.
  int32 elem_type;
  TensorShape shape;
};

// T
struct SequenceType {
  // The type and shape of each element of the sequence.
  // This field MUST be present for this version of the IR.
  Type elem_type;
};

// map<K,V>
struct MapType {
  // This field MUST have a valid TensorProto.DataType value
  // This field MUST be present for this version of the IR.
  // This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
  int32 key_type;
  // This field MUST be present for this version of the IR.
  Type value_type;
};


struct SparseTensorType { 
  // This field MUST NOT have the value of UNDEFINED 
  // This field MUST have a valid TensorProto.DataType value
  // This field MUST be present for this version of the IR. 
  int32 elem_type;
  TensorShape shape;
};

struct OpaqueType {
  // When missing, the domain is the same as the model's.
  string domain;
  // The name is but significant when provided.
  string name;
  // parameters that help defining the type
  // DEPRECATED do not use.
  // TypeProto parameters = 3;
};

union TypeValue {
  // The type of a tensor.
  Tensor tensor_type;

  // NOTE:  DNN-only implementations of ONNX MAY elect to not support non-tensor values
  //        as input and output to graphs and nodes. These types are needed to naturally
  //        support classical ML operators.  DNN operators SHOULD restrict their input
  //        and output types to tensors.

  // The type of a sequence.
  SequenceType sequence_type;

  // The type of a map.
  MapType map_type;

  SparseTensor sparse_tensor_type;
  
  OpaqueType opaque_type;
};

struct Type {
  TypeValue value;
  // An denotation can be used to denote the whole 
  // type with a standard semantic description as to what is 
  // stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
  // for pre-defined type denotations.
  string denotation;
};

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto.
struct Model {
  // The version of the IR this model targets. See Version enum above.
  // This field MUST be present.
  int64 ir_version;

  // The OperatorSets this model relies on.
  // All ModelProtos MUST have at least one entry that
  // specifies which version of the ONNX OperatorSet is
  // being imported.
  //
  // All nodes in the ModelProto's graph will bind against the operator
  // with the same-domain/same-op_type operator with the HIGHEST version
  // in the referenced operator sets.
  OperatorSetId opset_import;

  // The name of the framework or tool used to generate this model.
  // This field SHOULD be present to indicate which implementation/tool/framework
  // emitted the model.
  string producer_name;

  // The version of the framework or tool used to generate this model.
  // This field SHOULD be present to indicate which implementation/tool/framework
  // emitted the model.
  string producer_version;

  // Domain name of the model.
  // We use reverse domain names as name space indicators. For example:
  // `com.facebook.fair` or `com.microsoft.cognitiveservices`
  //
  // Together with `model_version` and GraphProto.name, this forms the unique identity of
  // the graph.
  string domain;

  // The version of the graph encoded. See Version enum below.
  int64 model_version;

  // A human-readable documentation for this model. Markdown is allowed.
  string doc_string;

  // The parameterized graph that is evaluated to execute the model.
  Graph graph;

  // kezhan: This field is not in ONNX, and will be pushed into ONNX with good use cases in microsoft.
  Function functions;

  // Named metadata values; keys should be distinct.
  StringStringEntry metadata_props;
};

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
struct StringStringEntry {
  string key;
  string value;
};

struct TensorAnnotation {
  string tensor_name;
  // <key, value> pairs to annotate tensor specified by <tensor_name> above.
  // The keys used in the mapping below must be pre-defined in ONNX spec.
  // For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
  // quantization parameter keys.
  StringStringEntry quant_parameter_tensor_names;
};

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized 
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
struct Graph {
  // The nodes in the graph, sorted topologically.
  Node node;

  // The name of the graph.
  string name;   // namespace Graph

  // A list of named tensor values, used to specify constant inputs of the graph.
  // Each TensorProto entry must have a distinct name (within the list) that
  // MAY also appear in the input list.
  Tensor initializer;

  // Initializers (see above) stored in sparse format.
  SparseTensor sparse_initializer;

  // A human-readable documentation for this graph. Markdown is allowed.
  string doc_string;

  // The inputs and outputs of the graph.
  ValueInfo input;
  ValueInfo output;

  // Information for the values in the graph. The ValueInfoProto.name's
  // must be distinct. It is for a value to appear in value_info list.
  ValueInfo value_info;

  // This field carries information to indicate the mapping among a tensor and its
  // quantization parameter tensors. For example:
  // For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
  // which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
  TensorAnnotation quantization_annotation;

  // DO NOT USE the following fields, they were deprecated from earlier versions.
  // string input = 3;
  // string output = 4;
  // int64 ir_version = 6;
  // int64 producer_version = 7;
  // string producer_tag = 8;
  // string domain = 9;
};

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
struct OperatorSetId {
  // The domain of the operator set being identified.
  // The empty string ("") or absence of this field implies the operator
  // set that is defined as part of the ONNX specification.
  // This field MUST be present in this version of the IR when referring to any other operator set.
  string domain;

  // The version of the operator set being identified.
  // This field MUST be present in this version of the IR.
  int64 version;
};

// Operator/function status.
enum OperatorStatus {
  EXPERIMENTAL = 0,
  STABLE = 1
};

struct Function {
  // The name of the function, similar usage of op_type in OperatorProto.
  string name;
  
  // The first version of a function set which contains this function.
  // When there's any breaking change for this function, the function set
  // contains the function needs to bump its version, and since_version of
  // the updated function will be changed to the updated function set version.  
  int64 since_version;

  // This field indicates whether the syntax, semantics, or presence
  // of this function is in an experimental or stable stage. Once an
  // function is published as STABLE, its syntax and semantics MUST NOT
  // change in subsequent versions of the operator set.
  // When a function is published as EXPERIMENTAL, the syntax and semantics
  // of the function MAY change across operator set versions.
  // Functions "become" stable by deprecating the experimental version and
  // introducing a new stable function with the same name.
  OperatorStatus status;

  // The inputs and outputs of the function.
  string input;
  string output;

  // The attributes of the function.
  string attribute;
  
  // The nodes in the function.
  Node node;
  // A human-readable documentation for this function. Markdown is allowed.
  string doc_string;
};

enum PredictStatus {
  OK,
  FAILED
};

// PredictRequest specifies how inputs are mapped to tensors
// and how outputs are filtered before returning to user.
struct PredictRequest {
  // Input Tensors.
  // This is a mapping between output name and tensor.
  map<string, Tensor> inputs;

  // Output Filters.
  // This field is to specify which output fields need to be returned.
  // If the list is empty, all outputs will be included.
  string output_filter;
};

// Response for PredictRequest on successful run.
struct PredictResponse {
  // Output Tensors.
  // This is a mapping between output name and tensor.
  map<string, Tensor> outputs;
};

interface PredictionService {
  Predict(string model_name, string model_version, PredictRequest request) => (PredictStatus status, PredictResponse response);
};

enum ModelServiceStatus {
  OK,
  FAILED
};

struct ModelCompileRequest {
  string model_name;
};

struct ModelCompileResponse {
  ModelServiceStatus status;
};

struct ModelLoadRequest {
  string path;
};

struct ModelLoadResponse {
  ModelServiceStatus status;
};

struct ModelUnloadRequest {
  string model_name;
};

struct ModelUnloadResponse {
  ModelServiceStatus status;
};

interface ModelService {
  Compile(ModelCompileRequest request) => (ModelCompileResponse response);
  Load(ModelLoadRequest request) => (ModelLoadResponse response);
  Unload(ModelUnloadRequest request) => (ModelUnloadResponse response);
};