// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "shill/net/rtnl_message.h"

#include <linux/fib_rules.h>
#include <linux/if.h>  // NOLINT(build/include_alpha) - needs sockaddr.
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>

#include <string>

#include <gtest/gtest.h>
#include <re2/re2.h>

#include "shill/net/byte_string.h"
#include "shill/net/ip_address.h"

using testing::Test;

namespace shill {

namespace {

// These test strings were generated by cutting up the output of the
// "rtmon" utility into individual strings.  This tool outputs the raw
// RTNL packet contents sent by the kernel.  The comments above each
// of these strings is the markup that the "ip monitor" command
// outputs for each of these RTNL packets.

// 2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP
//     link/ether c0:f8:da:05:03:0b brd ff:ff:ff:ff:ff:ff

const int kNewLinkMessageWlan0InterfaceIndex = 2;
const unsigned int kNewLinkMessageWlan0InterfaceFlags =
    IFF_BROADCAST | IFF_MULTICAST | IFF_UP | IFF_LOWER_UP | IFF_RUNNING;
const unsigned int kNewLinkMessageWlan0InterfaceFlagsChange = 0;
const uint32_t kNewLinkMessageWlan0MTU = 1500;
const char kNewLinkMessageWlan0MacAddress[] = "\xc0\xf8\xda\x05\x03\x0b";
const char kNewLinkMessageWlan0InterfaceName[] = "wlan0";
const char kNewLinkMessageWlan0Qdisc[] = "mq";
const int kNewLinkMessageWlan0OperState = IF_OPER_UP;

const unsigned char kNewLinkMessageWlan0[] = {
    0xe0, 0x03, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x53, 0x18, 0x1f, 0x4e,
    0xac, 0x77, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x43, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x03, 0x00,
    0x77, 0x6c, 0x61, 0x6e, 0x30, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0d, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x11, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00,
    0xdc, 0x05, 0x00, 0x00, 0x07, 0x00, 0x06, 0x00, 0x6d, 0x71, 0x00, 0x00,
    0x20, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00,
    0xc0, 0xf8, 0xda, 0x05, 0x03, 0x0b, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x60, 0x00, 0x07, 0x00,
    0xa6, 0x65, 0x0f, 0x00, 0xa6, 0x0b, 0x00, 0x00, 0xd2, 0x29, 0x61, 0x06,
    0xd7, 0x25, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x84, 0x53, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x17, 0x00,
    0xa6, 0x65, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x0b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xd2, 0x29, 0x61, 0x06, 0x00, 0x00, 0x00, 0x00,
    0xd7, 0x25, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x84, 0x53, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x02, 0x1a, 0x00, 0x6c, 0x00, 0x02, 0x00, 0x68, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x0a, 0x00, 0x08, 0x00, 0x01, 0x00,
    0x10, 0x00, 0x00, 0x80, 0x14, 0x00, 0x05, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x22, 0x05, 0x00, 0x00, 0x4f, 0x53, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00,
    0x78, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0xdc, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0xa0, 0x0f, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x3a, 0x09, 0x00, 0x80, 0x51, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x58, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xfc, 0x00, 0x03, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x15, 0xe6, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0xe6, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x9b, 0x95, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9b, 0x95, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2c, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const int kNewLinkMessageIbf1InterfaceIndex = 17;
const char kNewLinkMessageIbf1InterfaceName[] = "ifb1";

const unsigned char kNewLinkMessageIfb1[] = {
    0xec, 0x04, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x2a, 0x47, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x00,
    0x69, 0x66, 0x62, 0x31, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0d, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00,
    0xdc, 0x05, 0x00, 0x00, 0x08, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1f, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x28, 0x00, 0xff, 0xff, 0x00, 0x00,
    0x08, 0x00, 0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x20, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x09, 0x00, 0x06, 0x00, 0x6e, 0x6f, 0x6f, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x27, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0xa2, 0xdc, 0xe7, 0xa3,
    0xd5, 0xfc, 0x00, 0x00, 0x0a, 0x00, 0x02, 0x00, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x00, 0x00, 0xbc, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0c, 0x00, 0x12, 0x00, 0x08, 0x00, 0x01, 0x00, 0x69, 0x66, 0x62, 0x00,
    0xe8, 0x02, 0x1a, 0x00, 0x7c, 0x00, 0x02, 0x00, 0x78, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x02, 0x0a, 0x00,
    0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x05, 0x00,
    0xff, 0xff, 0x00, 0x00, 0xd5, 0x23, 0x02, 0x00, 0x65, 0x77, 0x00, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0xdc, 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xa0, 0x0f, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x3a, 0x09, 0x00, 0x80, 0x51, 0x01, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x60, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xee, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x2c, 0x01, 0x03, 0x00, 0x25, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x07, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// Deleted 8: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN
//    link/ether 68:7f:74:ba:ef:c7 brd ff:ff:ff:ff:ff:ff

const int kDelLinkMessageEth0InterfaceIndex = 8;
const unsigned int kDelLinkMessageEth0InterfaceFlags =
    IFF_BROADCAST | IFF_MULTICAST;
const unsigned int kDelLinkMessageEth0InterfaceFlagsChange = 0xffffffff;
const uint32_t kDelLinkMessageEth0MTU = 1500;
const char kDelLinkMessageEth0MacAddress[] = "\x68\x7f\x74\xba\xef\xc7";
const char kDelLinkMessageEth0InterfacName[] = "eth0";
const char kDelLinkMessageEth0Qdisc[] = "noop";
const int kDelLinkMessageEth0OperState = IF_OPER_DOWN;

const unsigned char kDelLinkMessageEth0[] = {
    0xb8, 0x01, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x02, 0x10, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x09, 0x00, 0x03, 0x00,
    0x65, 0x74, 0x68, 0x30, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0d, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0x05, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00,
    0xdc, 0x05, 0x00, 0x00, 0x09, 0x00, 0x06, 0x00, 0x6e, 0x6f, 0x6f, 0x70,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x01, 0x00, 0x68, 0x7f, 0x74, 0xba, 0xef, 0xc7, 0x00, 0x00,
    0x0a, 0x00, 0x02, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
    0x60, 0x00, 0x07, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0xfa, 0x05, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xbc, 0x00, 0x17, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x05, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x15, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1a, 0x00,
};

// 8: if8    inet 192.168.10.100/24 brd 192.168.10.255 scope global eth0

const int kNewAddrIPV4InterfaceIndex = 8;
const char kNewAddrIPV4Address[] = "192.168.10.100";
const int kNewAddrIPV4AddressPrefix = 24;
const unsigned char kNewAddrIPV4Scope = RT_SCOPE_UNIVERSE;

const unsigned char kNewAddrIPV4[] = {
    0x3c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x01, 0x00, 0xc0, 0xa8, 0x0a, 0x64, 0x08, 0x00, 0x02, 0x00,
    0xc0, 0xa8, 0x0a, 0x64, 0x08, 0x00, 0x04, 0x00, 0xc0, 0xa8, 0x0a, 0xff,
    0x09, 0x00, 0x03, 0x00, 0x65, 0x74, 0x68, 0x30, 0x00, 0x00, 0x00, 0x00,
};

// Deleted 15: if15    inet6 fe80::6a7f:74ff:feba:efc7/64 scope link
//       valid_lft forever preferred_lft forever

const int kDelAddrIPV6InterfaceIndex = 15;
const char kDelAddrIPV6Address[] = "fe80::6a7f:74ff:feba:efc7";
const int kDelAddrIPV6AddressPrefix = 64;
const unsigned char kDelAddrIPV6Scope = RT_SCOPE_LINK;

const unsigned char kDelAddrIPV6[] = {
    0x40, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x40, 0x80, 0xfd, 0x0f, 0x00,
    0x00, 0x00, 0x14, 0x00, 0x01, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6a, 0x7f, 0x74, 0xff, 0xfe, 0xba, 0xef, 0xc7,
    0x14, 0x00, 0x06, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xbf, 0xdb, 0x02, 0x00, 0xbf, 0xdb, 0x02, 0x00,
};

// Deleted ff02::1:ffa0:688 via ff02::1:ffa0:688 dev if2  metric 0

const int kDelRouteIPV6InterfaceIndex = 2;
const char kDelRouteIPV6Address[] = "ff02::1:ffa0:688";
const int kDelRouteIPV6Prefix = 128;
const int kDelRouteIPV6Metric = 0;

const unsigned char kDelRouteIPV6[] = {
    0x80, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00, 0xfe, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x01, 0x00, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xff, 0xa0, 0x06, 0x88, 0x14, 0x00, 0x05, 0x00,
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0xff, 0xa0, 0x06, 0x88, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x0c, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// default via 192.168.17.254 dev if12  metric 9

const int kAddRouteIPV4InterfaceIndex = 12;
const char kAddRouteIPV4Address[] = "192.168.17.254";
const int kAddRouteIPV4Metric = 9;

const unsigned char kAddRouteIPV4[] = {
    0x3c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00, 0xfe, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x06, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x05, 0x00,
    0xc0, 0xa8, 0x11, 0xfe, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
};

// This is the same as kAddRouteIPV4 above, except manually corrupted
// the second to last parameter
const unsigned char kAddRouteBusted[] = {
    0x3c, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0f, 0x00, 0xfe, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x06, 0x00, 0x09, 0x00, 0x00, 0x00, 0x28, 0x00, 0x05, 0x00,
    0xc0, 0xa8, 0x11, 0xfe, 0x08, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x00, 0x00,
};

// 192.168.10.1 dev if8 lladdr 00:14:d1:cd:d5:2c REACHABLE
const unsigned char kAddNeighborMessage[] = {
    0x4c, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x08, 0x00, 0x01, 0x00, 0xc0,
    0xa8, 0x0a, 0x01, 0x0a, 0x00, 0x02, 0x00, 0x00, 0x14, 0xd1, 0xcd,
    0xd5, 0x2c, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00,
    0x00, 0x14, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
};

// RDNSS notification
// Lifetime: infinity (0xffffffff)
// Server addresses: 2001:db8:100:f101::1, 2001:db8:100:f101::2
const unsigned char kNdRdnssMessage[] = {
    0x5c, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x28, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x86, 0x00, 0x03, 0x00, 0x14, 0x00, 0x01, 0x00, 0x19, 0x05, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x20, 0x01, 0x0d, 0xb8, 0x01, 0x00, 0xf1, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x01, 0x0d, 0xb8,
    0x01, 0x00, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x14, 0x00, 0x01, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x50, 0xf8, 0x86, 0xff,
};

// Add IPv4 rule for src 100.87.84.110/24 table 1002
const unsigned char kRuleMessage1[] = {
    0x3C, 0x0, 0x0, 0x0, 0x20, 0x0,  0x0,  0x0,  0x39, 0x0,  0x0,  0x0,
    0xCE, 0x4, 0x0, 0x0, 0x2,  0x0,  0x18, 0x0,  0xFC, 0x0,  0x0,  0x1,
    0x0,  0x0, 0x0, 0x0, 0x8,  0x0,  0xF,  0x0,  0xEA, 0x3,  0x0,  0x0,
    0x8,  0x0, 0xE, 0x0, 0xFF, 0xFF, 0xFF, 0xFF, 0x8,  0x0,  0x6,  0x0,
    0xA,  0x0, 0x0, 0x0, 0x8,  0x0,  0x2,  0x0,  0x64, 0x57, 0x54, 0x6E};

// Delete IPv4 rule for iif eth0 table 1002
const unsigned char kRuleMessage2[] = {
    0x40, 0x0,  0x0,  0x0,  0x21, 0x0, 0x0,  0x0,  0xFA, 0x0,  0x0,  0x0,  0x60,
    0x4,  0x0,  0x0,  0x2,  0x0,  0x0, 0x0,  0xFC, 0x0,  0x0,  0x1,  0x0,  0x0,
    0x0,  0x0,  0x8,  0x0,  0xF,  0x0, 0xEA, 0x3,  0x0,  0x0,  0x8,  0x0,  0xE,
    0x0,  0xFF, 0xFF, 0xFF, 0xFF, 0x9, 0x0,  0x3,  0x0,  0x65, 0x74, 0x68, 0x30,
    0x0,  0x0,  0x0,  0x0,  0x8,  0x0, 0x6,  0x0,  0xA,  0x0,  0x0,  0x0};

// Add IPv4 rule for fwmark 0x1234/0xFFFF table 1002
const unsigned char kRuleMessage3[] = {
    0x44, 0x0, 0x0,  0x0, 0x20, 0x0,  0x0,  0x0,  0x87, 0xB1, 0xA1, 0x5E,
    0xD0, 0xE, 0x0,  0x0, 0x2,  0x0,  0x0,  0x0,  0xFC, 0x0,  0x0,  0x1,
    0x0,  0x0, 0x0,  0x0, 0x8,  0x0,  0xF,  0x0,  0xEA, 0x3,  0x0,  0x0,
    0x8,  0x0, 0xE,  0x0, 0xFF, 0xFF, 0xFF, 0xFF, 0x8,  0x0,  0x6,  0x0,
    0x8,  0x0, 0x0,  0x0, 0x8,  0x0,  0xA,  0x0,  0x34, 0x12, 0x0,  0x0,
    0x8,  0x0, 0x10, 0x0, 0xFF, 0xFF, 0x0,  0x0};

// Add IPv6 rule for table 1002
const unsigned char kRuleMessage4[] = {
    0x2c, 0x0,  0x0, 0x0, 0x20, 0x0, 0x2, 0x0,  0x2,  0x0,  0x0,
    0x0,  0xce, 0x4, 0x0, 0x0,  0xa, 0x0, 0x0,  0x0,  0xff, 0x0,
    0x0,  0x1,  0x0, 0x0, 0x0,  0x0, 0x8, 0x0,  0xf,  0x0,  0xff,
    0x0,  0x0,  0x0, 0x8, 0x0,  0xe, 0x0, 0xff, 0xff, 0xff, 0xff};

}  // namespace

class RTNLMessageTest : public Test {
 protected:
  void TestParseLink(const ByteString& packet,
                     RTNLMessage::Mode mode,
                     int interface_index,
                     unsigned int flags,
                     unsigned int change,
                     ByteString address,
                     std::string name,
                     uint32_t mtu,
                     ByteString qdisc,
                     int oper_state) {
    RTNLMessage msg;
    EXPECT_TRUE(msg.Decode(packet));

    EXPECT_EQ(RTNLMessage::kTypeLink, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::LinkStatus status = msg.link_status();
    EXPECT_EQ(flags, status.flags);
    EXPECT_EQ(change, status.change);

    EXPECT_TRUE(msg.HasAttribute(IFLA_ADDRESS));
    EXPECT_EQ(address.GetLength(), msg.GetAttribute(IFLA_ADDRESS).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_ADDRESS).Equals(address));

    ByteString bytestring_name(name, true);
    EXPECT_TRUE(msg.HasAttribute(IFLA_IFNAME));
    EXPECT_EQ(bytestring_name.GetLength(),
              msg.GetAttribute(IFLA_IFNAME).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_IFNAME).Equals(bytestring_name));
    EXPECT_EQ(name, msg.GetIflaIfname());

    EXPECT_TRUE(msg.HasAttribute(IFLA_MTU));
    uint32_t mtu_val;
    EXPECT_TRUE(msg.GetAttribute(IFLA_MTU).ConvertToCPUUInt32(&mtu_val));
    EXPECT_EQ(mtu, mtu_val);

    EXPECT_TRUE(msg.HasAttribute(IFLA_QDISC));
    EXPECT_EQ(qdisc.GetLength(), msg.GetAttribute(IFLA_QDISC).GetLength());
    EXPECT_TRUE(msg.GetAttribute(IFLA_QDISC).Equals(qdisc));

    EXPECT_TRUE(msg.HasAttribute(IFLA_OPERSTATE));
    EXPECT_EQ(oper_state, msg.GetAttribute(IFLA_OPERSTATE).GetConstData()[0]);
  }

  void TestParseAddress(const ByteString& packet,
                        RTNLMessage::Mode mode,
                        int interface_index,
                        const IPAddress& address,
                        unsigned char scope) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeAddress, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());
    EXPECT_EQ(address.family(), msg.family());

    RTNLMessage::AddressStatus status = msg.address_status();
    EXPECT_EQ(scope, status.scope);

    EXPECT_TRUE(msg.HasAttribute(IFA_ADDRESS));
    EXPECT_EQ(address.GetLength(), msg.GetAttribute(IFA_ADDRESS).GetLength());
    EXPECT_TRUE(IPAddress(address.family(), msg.GetAttribute(IFA_ADDRESS),
                          status.prefix_len)
                    .Equals(address));
    EXPECT_TRUE(msg.GetIfaAddress().IsValid());
    EXPECT_TRUE(msg.GetIfaAddress().Equals(address));
  }

  void TestParseRoute(const ByteString& packet,
                      RTNLMessage::Mode /*mode*/,
                      IPAddress::Family family,
                      int interface_index,
                      const IPAddress& dst,
                      const IPAddress& src,
                      const IPAddress& gateway,
                      unsigned char table,
                      int protocol,
                      unsigned char scope,
                      unsigned char type,
                      int metric) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeRoute, msg.type());
    EXPECT_EQ(0, msg.interface_index());
    EXPECT_EQ(family, msg.family());

    RTNLMessage::RouteStatus status = msg.route_status();
    EXPECT_EQ(table, status.table);
    EXPECT_EQ(protocol, status.protocol);
    EXPECT_EQ(scope, status.scope);
    EXPECT_EQ(type, status.type);

    if (!dst.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_DST));
      EXPECT_TRUE(
          IPAddress(family, msg.GetAttribute(RTA_DST), status.dst_prefix)
              .Equals(dst));
      EXPECT_TRUE(msg.GetRtaDst().Equals(dst));
    }

    if (!src.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_SRC));
      EXPECT_TRUE(
          IPAddress(family, msg.GetAttribute(RTA_SRC), status.src_prefix)
              .Equals(src));
      EXPECT_TRUE(msg.GetRtaSrc().Equals(src));
    }

    if (!gateway.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(RTA_GATEWAY));
      EXPECT_TRUE(
          IPAddress(family, msg.GetAttribute(RTA_GATEWAY)).Equals(gateway));
      EXPECT_TRUE(msg.GetRtaGateway().Equals(gateway));
    }

    if (interface_index >= 0) {
      EXPECT_TRUE(msg.HasAttribute(RTA_OIF));
      uint32_t int_val;
      EXPECT_TRUE(msg.GetAttribute(RTA_OIF).ConvertToCPUUInt32(&int_val));
      EXPECT_EQ(interface_index, int_val);
      EXPECT_EQ(interface_index, msg.GetRtaOif());
    } else {
      EXPECT_FALSE(msg.HasAttribute(RTA_OIF));
    }
    if (metric >= 0) {
      EXPECT_TRUE(msg.HasAttribute(RTA_PRIORITY));
      uint32_t metric_val;
      EXPECT_TRUE(
          msg.GetAttribute(RTA_PRIORITY).ConvertToCPUUInt32(&metric_val));
      EXPECT_EQ(metric, metric_val);
    } else {
      EXPECT_FALSE(msg.HasAttribute(RTA_PRIORITY));
    }
  }

  void TestParseRule(const ByteString& packet,
                     RTNLMessage::Mode /*mode*/,
                     IPAddress::Family family,
                     unsigned char table,
                     int protocol,
                     unsigned char scope,
                     unsigned char type,
                     const IPAddress& dst,
                     const IPAddress& src,
                     uint32_t priority,
                     uint32_t fwmark,
                     uint32_t fwmask,
                     uint32_t uidrange_start,
                     uint32_t uidrange_end,
                     const std::string& ifname) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeRule, msg.type());
    EXPECT_EQ(0, msg.interface_index());
    EXPECT_EQ(family, msg.family());

    RTNLMessage::RouteStatus status = msg.route_status();
    EXPECT_EQ(table, status.table);
    EXPECT_EQ(protocol, status.protocol);
    EXPECT_EQ(scope, status.scope);
    EXPECT_EQ(type, status.type);

    if (!dst.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(FRA_DST));
      EXPECT_TRUE(
          IPAddress(family, msg.GetAttribute(FRA_DST), status.dst_prefix)
              .Equals(dst));
    }

    if (!src.IsDefault()) {
      EXPECT_TRUE(msg.HasAttribute(FRA_SRC));
      EXPECT_TRUE(
          IPAddress(family, msg.GetAttribute(FRA_SRC), status.src_prefix)
              .Equals(src));
    }

    EXPECT_TRUE(msg.HasAttribute(FRA_PRIORITY));
    uint32_t decoded_priority;
    EXPECT_TRUE(
        msg.GetAttribute(FRA_PRIORITY).ConvertToCPUUInt32(&decoded_priority));
    EXPECT_EQ(priority, decoded_priority);

    if (fwmark || fwmask) {
      EXPECT_TRUE(msg.HasAttribute(FRA_FWMARK));
      EXPECT_TRUE(msg.HasAttribute(FRA_FWMASK));

      uint32_t decoded_fwmark, decoded_fwmask;
      EXPECT_TRUE(
          msg.GetAttribute(FRA_FWMARK).ConvertToCPUUInt32(&decoded_fwmark));
      EXPECT_TRUE(
          msg.GetAttribute(FRA_FWMASK).ConvertToCPUUInt32(&decoded_fwmask));
      EXPECT_EQ(fwmark, decoded_fwmark);
      EXPECT_EQ(fwmask, decoded_fwmask);
    } else {
      EXPECT_FALSE(msg.HasAttribute(FRA_FWMARK));
      EXPECT_FALSE(msg.HasAttribute(FRA_FWMASK));
    }

    if (uidrange_start || uidrange_end) {
      EXPECT_TRUE(msg.HasAttribute(FRA_UID_RANGE));

      struct fib_rule_uid_range decoded_range;
      EXPECT_TRUE(msg.GetAttribute(FRA_UID_RANGE)
                      .CopyData(sizeof(decoded_range), &decoded_range));
      EXPECT_EQ(uidrange_start, decoded_range.start);
      EXPECT_EQ(uidrange_end, decoded_range.end);
    } else {
      EXPECT_FALSE(msg.HasAttribute(FRA_UID_RANGE));
    }

    if (!ifname.empty()) {
      EXPECT_TRUE(msg.HasAttribute(FRA_IFNAME));
      std::string decoded_ifname;
      decoded_ifname = reinterpret_cast<const char*>(
          msg.GetAttribute(FRA_IFNAME).GetConstData());
      EXPECT_STREQ(ifname.c_str(), decoded_ifname.c_str());
    } else {
      EXPECT_FALSE(msg.HasAttribute(FRA_IFNAME));
    }
  }

  void TestParseRdnss(const ByteString& packet,
                      RTNLMessage::Mode mode,
                      int interface_index,
                      uint32_t lifetime,
                      const std::string& dns_server_addresses) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeRdnss, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::RdnssOption rdnss = msg.rdnss_option();

    // Format addresses string for verification.
    std::string addresses;
    bool first = true;
    for (auto& ip : rdnss.addresses) {
      if (!first) {
        addresses += ", ";
      } else {
        first = false;
      }
      addresses += ip.ToString();
    }

    // Verify life time and addresses.
    EXPECT_EQ(lifetime, rdnss.lifetime);
    EXPECT_EQ(dns_server_addresses, addresses);
  }

  void TestParseNeighbor(const ByteString& packet,
                         RTNLMessage::Mode mode,
                         IPAddress::Family family,
                         int interface_index,
                         uint16_t state,
                         uint8_t flags,
                         uint8_t type) {
    RTNLMessage msg;

    EXPECT_TRUE(msg.Decode(packet));
    EXPECT_EQ(RTNLMessage::kTypeNeighbor, msg.type());
    EXPECT_EQ(mode, msg.mode());
    EXPECT_EQ(family, msg.family());
    EXPECT_EQ(interface_index, msg.interface_index());

    RTNLMessage::NeighborStatus neighbor = msg.neighbor_status();

    EXPECT_EQ(neighbor.state, state);
    EXPECT_EQ(neighbor.flags, flags);
    EXPECT_EQ(neighbor.type, type);
  }
};

TEST_F(RTNLMessageTest, NewLinkWlan0) {
  TestParseLink(ByteString(kNewLinkMessageWlan0, sizeof(kNewLinkMessageWlan0)),
                RTNLMessage::kModeAdd, kNewLinkMessageWlan0InterfaceIndex,
                kNewLinkMessageWlan0InterfaceFlags,
                kNewLinkMessageWlan0InterfaceFlagsChange,
                ByteString(std::string(kNewLinkMessageWlan0MacAddress), false),
                std::string(kNewLinkMessageWlan0InterfaceName),
                kNewLinkMessageWlan0MTU,
                ByteString(std::string(kNewLinkMessageWlan0Qdisc), true),
                kNewLinkMessageWlan0OperState);
}

TEST_F(RTNLMessageTest, NewLinkIfb1) {
  RTNLMessage msg;
  EXPECT_TRUE(
      msg.Decode(ByteString(kNewLinkMessageIfb1, sizeof(kNewLinkMessageIfb1))));
  EXPECT_EQ(RTNLMessage::kTypeLink, msg.type());

  EXPECT_EQ(RTNLMessage::kModeAdd, msg.mode());
  EXPECT_EQ(kNewLinkMessageIbf1InterfaceIndex, msg.interface_index());

  ByteString name(std::string(kNewLinkMessageIbf1InterfaceName), true);
  EXPECT_TRUE(msg.HasAttribute(IFLA_IFNAME));
  EXPECT_EQ(name.GetLength(), msg.GetAttribute(IFLA_IFNAME).GetLength());
  EXPECT_TRUE(msg.GetAttribute(IFLA_IFNAME).Equals(name));

  EXPECT_TRUE(msg.HasAttribute(IFLA_LINKINFO));
  EXPECT_STREQ("ifb", msg.link_status().kind.value().c_str());
}

TEST_F(RTNLMessageTest, DelLinkEth0) {
  TestParseLink(ByteString(kDelLinkMessageEth0, sizeof(kDelLinkMessageEth0)),
                RTNLMessage::kModeDelete, kDelLinkMessageEth0InterfaceIndex,
                kDelLinkMessageEth0InterfaceFlags,
                kDelLinkMessageEth0InterfaceFlagsChange,
                ByteString(std::string(kDelLinkMessageEth0MacAddress), false),
                std::string(kDelLinkMessageEth0InterfacName),
                kDelLinkMessageEth0MTU,
                ByteString(std::string(kDelLinkMessageEth0Qdisc), true),
                kDelLinkMessageEth0OperState);
}

TEST_F(RTNLMessageTest, NewAddrIPv4) {
  IPAddress addr(IPAddress::kFamilyIPv4);

  EXPECT_TRUE(addr.SetAddressFromString(kNewAddrIPV4Address));
  addr.set_prefix(kNewAddrIPV4AddressPrefix);
  TestParseAddress(ByteString(kNewAddrIPV4, sizeof(kNewAddrIPV4)),
                   RTNLMessage::kModeAdd, kNewAddrIPV4InterfaceIndex, addr,
                   kNewAddrIPV4Scope);
}

TEST_F(RTNLMessageTest, DelAddrIPv6) {
  IPAddress addr(IPAddress::kFamilyIPv6);

  EXPECT_TRUE(addr.SetAddressFromString(kDelAddrIPV6Address));
  addr.set_prefix(kDelAddrIPV6AddressPrefix);
  TestParseAddress(ByteString(kDelAddrIPV6, sizeof(kDelAddrIPV6)),
                   RTNLMessage::kModeDelete, kDelAddrIPV6InterfaceIndex, addr,
                   kDelAddrIPV6Scope);
}

TEST_F(RTNLMessageTest, DelRouteIPv6) {
  IPAddress dst(IPAddress::kFamilyIPv6);
  IPAddress src(IPAddress::kFamilyIPv6);
  IPAddress gateway(IPAddress::kFamilyIPv6);

  EXPECT_TRUE(dst.SetAddressFromString(kDelRouteIPV6Address));
  dst.set_prefix(kDelRouteIPV6Prefix);
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString(kDelRouteIPV6Address));

  TestParseRoute(ByteString(kDelRouteIPV6, sizeof(kDelRouteIPV6)),
                 RTNLMessage::kModeDelete, IPAddress::kFamilyIPv6,
                 kDelRouteIPV6InterfaceIndex, dst, src, gateway, RT_TABLE_MAIN,
                 RTPROT_UNSPEC, RT_SCOPE_UNIVERSE, RTN_UNICAST,
                 kDelRouteIPV6Metric);
}

TEST_F(RTNLMessageTest, AddRouteIPv4) {
  IPAddress dst(IPAddress::kFamilyIPv4);
  IPAddress src(IPAddress::kFamilyIPv4);
  IPAddress gateway(IPAddress::kFamilyIPv4);

  dst.SetAddressToDefault();
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString(kAddRouteIPV4Address));

  TestParseRoute(ByteString(kAddRouteIPV4, sizeof(kAddRouteIPV4)),
                 RTNLMessage::kModeAdd, IPAddress::kFamilyIPv4,
                 kAddRouteIPV4InterfaceIndex, dst, src, gateway, RT_TABLE_MAIN,
                 RTPROT_BOOT, RT_SCOPE_UNIVERSE, RTN_UNICAST,
                 kAddRouteIPV4Metric);
}

TEST_F(RTNLMessageTest, NewRdnssOption) {
  int interface_index = 1;
  uint32_t lifetime = 0xffffffff;
  std::string dns_server_addresses =
      "2001:db8:100:f101::1, 2001:db8:100:f101::2";

  TestParseRdnss(ByteString(kNdRdnssMessage, sizeof(kNdRdnssMessage)),
                 RTNLMessage::kModeAdd, interface_index, lifetime,
                 dns_server_addresses);
}

TEST_F(RTNLMessageTest, ParseRuleEvents) {
  struct {
    const unsigned char* payload;
    size_t length;
    std::string iif;
    std::string oif;
    IPAddress src;
    IPAddress dst;
    uint32_t fwmark;
    uint32_t fwmask;
    uint32_t table;
    uint32_t priority;
  } test_cases[] = {
      {kRuleMessage1, sizeof(kRuleMessage1), "", "",
       IPAddress("100.87.84.110", 24), IPAddress(), 0, 0, 1002, 10},
      {kRuleMessage2, sizeof(kRuleMessage2), "eth0", "", IPAddress(),
       IPAddress(), 0, 0, 1002, 10},
      {kRuleMessage3, sizeof(kRuleMessage3), "", "", IPAddress(), IPAddress(),
       0x1234, 0xffff, 1002, 8},
      {kRuleMessage4, sizeof(kRuleMessage4), "", "", IPAddress(), IPAddress(),
       0, 0, 255, 0},
  };
  for (const auto& tt : test_cases) {
    RTNLMessage msg;
    EXPECT_TRUE(msg.Decode(ByteString(tt.payload, tt.length)));
    EXPECT_EQ(tt.iif, msg.GetFraIifname());
    EXPECT_EQ(tt.oif, msg.GetFraOifname());
    EXPECT_EQ(tt.src.ToString(), msg.GetFraSrc().ToString());
    EXPECT_EQ(tt.dst.ToString(), msg.GetFraDst().ToString());
    EXPECT_EQ(tt.fwmark, msg.GetFraFwmark());
    EXPECT_EQ(tt.fwmask, msg.GetFraFwmask());
    EXPECT_EQ(tt.table, msg.GetFraTable());
    EXPECT_EQ(tt.priority, msg.GetFraPriority());
  }
}

TEST_F(RTNLMessageTest, AddRouteBusted) {
  // RTNLMessage should list parse errors as kMessageUnknown
  RTNLMessage msg;
  EXPECT_FALSE(
      msg.Decode(ByteString(kAddRouteBusted, sizeof(kAddRouteBusted))));
}

TEST_F(RTNLMessageTest, AddNeighbor) {
  TestParseNeighbor(
      ByteString(kAddNeighborMessage, sizeof(kAddNeighborMessage)),
      RTNLMessage::kModeAdd, IPAddress::kFamilyIPv4, 8, NUD_REACHABLE, 0,
      NDA_DST);
}

TEST_F(RTNLMessageTest, EncodeDelNeighbor) {
  RTNLMessage msg(RTNLMessage::kTypeNeighbor, RTNLMessage::kModeDelete, 0, 1, 2,
                  0, IPAddress::kFamilyIPv4);
  msg.set_neighbor_status(
      RTNLMessage::NeighborStatus(0, NTF_ROUTER, NDA_LLADDR));

  TestParseNeighbor(msg.Encode(), RTNLMessage::kModeDelete,
                    IPAddress::kFamilyIPv4, 0, 0, NTF_ROUTER, NDA_LLADDR);
}

TEST_F(RTNLMessageTest, EncodeRouteAdd) {
  RTNLMessage msg(RTNLMessage::kTypeRoute, RTNLMessage::kModeAdd, 0, 1, 2, 0,
                  IPAddress::kFamilyIPv4);
  IPAddress dst(IPAddress::kFamilyIPv4);
  IPAddress src(IPAddress::kFamilyIPv4);
  IPAddress gateway(IPAddress::kFamilyIPv4);

  dst.SetAddressToDefault();
  src.SetAddressToDefault();
  EXPECT_TRUE(gateway.SetAddressFromString("192.168.0.1"));

  msg.set_route_status(RTNLMessage::RouteStatus(
      0, 0, RT_TABLE_MAIN, RTPROT_BOOT, RT_SCOPE_UNIVERSE, RTN_UNICAST, 0));
  msg.SetAttribute(RTA_DST, dst.address());
  msg.SetAttribute(RTA_SRC, src.address());
  msg.SetAttribute(RTA_GATEWAY, gateway.address());
  msg.SetAttribute(RTA_OIF, ByteString::CreateFromCPUUInt32(12));
  msg.SetAttribute(RTA_PRIORITY, ByteString::CreateFromCPUUInt32(13));

  TestParseRoute(msg.Encode(), RTNLMessage::kModeAdd, IPAddress::kFamilyIPv4,
                 12, dst, src, gateway, RT_TABLE_MAIN, RTPROT_BOOT,
                 RT_SCOPE_UNIVERSE, RTN_UNICAST, 13);
}

TEST_F(RTNLMessageTest, EncodeRuleAdd) {
  RTNLMessage msg(RTNLMessage::kTypeRule, RTNLMessage::kModeAdd, 0, 1, 2, 0,
                  IPAddress::kFamilyIPv4);
  IPAddress dst(IPAddress::kFamilyIPv4);
  IPAddress src(IPAddress::kFamilyIPv4);

  EXPECT_TRUE(dst.SetAddressFromString("192.168.1.0"));
  EXPECT_TRUE(src.SetAddressFromString("192.168.2.0"));

  msg.set_route_status(
      RTNLMessage::RouteStatus(dst.prefix(), src.prefix(), RT_TABLE_MAIN,
                               RTPROT_BOOT, RT_SCOPE_UNIVERSE, RTN_UNICAST, 0));
  msg.SetAttribute(FRA_DST, dst.address());
  msg.SetAttribute(FRA_SRC, src.address());

  msg.SetAttribute(FRA_PRIORITY, ByteString::CreateFromCPUUInt32(13));
  msg.SetAttribute(FRA_FWMARK, ByteString::CreateFromCPUUInt32(0x1234));
  msg.SetAttribute(FRA_FWMASK, ByteString::CreateFromCPUUInt32(0xffff));

  struct fib_rule_uid_range r = {.start = 1000, .end = 2000};
  msg.SetAttribute(
      FRA_UID_RANGE,
      ByteString(reinterpret_cast<const unsigned char*>(&r), sizeof(r)));

  msg.SetAttribute(FRA_IFNAME, ByteString(std::string("fake0"), true));

  TestParseRule(msg.Encode(), RTNLMessage::kModeAdd, IPAddress::kFamilyIPv4,
                RT_TABLE_MAIN, RTPROT_BOOT, RT_SCOPE_UNIVERSE, RTN_UNICAST, dst,
                src, 13, 0x1234, 0xffff, 1000, 2000, "fake0");
}

TEST_F(RTNLMessageTest, EncodeLinkDel) {
  const int kInterfaceIndex = 0x1234;
  RTNLMessage pmsg(RTNLMessage::kTypeLink, RTNLMessage::kModeDelete,
                   NLM_F_REQUEST, 0, 0, kInterfaceIndex,
                   IPAddress::kFamilyUnknown);

  RTNLMessage msg;
  EXPECT_TRUE(msg.Decode(pmsg.Encode()));

  EXPECT_EQ(RTNLMessage::kTypeLink, msg.type());
  EXPECT_EQ(RTNLMessage::kModeDelete, msg.mode());
  EXPECT_EQ(kInterfaceIndex, msg.interface_index());

  RTNLMessage::LinkStatus status = msg.link_status();
  EXPECT_EQ(0, status.flags);
  EXPECT_EQ(0, status.change);

  EXPECT_FALSE(msg.HasAttribute(IFLA_ADDRESS));
  EXPECT_FALSE(msg.HasAttribute(IFLA_IFNAME));
  EXPECT_FALSE(msg.HasAttribute(IFLA_MTU));
  EXPECT_FALSE(msg.HasAttribute(IFLA_QDISC));
  EXPECT_FALSE(msg.HasAttribute(IFLA_OPERSTATE));
}

TEST_F(RTNLMessageTest, EncodeIflaInfoKind) {
  const std::string kLinkKind = "kind";
  RTNLMessage pmsg(RTNLMessage::kTypeLink, RTNLMessage::kModeAdd, NLM_F_REQUEST,
                   0, 0, 0, IPAddress::kFamilyUnknown);
  pmsg.SetIflaInfoKind(kLinkKind, {});
  RTNLMessage msg;
  EXPECT_TRUE(msg.Decode(pmsg.Encode()));
  EXPECT_TRUE(msg.link_status().kind.has_value());
  EXPECT_EQ(msg.link_status().kind.value(), kLinkKind);
}

TEST_F(RTNLMessageTest, ToString) {
  struct {
    const unsigned char* payload;
    size_t length;
    std::string regexp;
  } test_cases[] = {
      {kNewLinkMessageWlan0, sizeof(kNewLinkMessageWlan0),
       "Add Link: wlan0\\[2\\] type ETHER flags <BROADCAST,LOWER_UP,MULTICAST,"
       "RUNNING,UP> change 0"},
      {kNewLinkMessageIfb1, sizeof(kNewLinkMessageIfb1),
       "Add Link: ifb1\\[17\\] type ETHER flags <BROADCAST,NOARP> change 0 "
       "kind ifb"},
      {kDelLinkMessageEth0, sizeof(kDelLinkMessageEth0),
       "Delete Link: eth0\\[8\\] type ETHER flags <BROADCAST,MULTICAST> change "
       "FFFFFFFF"},
      // For Address events, the output interface index cannot be converted
      // after the fact using if_indextoname(), but can still happen to match an
      // unrelated interface on the unit test host. Escape it with \w*.
      {kNewAddrIPV4, sizeof(kNewAddrIPV4),
       "Add IPv4 Address: 192\\.168\\.10\\.100/24 if \\w*\\[8\\] flags "
       "PERMANENT scope 0"},
      {kDelAddrIPV6, sizeof(kDelAddrIPV6),
       "Delete IPv6 Address: fe80::6a7f:74ff:feba:efc7/64 if \\w*\\[15\\] "
       "flags PERMANENT scope 253"},
      {kAddRouteIPV4, sizeof(kAddRouteIPV4),
       // For routes, the output interface index cannot be converted after the
       // fact using if_indextoname(), but can still happen to match an
       // unrelated interface on the unit test host. Escape it with \w*.
       "Add IPv4 Route: via 192\\.168\\.17\\.254 if \\w*\\[12\\] table 254 "
       "priority 9 protocol BOOT type UNICAST"},
      {kDelRouteIPV6, sizeof(kDelRouteIPV6),
       "Delete IPv6 Route: dst ff02::1:ffa0:688/128 via ff02::1:ffa0:688 if "
       "\\w*\\[2\\] table 254 priority 0 protocol UNSPEC type UNICAST"},
      {kAddNeighborMessage, sizeof(kAddNeighborMessage),
       "Add IPv4 Neighbor: NeighborStatus state 2 flags 0 type 1"},
      {kNdRdnssMessage, sizeof(kNdRdnssMessage),
       "Add IPv6 Rdnss: RdnssOption lifetime -1"},
      {kRuleMessage1, sizeof(kRuleMessage1),
       "Add IPv4 Rule: src 100\\.87\\.84\\.110/24 table 1002 priority 10 "
       "action TO_TBL flags 0"},
      {kRuleMessage2, sizeof(kRuleMessage2),
       "Delete IPv4 Rule: iif eth0 table 1002 priority 10 action TO_TBL flags "
       "0"},
      {kRuleMessage3, sizeof(kRuleMessage3),
       "Add IPv4 Rule: fwmark 0x1234/0xFFFF table 1002 priority 8 action "
       "TO_TBL flags 0"},
      {kRuleMessage4, sizeof(kRuleMessage4),
       "Add IPv6 Rule: table 255 priority 0 action TO_TBL flags 0"},
  };
  for (const auto& tt : test_cases) {
    RTNLMessage msg;
    EXPECT_TRUE(msg.Decode(ByteString(tt.payload, tt.length)));
    EXPECT_TRUE(RE2::FullMatch(msg.ToString(), tt.regexp))
        << '"' << msg.ToString() << "\" did not match regex \"" << tt.regexp
        << '"';
  }
}

TEST_F(RTNLMessageTest, GetUint32Attribute) {
  // Attribute not found
  RTNLMessage msg;
  EXPECT_EQ(0, msg.GetUint32Attribute(4));

  // Attribute found
  msg.SetAttribute(5, ByteString::CreateFromCPUUInt32(1234));
  EXPECT_EQ(1234, msg.GetUint32Attribute(5));
}

TEST_F(RTNLMessageTest, GetStringAttribute) {
  const char* attr = "attribute";

  // Attribute not found
  RTNLMessage msg;
  EXPECT_EQ("", msg.GetStringAttribute(4));

  // Valid c string attribute found
  msg.SetAttribute(5, ByteString(attr, strlen(attr) + 1));
  EXPECT_EQ("attribute", msg.GetStringAttribute(5));

  // Non null-terminated c string attribute found
  msg.SetAttribute(6, ByteString(attr, 3));
  EXPECT_EQ("att", msg.GetStringAttribute(6));

  // Non null-terminated c string attribute found
  msg.SetAttribute(7, ByteString(attr, 1));
  EXPECT_EQ("a", msg.GetStringAttribute(7));

  // Non text attribute
  const unsigned char not_text[] = {0xff, 0xff, 0xff, 0xff};
  msg.SetAttribute(8, ByteString(not_text, 4));
  EXPECT_EQ("\xff\xff\xff\xff", msg.GetStringAttribute(8));
}

TEST_F(RTNLMessageTest, EncodeGetMessageLength) {
  // The message length of kModeGet should be correct: when there is no
  // attribute, it should be a nlmsg header plus a specific struct for the given
  // RTNL message type.
  RTNLMessage msg_link(RTNLMessage::kTypeLink, RTNLMessage::kModeGet, 0, 0, 0,
                       0, IPAddress::kFamilyIPv4);
  EXPECT_EQ(NLMSG_LENGTH(sizeof(struct ifinfomsg)),
            msg_link.Encode().GetLength());

  RTNLMessage msg_address(RTNLMessage::kTypeAddress, RTNLMessage::kModeGet, 0,
                          0, 0, 0, IPAddress::kFamilyIPv4);
  EXPECT_EQ(NLMSG_LENGTH(sizeof(struct ifaddrmsg)),
            msg_address.Encode().GetLength());

  RTNLMessage msg_route(RTNLMessage::kTypeRoute, RTNLMessage::kModeGet, 0, 0, 0,
                        0, IPAddress::kFamilyIPv4);
  EXPECT_EQ(NLMSG_LENGTH(sizeof(struct rtmsg)), msg_route.Encode().GetLength());

  RTNLMessage msg_rule(RTNLMessage::kTypeRule, RTNLMessage::kModeGet, 0, 0, 0,
                       0, IPAddress::kFamilyIPv4);
  EXPECT_EQ(NLMSG_LENGTH(sizeof(struct rtmsg)), msg_rule.Encode().GetLength());

  RTNLMessage msg_neighor(RTNLMessage::kTypeNeighbor, RTNLMessage::kModeGet, 0,
                          0, 0, 0, IPAddress::kFamilyIPv4);
  EXPECT_EQ(NLMSG_LENGTH(sizeof(struct ndmsg)),
            msg_neighor.Encode().GetLength());
}

}  // namespace shill
