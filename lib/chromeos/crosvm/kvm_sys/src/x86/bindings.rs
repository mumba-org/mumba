/* automatically generated by tools/bindgen-all-the-things */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

// Added by kvm_sys/bindgen.sh
pub const KVM_SYSTEM_EVENT_S2IDLE: u32 = 4;
pub const KVM_SYSTEM_EVENT_RESET_FLAG_PSCI_RESET2: u64 = 0x1;
// TODO(tjeznach): Remove this when reporting KVM_IOAPIC_NUM_PINS is no longer required.
pub const KVM_CAP_IOAPIC_NUM_PINS: u32 = 8191;
// TODO(qwandor): Update this once the pKVM patches are merged upstream with a stable capability ID.
pub const KVM_CAP_ARM_PROTECTED_VM: u32 = 0xffbadab1;
pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_SET_FW_IPA: u32 = 0;
pub const KVM_CAP_ARM_PROTECTED_VM_FLAGS_INFO: u32 = 1;
pub const KVM_VM_TYPE_ARM_PROTECTED: u32 = 0x80000000;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const KVM_PIO_PAGE_OFFSET: u32 = 1;
pub const KVM_COALESCED_MMIO_PAGE_OFFSET: u32 = 2;
pub const DE_VECTOR: u32 = 0;
pub const DB_VECTOR: u32 = 1;
pub const BP_VECTOR: u32 = 3;
pub const OF_VECTOR: u32 = 4;
pub const BR_VECTOR: u32 = 5;
pub const UD_VECTOR: u32 = 6;
pub const NM_VECTOR: u32 = 7;
pub const DF_VECTOR: u32 = 8;
pub const TS_VECTOR: u32 = 10;
pub const NP_VECTOR: u32 = 11;
pub const SS_VECTOR: u32 = 12;
pub const GP_VECTOR: u32 = 13;
pub const PF_VECTOR: u32 = 14;
pub const MF_VECTOR: u32 = 16;
pub const AC_VECTOR: u32 = 17;
pub const MC_VECTOR: u32 = 18;
pub const XM_VECTOR: u32 = 19;
pub const VE_VECTOR: u32 = 20;
pub const KVM_NR_INTERRUPTS: u32 = 256;
pub const KVM_IOAPIC_NUM_PINS: u32 = 24;
pub const KVM_IRQCHIP_PIC_MASTER: u32 = 0;
pub const KVM_IRQCHIP_PIC_SLAVE: u32 = 1;
pub const KVM_IRQCHIP_IOAPIC: u32 = 2;
pub const KVM_NR_IRQCHIPS: u32 = 3;
pub const KVM_RUN_X86_SMM: u32 = 1;
pub const KVM_APIC_REG_SIZE: u32 = 1024;
pub const KVM_MSR_FILTER_MAX_BITMAP_SIZE: u32 = 1536;
pub const KVM_MSR_FILTER_READ: u32 = 1;
pub const KVM_MSR_FILTER_WRITE: u32 = 2;
pub const KVM_MSR_FILTER_MAX_RANGES: u32 = 16;
pub const KVM_MSR_FILTER_DEFAULT_ALLOW: u32 = 0;
pub const KVM_MSR_FILTER_DEFAULT_DENY: u32 = 1;
pub const KVM_CPUID_FLAG_SIGNIFCANT_INDEX: u32 = 1;
pub const KVM_CPUID_FLAG_STATEFUL_FUNC: u32 = 2;
pub const KVM_CPUID_FLAG_STATE_READ_NEXT: u32 = 4;
pub const KVM_GUESTDBG_USE_SW_BP: u32 = 65536;
pub const KVM_GUESTDBG_USE_HW_BP: u32 = 131072;
pub const KVM_GUESTDBG_INJECT_DB: u32 = 262144;
pub const KVM_GUESTDBG_INJECT_BP: u32 = 524288;
pub const KVM_PIT_FLAGS_HPET_LEGACY: u32 = 1;
pub const KVM_VCPUEVENT_VALID_NMI_PENDING: u32 = 1;
pub const KVM_VCPUEVENT_VALID_SIPI_VECTOR: u32 = 2;
pub const KVM_VCPUEVENT_VALID_SHADOW: u32 = 4;
pub const KVM_VCPUEVENT_VALID_SMM: u32 = 8;
pub const KVM_VCPUEVENT_VALID_PAYLOAD: u32 = 16;
pub const KVM_X86_SHADOW_INT_MOV_SS: u32 = 1;
pub const KVM_X86_SHADOW_INT_STI: u32 = 2;
pub const KVM_MAX_XCRS: u32 = 16;
pub const KVM_SYNC_X86_REGS: u32 = 1;
pub const KVM_SYNC_X86_SREGS: u32 = 2;
pub const KVM_SYNC_X86_EVENTS: u32 = 4;
pub const KVM_SYNC_X86_VALID_FIELDS: u32 = 7;
pub const KVM_X86_QUIRK_LINT0_REENABLED: u32 = 1;
pub const KVM_X86_QUIRK_CD_NW_CLEARED: u32 = 2;
pub const KVM_X86_QUIRK_LAPIC_MMIO_HOLE: u32 = 4;
pub const KVM_X86_QUIRK_OUT_7E_INC_RIP: u32 = 8;
pub const KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT: u32 = 16;
pub const KVM_STATE_NESTED_FORMAT_VMX: u32 = 0;
pub const KVM_STATE_NESTED_FORMAT_SVM: u32 = 1;
pub const KVM_STATE_NESTED_GUEST_MODE: u32 = 1;
pub const KVM_STATE_NESTED_RUN_PENDING: u32 = 2;
pub const KVM_STATE_NESTED_EVMCS: u32 = 4;
pub const KVM_STATE_NESTED_MTF_PENDING: u32 = 8;
pub const KVM_STATE_NESTED_GIF_SET: u32 = 256;
pub const KVM_STATE_NESTED_SMM_GUEST_MODE: u32 = 1;
pub const KVM_STATE_NESTED_SMM_VMXON: u32 = 2;
pub const KVM_STATE_NESTED_VMX_VMCS_SIZE: u32 = 4096;
pub const KVM_STATE_NESTED_SVM_VMCB_SIZE: u32 = 4096;
pub const KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE: u32 = 1;
pub const KVM_PMU_EVENT_ALLOW: u32 = 0;
pub const KVM_PMU_EVENT_DENY: u32 = 1;
pub const KVM_API_VERSION: u32 = 12;
pub const KVM_TRC_SHIFT: u32 = 16;
pub const KVM_TRC_ENTRYEXIT: u32 = 65536;
pub const KVM_TRC_HANDLER: u32 = 131072;
pub const KVM_TRC_VMENTRY: u32 = 65537;
pub const KVM_TRC_VMEXIT: u32 = 65538;
pub const KVM_TRC_PAGE_FAULT: u32 = 131073;
pub const KVM_TRC_HEAD_SIZE: u32 = 12;
pub const KVM_TRC_CYCLE_SIZE: u32 = 8;
pub const KVM_TRC_EXTRA_MAX: u32 = 7;
pub const KVM_TRC_INJ_VIRQ: u32 = 131074;
pub const KVM_TRC_REDELIVER_EVT: u32 = 131075;
pub const KVM_TRC_PEND_INTR: u32 = 131076;
pub const KVM_TRC_IO_READ: u32 = 131077;
pub const KVM_TRC_IO_WRITE: u32 = 131078;
pub const KVM_TRC_CR_READ: u32 = 131079;
pub const KVM_TRC_CR_WRITE: u32 = 131080;
pub const KVM_TRC_DR_READ: u32 = 131081;
pub const KVM_TRC_DR_WRITE: u32 = 131082;
pub const KVM_TRC_MSR_READ: u32 = 131083;
pub const KVM_TRC_MSR_WRITE: u32 = 131084;
pub const KVM_TRC_CPUID: u32 = 131085;
pub const KVM_TRC_INTR: u32 = 131086;
pub const KVM_TRC_NMI: u32 = 131087;
pub const KVM_TRC_VMMCALL: u32 = 131088;
pub const KVM_TRC_HLT: u32 = 131089;
pub const KVM_TRC_CLTS: u32 = 131090;
pub const KVM_TRC_LMSW: u32 = 131091;
pub const KVM_TRC_APIC_ACCESS: u32 = 131092;
pub const KVM_TRC_TDP_FAULT: u32 = 131093;
pub const KVM_TRC_GTLB_WRITE: u32 = 131094;
pub const KVM_TRC_STLB_WRITE: u32 = 131095;
pub const KVM_TRC_STLB_INVAL: u32 = 131096;
pub const KVM_TRC_PPC_INSTR: u32 = 131097;
pub const KVM_MEM_LOG_DIRTY_PAGES: u32 = 1;
pub const KVM_MEM_READONLY: u32 = 2;
pub const KVM_PIT_SPEAKER_DUMMY: u32 = 1;
pub const KVM_S390_CMMA_PEEK: u32 = 1;
pub const KVM_EXIT_HYPERV_SYNIC: u32 = 1;
pub const KVM_EXIT_HYPERV_HCALL: u32 = 2;
pub const KVM_EXIT_HYPERV_SYNDBG: u32 = 3;
pub const KVM_S390_GET_SKEYS_NONE: u32 = 1;
pub const KVM_S390_SKEYS_MAX: u32 = 1048576;
pub const KVM_EXIT_UNKNOWN: u32 = 0;
pub const KVM_EXIT_EXCEPTION: u32 = 1;
pub const KVM_EXIT_IO: u32 = 2;
pub const KVM_EXIT_HYPERCALL: u32 = 3;
pub const KVM_EXIT_DEBUG: u32 = 4;
pub const KVM_EXIT_HLT: u32 = 5;
pub const KVM_EXIT_MMIO: u32 = 6;
pub const KVM_EXIT_IRQ_WINDOW_OPEN: u32 = 7;
pub const KVM_EXIT_SHUTDOWN: u32 = 8;
pub const KVM_EXIT_FAIL_ENTRY: u32 = 9;
pub const KVM_EXIT_INTR: u32 = 10;
pub const KVM_EXIT_SET_TPR: u32 = 11;
pub const KVM_EXIT_TPR_ACCESS: u32 = 12;
pub const KVM_EXIT_S390_SIEIC: u32 = 13;
pub const KVM_EXIT_S390_RESET: u32 = 14;
pub const KVM_EXIT_DCR: u32 = 15;
pub const KVM_EXIT_NMI: u32 = 16;
pub const KVM_EXIT_INTERNAL_ERROR: u32 = 17;
pub const KVM_EXIT_OSI: u32 = 18;
pub const KVM_EXIT_PAPR_HCALL: u32 = 19;
pub const KVM_EXIT_S390_UCONTROL: u32 = 20;
pub const KVM_EXIT_WATCHDOG: u32 = 21;
pub const KVM_EXIT_S390_TSCH: u32 = 22;
pub const KVM_EXIT_EPR: u32 = 23;
pub const KVM_EXIT_SYSTEM_EVENT: u32 = 24;
pub const KVM_EXIT_S390_STSI: u32 = 25;
pub const KVM_EXIT_IOAPIC_EOI: u32 = 26;
pub const KVM_EXIT_HYPERV: u32 = 27;
pub const KVM_EXIT_ARM_NISV: u32 = 28;
pub const KVM_EXIT_X86_RDMSR: u32 = 29;
pub const KVM_EXIT_X86_WRMSR: u32 = 30;
pub const KVM_INTERNAL_ERROR_EMULATION: u32 = 1;
pub const KVM_INTERNAL_ERROR_SIMUL_EX: u32 = 2;
pub const KVM_INTERNAL_ERROR_DELIVERY_EV: u32 = 3;
pub const KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON: u32 = 4;
pub const KVM_EXIT_IO_IN: u32 = 0;
pub const KVM_EXIT_IO_OUT: u32 = 1;
pub const KVM_S390_RESET_POR: u32 = 1;
pub const KVM_S390_RESET_CLEAR: u32 = 2;
pub const KVM_S390_RESET_SUBSYSTEM: u32 = 4;
pub const KVM_S390_RESET_CPU_INIT: u32 = 8;
pub const KVM_S390_RESET_IPL: u32 = 16;
pub const KVM_SYSTEM_EVENT_SHUTDOWN: u32 = 1;
pub const KVM_SYSTEM_EVENT_RESET: u32 = 2;
pub const KVM_SYSTEM_EVENT_CRASH: u32 = 3;
pub const KVM_MSR_EXIT_REASON_INVAL: u32 = 1;
pub const KVM_MSR_EXIT_REASON_UNKNOWN: u32 = 2;
pub const KVM_MSR_EXIT_REASON_FILTER: u32 = 4;
pub const SYNC_REGS_SIZE_BYTES: u32 = 2048;
pub const KVM_S390_MEMOP_LOGICAL_READ: u32 = 0;
pub const KVM_S390_MEMOP_LOGICAL_WRITE: u32 = 1;
pub const KVM_S390_MEMOP_SIDA_READ: u32 = 2;
pub const KVM_S390_MEMOP_SIDA_WRITE: u32 = 3;
pub const KVM_S390_MEMOP_F_CHECK_ONLY: u32 = 1;
pub const KVM_S390_MEMOP_F_INJECT_EXCEPTION: u32 = 2;
pub const KVM_MP_STATE_RUNNABLE: u32 = 0;
pub const KVM_MP_STATE_UNINITIALIZED: u32 = 1;
pub const KVM_MP_STATE_INIT_RECEIVED: u32 = 2;
pub const KVM_MP_STATE_HALTED: u32 = 3;
pub const KVM_MP_STATE_SIPI_RECEIVED: u32 = 4;
pub const KVM_MP_STATE_STOPPED: u32 = 5;
pub const KVM_MP_STATE_CHECK_STOP: u32 = 6;
pub const KVM_MP_STATE_OPERATING: u32 = 7;
pub const KVM_MP_STATE_LOAD: u32 = 8;
pub const KVM_S390_SIGP_STOP: u32 = 4294836224;
pub const KVM_S390_PROGRAM_INT: u32 = 4294836225;
pub const KVM_S390_SIGP_SET_PREFIX: u32 = 4294836226;
pub const KVM_S390_RESTART: u32 = 4294836227;
pub const KVM_S390_INT_PFAULT_INIT: u32 = 4294836228;
pub const KVM_S390_INT_PFAULT_DONE: u32 = 4294836229;
pub const KVM_S390_MCHK: u32 = 4294840320;
pub const KVM_S390_INT_CLOCK_COMP: u32 = 4294905860;
pub const KVM_S390_INT_CPU_TIMER: u32 = 4294905861;
pub const KVM_S390_INT_VIRTIO: u32 = 4294911491;
pub const KVM_S390_INT_SERVICE: u32 = 4294910977;
pub const KVM_S390_INT_EMERGENCY: u32 = 4294906369;
pub const KVM_S390_INT_EXTERNAL_CALL: u32 = 4294906370;
pub const KVM_S390_INT_IO_MIN: u32 = 0;
pub const KVM_S390_INT_IO_MAX: u32 = 4294836223;
pub const KVM_S390_INT_IO_AI_MASK: u32 = 67108864;
pub const KVM_S390_PGM_FLAGS_ILC_VALID: u32 = 1;
pub const KVM_S390_PGM_FLAGS_ILC_0: u32 = 2;
pub const KVM_S390_PGM_FLAGS_ILC_1: u32 = 4;
pub const KVM_S390_PGM_FLAGS_ILC_MASK: u32 = 6;
pub const KVM_S390_PGM_FLAGS_NO_REWIND: u32 = 8;
pub const KVM_S390_STOP_FLAG_STORE_STATUS: u32 = 1;
pub const KVM_GUESTDBG_ENABLE: u32 = 1;
pub const KVM_GUESTDBG_SINGLESTEP: u32 = 2;
pub const KVM_X86_DISABLE_EXITS_MWAIT: u32 = 1;
pub const KVM_X86_DISABLE_EXITS_HLT: u32 = 2;
pub const KVM_X86_DISABLE_EXITS_PAUSE: u32 = 4;
pub const KVM_X86_DISABLE_EXITS_CSTATE: u32 = 8;
pub const KVM_X86_DISABLE_VALID_EXITS: u32 = 15;
pub const KVM_PPC_PVINFO_FLAGS_EV_IDLE: u32 = 1;
pub const KVM_PPC_PAGE_SIZES_MAX_SZ: u32 = 8;
pub const KVM_PPC_PAGE_SIZES_REAL: u32 = 1;
pub const KVM_PPC_1T_SEGMENTS: u32 = 2;
pub const KVM_PPC_NO_HASH: u32 = 4;
pub const KVMIO: u32 = 174;
pub const KVM_VM_S390_UCONTROL: u32 = 1;
pub const KVM_VM_PPC_HV: u32 = 1;
pub const KVM_VM_PPC_PR: u32 = 2;
pub const KVM_VM_MIPS_AUTO: u32 = 0;
pub const KVM_VM_MIPS_VZ: u32 = 1;
pub const KVM_VM_MIPS_TE: u32 = 2;
pub const KVM_S390_SIE_PAGE_OFFSET: u32 = 1;
pub const KVM_VM_TYPE_ARM_IPA_SIZE_MASK: u32 = 255;
pub const KVM_CAP_IRQCHIP: u32 = 0;
pub const KVM_CAP_HLT: u32 = 1;
pub const KVM_CAP_MMU_SHADOW_CACHE_CONTROL: u32 = 2;
pub const KVM_CAP_USER_MEMORY: u32 = 3;
pub const KVM_CAP_SET_TSS_ADDR: u32 = 4;
pub const KVM_CAP_VAPIC: u32 = 6;
pub const KVM_CAP_EXT_CPUID: u32 = 7;
pub const KVM_CAP_CLOCKSOURCE: u32 = 8;
pub const KVM_CAP_NR_VCPUS: u32 = 9;
pub const KVM_CAP_NR_MEMSLOTS: u32 = 10;
pub const KVM_CAP_PIT: u32 = 11;
pub const KVM_CAP_NOP_IO_DELAY: u32 = 12;
pub const KVM_CAP_PV_MMU: u32 = 13;
pub const KVM_CAP_MP_STATE: u32 = 14;
pub const KVM_CAP_COALESCED_MMIO: u32 = 15;
pub const KVM_CAP_SYNC_MMU: u32 = 16;
pub const KVM_CAP_IOMMU: u32 = 18;
pub const KVM_CAP_DESTROY_MEMORY_REGION_WORKS: u32 = 21;
pub const KVM_CAP_USER_NMI: u32 = 22;
pub const KVM_CAP_SET_GUEST_DEBUG: u32 = 23;
pub const KVM_CAP_REINJECT_CONTROL: u32 = 24;
pub const KVM_CAP_IRQ_ROUTING: u32 = 25;
pub const KVM_CAP_IRQ_INJECT_STATUS: u32 = 26;
pub const KVM_CAP_ASSIGN_DEV_IRQ: u32 = 29;
pub const KVM_CAP_JOIN_MEMORY_REGIONS_WORKS: u32 = 30;
pub const KVM_CAP_MCE: u32 = 31;
pub const KVM_CAP_IRQFD: u32 = 32;
pub const KVM_CAP_PIT2: u32 = 33;
pub const KVM_CAP_SET_BOOT_CPU_ID: u32 = 34;
pub const KVM_CAP_PIT_STATE2: u32 = 35;
pub const KVM_CAP_IOEVENTFD: u32 = 36;
pub const KVM_CAP_SET_IDENTITY_MAP_ADDR: u32 = 37;
pub const KVM_CAP_XEN_HVM: u32 = 38;
pub const KVM_CAP_ADJUST_CLOCK: u32 = 39;
pub const KVM_CAP_INTERNAL_ERROR_DATA: u32 = 40;
pub const KVM_CAP_VCPU_EVENTS: u32 = 41;
pub const KVM_CAP_S390_PSW: u32 = 42;
pub const KVM_CAP_PPC_SEGSTATE: u32 = 43;
pub const KVM_CAP_HYPERV: u32 = 44;
pub const KVM_CAP_HYPERV_VAPIC: u32 = 45;
pub const KVM_CAP_HYPERV_SPIN: u32 = 46;
pub const KVM_CAP_PCI_SEGMENT: u32 = 47;
pub const KVM_CAP_PPC_PAIRED_SINGLES: u32 = 48;
pub const KVM_CAP_INTR_SHADOW: u32 = 49;
pub const KVM_CAP_DEBUGREGS: u32 = 50;
pub const KVM_CAP_X86_ROBUST_SINGLESTEP: u32 = 51;
pub const KVM_CAP_PPC_OSI: u32 = 52;
pub const KVM_CAP_PPC_UNSET_IRQ: u32 = 53;
pub const KVM_CAP_ENABLE_CAP: u32 = 54;
pub const KVM_CAP_XSAVE: u32 = 55;
pub const KVM_CAP_XCRS: u32 = 56;
pub const KVM_CAP_PPC_GET_PVINFO: u32 = 57;
pub const KVM_CAP_PPC_IRQ_LEVEL: u32 = 58;
pub const KVM_CAP_ASYNC_PF: u32 = 59;
pub const KVM_CAP_TSC_CONTROL: u32 = 60;
pub const KVM_CAP_GET_TSC_KHZ: u32 = 61;
pub const KVM_CAP_PPC_BOOKE_SREGS: u32 = 62;
pub const KVM_CAP_SPAPR_TCE: u32 = 63;
pub const KVM_CAP_PPC_SMT: u32 = 64;
pub const KVM_CAP_PPC_RMA: u32 = 65;
pub const KVM_CAP_MAX_VCPUS: u32 = 66;
pub const KVM_CAP_PPC_HIOR: u32 = 67;
pub const KVM_CAP_PPC_PAPR: u32 = 68;
pub const KVM_CAP_SW_TLB: u32 = 69;
pub const KVM_CAP_ONE_REG: u32 = 70;
pub const KVM_CAP_S390_GMAP: u32 = 71;
pub const KVM_CAP_TSC_DEADLINE_TIMER: u32 = 72;
pub const KVM_CAP_S390_UCONTROL: u32 = 73;
pub const KVM_CAP_SYNC_REGS: u32 = 74;
pub const KVM_CAP_PCI_2_3: u32 = 75;
pub const KVM_CAP_KVMCLOCK_CTRL: u32 = 76;
pub const KVM_CAP_SIGNAL_MSI: u32 = 77;
pub const KVM_CAP_PPC_GET_SMMU_INFO: u32 = 78;
pub const KVM_CAP_S390_COW: u32 = 79;
pub const KVM_CAP_PPC_ALLOC_HTAB: u32 = 80;
pub const KVM_CAP_READONLY_MEM: u32 = 81;
pub const KVM_CAP_IRQFD_RESAMPLE: u32 = 82;
pub const KVM_CAP_PPC_BOOKE_WATCHDOG: u32 = 83;
pub const KVM_CAP_PPC_HTAB_FD: u32 = 84;
pub const KVM_CAP_S390_CSS_SUPPORT: u32 = 85;
pub const KVM_CAP_PPC_EPR: u32 = 86;
pub const KVM_CAP_ARM_PSCI: u32 = 87;
pub const KVM_CAP_ARM_SET_DEVICE_ADDR: u32 = 88;
pub const KVM_CAP_DEVICE_CTRL: u32 = 89;
pub const KVM_CAP_IRQ_MPIC: u32 = 90;
pub const KVM_CAP_PPC_RTAS: u32 = 91;
pub const KVM_CAP_IRQ_XICS: u32 = 92;
pub const KVM_CAP_ARM_EL1_32BIT: u32 = 93;
pub const KVM_CAP_SPAPR_MULTITCE: u32 = 94;
pub const KVM_CAP_EXT_EMUL_CPUID: u32 = 95;
pub const KVM_CAP_HYPERV_TIME: u32 = 96;
pub const KVM_CAP_IOAPIC_POLARITY_IGNORED: u32 = 97;
pub const KVM_CAP_ENABLE_CAP_VM: u32 = 98;
pub const KVM_CAP_S390_IRQCHIP: u32 = 99;
pub const KVM_CAP_IOEVENTFD_NO_LENGTH: u32 = 100;
pub const KVM_CAP_VM_ATTRIBUTES: u32 = 101;
pub const KVM_CAP_ARM_PSCI_0_2: u32 = 102;
pub const KVM_CAP_PPC_FIXUP_HCALL: u32 = 103;
pub const KVM_CAP_PPC_ENABLE_HCALL: u32 = 104;
pub const KVM_CAP_CHECK_EXTENSION_VM: u32 = 105;
pub const KVM_CAP_S390_USER_SIGP: u32 = 106;
pub const KVM_CAP_S390_VECTOR_REGISTERS: u32 = 107;
pub const KVM_CAP_S390_MEM_OP: u32 = 108;
pub const KVM_CAP_S390_USER_STSI: u32 = 109;
pub const KVM_CAP_S390_SKEYS: u32 = 110;
pub const KVM_CAP_MIPS_FPU: u32 = 111;
pub const KVM_CAP_MIPS_MSA: u32 = 112;
pub const KVM_CAP_S390_INJECT_IRQ: u32 = 113;
pub const KVM_CAP_S390_IRQ_STATE: u32 = 114;
pub const KVM_CAP_PPC_HWRNG: u32 = 115;
pub const KVM_CAP_DISABLE_QUIRKS: u32 = 116;
pub const KVM_CAP_X86_SMM: u32 = 117;
pub const KVM_CAP_MULTI_ADDRESS_SPACE: u32 = 118;
pub const KVM_CAP_GUEST_DEBUG_HW_BPS: u32 = 119;
pub const KVM_CAP_GUEST_DEBUG_HW_WPS: u32 = 120;
pub const KVM_CAP_SPLIT_IRQCHIP: u32 = 121;
pub const KVM_CAP_IOEVENTFD_ANY_LENGTH: u32 = 122;
pub const KVM_CAP_HYPERV_SYNIC: u32 = 123;
pub const KVM_CAP_S390_RI: u32 = 124;
pub const KVM_CAP_SPAPR_TCE_64: u32 = 125;
pub const KVM_CAP_ARM_PMU_V3: u32 = 126;
pub const KVM_CAP_VCPU_ATTRIBUTES: u32 = 127;
pub const KVM_CAP_MAX_VCPU_ID: u32 = 128;
pub const KVM_CAP_X2APIC_API: u32 = 129;
pub const KVM_CAP_S390_USER_INSTR0: u32 = 130;
pub const KVM_CAP_MSI_DEVID: u32 = 131;
pub const KVM_CAP_PPC_HTM: u32 = 132;
pub const KVM_CAP_SPAPR_RESIZE_HPT: u32 = 133;
pub const KVM_CAP_PPC_MMU_RADIX: u32 = 134;
pub const KVM_CAP_PPC_MMU_HASH_V3: u32 = 135;
pub const KVM_CAP_IMMEDIATE_EXIT: u32 = 136;
pub const KVM_CAP_MIPS_VZ: u32 = 137;
pub const KVM_CAP_MIPS_TE: u32 = 138;
pub const KVM_CAP_MIPS_64BIT: u32 = 139;
pub const KVM_CAP_S390_GS: u32 = 140;
pub const KVM_CAP_S390_AIS: u32 = 141;
pub const KVM_CAP_SPAPR_TCE_VFIO: u32 = 142;
pub const KVM_CAP_X86_DISABLE_EXITS: u32 = 143;
pub const KVM_CAP_ARM_USER_IRQ: u32 = 144;
pub const KVM_CAP_S390_CMMA_MIGRATION: u32 = 145;
pub const KVM_CAP_PPC_FWNMI: u32 = 146;
pub const KVM_CAP_PPC_SMT_POSSIBLE: u32 = 147;
pub const KVM_CAP_HYPERV_SYNIC2: u32 = 148;
pub const KVM_CAP_HYPERV_VP_INDEX: u32 = 149;
pub const KVM_CAP_S390_AIS_MIGRATION: u32 = 150;
pub const KVM_CAP_PPC_GET_CPU_CHAR: u32 = 151;
pub const KVM_CAP_S390_BPB: u32 = 152;
pub const KVM_CAP_GET_MSR_FEATURES: u32 = 153;
pub const KVM_CAP_HYPERV_EVENTFD: u32 = 154;
pub const KVM_CAP_HYPERV_TLBFLUSH: u32 = 155;
pub const KVM_CAP_S390_HPAGE_1M: u32 = 156;
pub const KVM_CAP_NESTED_STATE: u32 = 157;
pub const KVM_CAP_ARM_INJECT_SERROR_ESR: u32 = 158;
pub const KVM_CAP_MSR_PLATFORM_INFO: u32 = 159;
pub const KVM_CAP_PPC_NESTED_HV: u32 = 160;
pub const KVM_CAP_HYPERV_SEND_IPI: u32 = 161;
pub const KVM_CAP_COALESCED_PIO: u32 = 162;
pub const KVM_CAP_HYPERV_ENLIGHTENED_VMCS: u32 = 163;
pub const KVM_CAP_EXCEPTION_PAYLOAD: u32 = 164;
pub const KVM_CAP_ARM_VM_IPA_SIZE: u32 = 165;
pub const KVM_CAP_MANUAL_DIRTY_LOG_PROTECT: u32 = 166;
pub const KVM_CAP_HYPERV_CPUID: u32 = 167;
pub const KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2: u32 = 168;
pub const KVM_CAP_PPC_IRQ_XIVE: u32 = 169;
pub const KVM_CAP_ARM_SVE: u32 = 170;
pub const KVM_CAP_ARM_PTRAUTH_ADDRESS: u32 = 171;
pub const KVM_CAP_ARM_PTRAUTH_GENERIC: u32 = 172;
pub const KVM_CAP_PMU_EVENT_FILTER: u32 = 173;
pub const KVM_CAP_ARM_IRQ_LINE_LAYOUT_2: u32 = 174;
pub const KVM_CAP_HYPERV_DIRECT_TLBFLUSH: u32 = 175;
pub const KVM_CAP_PPC_GUEST_DEBUG_SSTEP: u32 = 176;
pub const KVM_CAP_ARM_NISV_TO_USER: u32 = 177;
pub const KVM_CAP_ARM_INJECT_EXT_DABT: u32 = 178;
pub const KVM_CAP_S390_VCPU_RESETS: u32 = 179;
pub const KVM_CAP_S390_PROTECTED: u32 = 180;
pub const KVM_CAP_PPC_SECURE_GUEST: u32 = 181;
pub const KVM_CAP_HALT_POLL: u32 = 182;
pub const KVM_CAP_ASYNC_PF_INT: u32 = 183;
pub const KVM_CAP_LAST_CPU: u32 = 184;
pub const KVM_CAP_SMALLER_MAXPHYADDR: u32 = 185;
pub const KVM_CAP_S390_DIAG318: u32 = 186;
pub const KVM_CAP_STEAL_TIME: u32 = 187;
pub const KVM_CAP_X86_USER_SPACE_MSR: u32 = 188;
pub const KVM_CAP_X86_MSR_FILTER: u32 = 189;
pub const KVM_CAP_ENFORCE_PV_FEATURE_CPUID: u32 = 190;
pub const KVM_IRQ_ROUTING_IRQCHIP: u32 = 1;
pub const KVM_IRQ_ROUTING_MSI: u32 = 2;
pub const KVM_IRQ_ROUTING_S390_ADAPTER: u32 = 3;
pub const KVM_IRQ_ROUTING_HV_SINT: u32 = 4;
pub const KVM_IRQFD_FLAG_DEASSIGN: u32 = 1;
pub const KVM_IRQFD_FLAG_RESAMPLE: u32 = 2;
pub const KVM_CLOCK_TSC_STABLE: u32 = 2;
pub const KVM_MMU_FSL_BOOKE_NOHV: u32 = 0;
pub const KVM_MMU_FSL_BOOKE_HV: u32 = 1;
pub const KVM_REG_ARCH_MASK: i64 = -72057594037927936;
pub const KVM_REG_GENERIC: u32 = 0;
pub const KVM_REG_PPC: u64 = 1152921504606846976;
pub const KVM_REG_X86: u64 = 2305843009213693952;
pub const KVM_REG_IA64: u64 = 3458764513820540928;
pub const KVM_REG_ARM: u64 = 4611686018427387904;
pub const KVM_REG_S390: u64 = 5764607523034234880;
pub const KVM_REG_ARM64: u64 = 6917529027641081856;
pub const KVM_REG_MIPS: u64 = 8070450532247928832;
pub const KVM_REG_RISCV: i64 = -9223372036854775808;
pub const KVM_REG_SIZE_SHIFT: u32 = 52;
pub const KVM_REG_SIZE_MASK: u64 = 67553994410557440;
pub const KVM_REG_SIZE_U8: u32 = 0;
pub const KVM_REG_SIZE_U16: u64 = 4503599627370496;
pub const KVM_REG_SIZE_U32: u64 = 9007199254740992;
pub const KVM_REG_SIZE_U64: u64 = 13510798882111488;
pub const KVM_REG_SIZE_U128: u64 = 18014398509481984;
pub const KVM_REG_SIZE_U256: u64 = 22517998136852480;
pub const KVM_REG_SIZE_U512: u64 = 27021597764222976;
pub const KVM_REG_SIZE_U1024: u64 = 31525197391593472;
pub const KVM_REG_SIZE_U2048: u64 = 36028797018963968;
pub const KVM_MSI_VALID_DEVID: u32 = 1;
pub const KVM_CREATE_DEVICE_TEST: u32 = 1;
pub const KVM_DEV_VFIO_GROUP: u32 = 1;
pub const KVM_DEV_VFIO_GROUP_ADD: u32 = 1;
pub const KVM_DEV_VFIO_GROUP_DEL: u32 = 2;
pub const KVM_DEV_VFIO_GROUP_SET_SPAPR_TCE: u32 = 3;
pub const KVM_S390_STORE_STATUS_NOADDR: i32 = -1;
pub const KVM_S390_STORE_STATUS_PREFIXED: i32 = -2;
pub const KVM_DEV_ASSIGN_ENABLE_IOMMU: u32 = 1;
pub const KVM_DEV_ASSIGN_PCI_2_3: u32 = 2;
pub const KVM_DEV_ASSIGN_MASK_INTX: u32 = 4;
pub const KVM_DEV_IRQ_HOST_INTX: u32 = 1;
pub const KVM_DEV_IRQ_HOST_MSI: u32 = 2;
pub const KVM_DEV_IRQ_HOST_MSIX: u32 = 4;
pub const KVM_DEV_IRQ_GUEST_INTX: u32 = 256;
pub const KVM_DEV_IRQ_GUEST_MSI: u32 = 512;
pub const KVM_DEV_IRQ_GUEST_MSIX: u32 = 1024;
pub const KVM_DEV_IRQ_HOST_MASK: u32 = 255;
pub const KVM_DEV_IRQ_GUEST_MASK: u32 = 65280;
pub const KVM_MAX_MSIX_PER_DEV: u32 = 256;
pub const KVM_X2APIC_API_USE_32BIT_IDS: u32 = 1;
pub const KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK: u32 = 2;
pub const KVM_ARM_DEV_EL1_VTIMER: u32 = 1;
pub const KVM_ARM_DEV_EL1_PTIMER: u32 = 2;
pub const KVM_ARM_DEV_PMU: u32 = 4;
pub const KVM_HYPERV_CONN_ID_MASK: u32 = 16777215;
pub const KVM_HYPERV_EVENTFD_DEASSIGN: u32 = 1;
pub const KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE: u32 = 1;
pub const KVM_DIRTY_LOG_INITIALLY_SET: u32 = 2;
pub type __le16 = u16;
pub type __be16 = u16;
pub type __le32 = u32;
pub type __be32 = u32;
pub type __le64 = u64;
pub type __be64 = u64;
pub type __sum16 = u16;
pub type __wsum = u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_memory_alias {
    pub slot: u32,
    pub flags: u32,
    pub guest_phys_addr: u64,
    pub memory_size: u64,
    pub target_phys_addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pic_state {
    pub last_irr: u8,
    pub irr: u8,
    pub imr: u8,
    pub isr: u8,
    pub priority_add: u8,
    pub irq_base: u8,
    pub read_reg_select: u8,
    pub poll: u8,
    pub special_mask: u8,
    pub init_state: u8,
    pub auto_eoi: u8,
    pub rotate_on_auto_eoi: u8,
    pub special_fully_nested_mode: u8,
    pub init4: u8,
    pub elcr: u8,
    pub elcr_mask: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_ioapic_state {
    pub base_address: u64,
    pub ioregsel: u32,
    pub id: u32,
    pub irr: u32,
    pub pad: u32,
    pub redirtbl: [kvm_ioapic_state__bindgen_ty_1; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_ioapic_state__bindgen_ty_1 {
    pub bits: u64,
    pub fields: kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 {
    pub vector: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved: [u8; 4usize],
    pub dest_id: u8,
}
impl kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn delivery_mode(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dest_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trig_mode(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trig_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserve(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserve(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        delivery_mode: u8,
        dest_mode: u8,
        delivery_status: u8,
        polarity: u8,
        remote_irr: u8,
        trig_mode: u8,
        mask: u8,
        reserve: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let delivery_mode: u8 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dest_mode: u8 = unsafe { ::std::mem::transmute(dest_mode) };
            dest_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let delivery_status: u8 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let polarity: u8 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let remote_irr: u8 = unsafe { ::std::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let trig_mode: u8 = unsafe { ::std::mem::transmute(trig_mode) };
            trig_mode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mask: u8 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserve: u8 = unsafe { ::std::mem::transmute(reserve) };
            reserve as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for kvm_ioapic_state__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_ioapic_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_regs {
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rsi: u64,
    pub rdi: u64,
    pub rsp: u64,
    pub rbp: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,
    pub rflags: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_lapic_state {
    pub regs: [::std::os::raw::c_char; 1024usize],
}
impl Default for kvm_lapic_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_segment {
    pub base: u64,
    pub limit: u32,
    pub selector: u16,
    pub type_: u8,
    pub present: u8,
    pub dpl: u8,
    pub db: u8,
    pub s: u8,
    pub l: u8,
    pub g: u8,
    pub avl: u8,
    pub unusable: u8,
    pub padding: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_dtable {
    pub base: u64,
    pub limit: u16,
    pub padding: [u16; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sregs {
    pub cs: kvm_segment,
    pub ds: kvm_segment,
    pub es: kvm_segment,
    pub fs: kvm_segment,
    pub gs: kvm_segment,
    pub ss: kvm_segment,
    pub tr: kvm_segment,
    pub ldt: kvm_segment,
    pub gdt: kvm_dtable,
    pub idt: kvm_dtable,
    pub cr0: u64,
    pub cr2: u64,
    pub cr3: u64,
    pub cr4: u64,
    pub cr8: u64,
    pub efer: u64,
    pub apic_base: u64,
    pub interrupt_bitmap: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_fpu {
    pub fpr: [[u8; 16usize]; 8usize],
    pub fcw: u16,
    pub fsw: u16,
    pub ftwx: u8,
    pub pad1: u8,
    pub last_opcode: u16,
    pub last_ip: u64,
    pub last_dp: u64,
    pub xmm: [[u8; 16usize]; 16usize],
    pub mxcsr: u32,
    pub pad2: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_msr_entry {
    pub index: u32,
    pub reserved: u32,
    pub data: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_msrs {
    pub nmsrs: u32,
    pub pad: u32,
    pub entries: __IncompleteArrayField<kvm_msr_entry>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_msr_list {
    pub nmsrs: u32,
    pub indices: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_msr_filter_range {
    pub flags: u32,
    pub nmsrs: u32,
    pub base: u32,
    pub bitmap: *mut u8,
}
impl Default for kvm_msr_filter_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_msr_filter {
    pub flags: u32,
    pub ranges: [kvm_msr_filter_range; 16usize],
}
impl Default for kvm_msr_filter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_cpuid_entry {
    pub function: u32,
    pub eax: u32,
    pub ebx: u32,
    pub ecx: u32,
    pub edx: u32,
    pub padding: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_cpuid {
    pub nent: u32,
    pub padding: u32,
    pub entries: __IncompleteArrayField<kvm_cpuid_entry>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_cpuid_entry2 {
    pub function: u32,
    pub index: u32,
    pub flags: u32,
    pub eax: u32,
    pub ebx: u32,
    pub ecx: u32,
    pub edx: u32,
    pub padding: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_cpuid2 {
    pub nent: u32,
    pub padding: u32,
    pub entries: __IncompleteArrayField<kvm_cpuid_entry2>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pit_channel_state {
    pub count: u32,
    pub latched_count: u16,
    pub count_latched: u8,
    pub status_latched: u8,
    pub status: u8,
    pub read_state: u8,
    pub write_state: u8,
    pub write_latch: u8,
    pub rw_mode: u8,
    pub mode: u8,
    pub bcd: u8,
    pub gate: u8,
    pub count_load_time: i64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_debug_exit_arch {
    pub exception: u32,
    pub pad: u32,
    pub pc: u64,
    pub dr6: u64,
    pub dr7: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_guest_debug_arch {
    pub debugreg: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pit_state {
    pub channels: [kvm_pit_channel_state; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pit_state2 {
    pub channels: [kvm_pit_channel_state; 3usize],
    pub flags: u32,
    pub reserved: [u32; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_reinject_control {
    pub pit_reinject: u8,
    pub reserved: [u8; 31usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vcpu_events {
    pub exception: kvm_vcpu_events__bindgen_ty_1,
    pub interrupt: kvm_vcpu_events__bindgen_ty_2,
    pub nmi: kvm_vcpu_events__bindgen_ty_3,
    pub sipi_vector: u32,
    pub flags: u32,
    pub smi: kvm_vcpu_events__bindgen_ty_4,
    pub reserved: [u8; 27usize],
    pub exception_has_payload: u8,
    pub exception_payload: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vcpu_events__bindgen_ty_1 {
    pub injected: u8,
    pub nr: u8,
    pub has_error_code: u8,
    pub pending: u8,
    pub error_code: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vcpu_events__bindgen_ty_2 {
    pub injected: u8,
    pub nr: u8,
    pub soft: u8,
    pub shadow: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vcpu_events__bindgen_ty_3 {
    pub injected: u8,
    pub pending: u8,
    pub masked: u8,
    pub pad: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vcpu_events__bindgen_ty_4 {
    pub smm: u8,
    pub pending: u8,
    pub smm_inside_nmi: u8,
    pub latched_init: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_debugregs {
    pub db: [u64; 4usize],
    pub dr6: u64,
    pub dr7: u64,
    pub flags: u64,
    pub reserved: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_xsave {
    pub region: [u32; 1024usize],
}
impl Default for kvm_xsave {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_xcr {
    pub xcr: u32,
    pub reserved: u32,
    pub value: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_xcrs {
    pub nr_xcrs: u32,
    pub flags: u32,
    pub xcrs: [kvm_xcr; 16usize],
    pub padding: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sync_regs {
    pub regs: kvm_regs,
    pub sregs: kvm_sregs,
    pub events: kvm_vcpu_events,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_vmx_nested_state_data {
    pub vmcs12: [u8; 4096usize],
    pub shadow_vmcs12: [u8; 4096usize],
}
impl Default for kvm_vmx_nested_state_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vmx_nested_state_hdr {
    pub vmxon_pa: u64,
    pub vmcs12_pa: u64,
    pub smm: kvm_vmx_nested_state_hdr__bindgen_ty_1,
    pub flags: u32,
    pub preemption_timer_deadline: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vmx_nested_state_hdr__bindgen_ty_1 {
    pub flags: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_svm_nested_state_data {
    pub vmcb12: [u8; 4096usize],
}
impl Default for kvm_svm_nested_state_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_svm_nested_state_hdr {
    pub vmcb_pa: u64,
}
#[repr(C)]
pub struct kvm_nested_state {
    pub flags: u16,
    pub format: u16,
    pub size: u32,
    pub hdr: kvm_nested_state__bindgen_ty_1,
    pub data: kvm_nested_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_nested_state__bindgen_ty_1 {
    pub vmx: kvm_vmx_nested_state_hdr,
    pub svm: kvm_svm_nested_state_hdr,
    pub pad: [u8; 120usize],
}
impl Default for kvm_nested_state__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct kvm_nested_state__bindgen_ty_2 {
    pub vmx: __BindgenUnionField<[kvm_vmx_nested_state_data; 0usize]>,
    pub svm: __BindgenUnionField<[kvm_svm_nested_state_data; 0usize]>,
    pub bindgen_union_field: [u8; 0usize],
}
impl Default for kvm_nested_state__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_nested_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_pmu_event_filter {
    pub action: u32,
    pub nevents: u32,
    pub fixed_counter_bitmap: u32,
    pub flags: u32,
    pub pad: [u32; 4usize],
    pub events: __IncompleteArrayField<u64>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_user_trace_setup {
    pub buf_size: u32,
    pub buf_nr: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_breakpoint {
    pub enabled: u32,
    pub padding: u32,
    pub address: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_debug_guest {
    pub enabled: u32,
    pub pad: u32,
    pub breakpoints: [kvm_breakpoint; 4usize],
    pub singlestep: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_memory_region {
    pub slot: u32,
    pub flags: u32,
    pub guest_phys_addr: u64,
    pub memory_size: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_userspace_memory_region {
    pub slot: u32,
    pub flags: u32,
    pub guest_phys_addr: u64,
    pub memory_size: u64,
    pub userspace_addr: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_irq_level {
    pub __bindgen_anon_1: kvm_irq_level__bindgen_ty_1,
    pub level: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_irq_level__bindgen_ty_1 {
    pub irq: u32,
    pub status: i32,
}
impl Default for kvm_irq_level__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_irq_level {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_irqchip {
    pub chip_id: u32,
    pub pad: u32,
    pub chip: kvm_irqchip__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_irqchip__bindgen_ty_1 {
    pub dummy: [::std::os::raw::c_char; 512usize],
    pub pic: kvm_pic_state,
    pub ioapic: kvm_ioapic_state,
}
impl Default for kvm_irqchip__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_irqchip {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pit_config {
    pub flags: u32,
    pub pad: [u32; 15usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_skeys {
    pub start_gfn: u64,
    pub count: u64,
    pub skeydata_addr: u64,
    pub flags: u32,
    pub reserved: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_s390_cmma_log {
    pub start_gfn: u64,
    pub count: u32,
    pub flags: u32,
    pub __bindgen_anon_1: kvm_s390_cmma_log__bindgen_ty_1,
    pub values: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_s390_cmma_log__bindgen_ty_1 {
    pub remaining: u64,
    pub mask: u64,
}
impl Default for kvm_s390_cmma_log__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_s390_cmma_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_hyperv_exit {
    pub type_: u32,
    pub pad1: u32,
    pub u: kvm_hyperv_exit__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_hyperv_exit__bindgen_ty_1 {
    pub synic: kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_1,
    pub hcall: kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_2,
    pub syndbg: kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_1 {
    pub msr: u32,
    pub pad2: u32,
    pub control: u64,
    pub evt_page: u64,
    pub msg_page: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_2 {
    pub input: u64,
    pub result: u64,
    pub params: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_hyperv_exit__bindgen_ty_1__bindgen_ty_3 {
    pub msr: u32,
    pub pad2: u32,
    pub control: u64,
    pub status: u64,
    pub send_page: u64,
    pub recv_page: u64,
    pub pending_page: u64,
}
impl Default for kvm_hyperv_exit__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_hyperv_exit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_run {
    pub request_interrupt_window: u8,
    pub immediate_exit: u8,
    pub padding1: [u8; 6usize],
    pub exit_reason: u32,
    pub ready_for_interrupt_injection: u8,
    pub if_flag: u8,
    pub flags: u16,
    pub cr8: u64,
    pub apic_base: u64,
    pub __bindgen_anon_1: kvm_run__bindgen_ty_1,
    pub kvm_valid_regs: u64,
    pub kvm_dirty_regs: u64,
    pub s: kvm_run__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_run__bindgen_ty_1 {
    pub hw: kvm_run__bindgen_ty_1__bindgen_ty_1,
    pub fail_entry: kvm_run__bindgen_ty_1__bindgen_ty_2,
    pub ex: kvm_run__bindgen_ty_1__bindgen_ty_3,
    pub io: kvm_run__bindgen_ty_1__bindgen_ty_4,
    pub debug: kvm_run__bindgen_ty_1__bindgen_ty_5,
    pub mmio: kvm_run__bindgen_ty_1__bindgen_ty_6,
    pub hypercall: kvm_run__bindgen_ty_1__bindgen_ty_7,
    pub tpr_access: kvm_run__bindgen_ty_1__bindgen_ty_8,
    pub s390_sieic: kvm_run__bindgen_ty_1__bindgen_ty_9,
    pub s390_reset_flags: u64,
    pub s390_ucontrol: kvm_run__bindgen_ty_1__bindgen_ty_10,
    pub dcr: kvm_run__bindgen_ty_1__bindgen_ty_11,
    pub internal: kvm_run__bindgen_ty_1__bindgen_ty_12,
    pub osi: kvm_run__bindgen_ty_1__bindgen_ty_13,
    pub papr_hcall: kvm_run__bindgen_ty_1__bindgen_ty_14,
    pub s390_tsch: kvm_run__bindgen_ty_1__bindgen_ty_15,
    pub epr: kvm_run__bindgen_ty_1__bindgen_ty_16,
    pub system_event: kvm_run__bindgen_ty_1__bindgen_ty_17,
    pub s390_stsi: kvm_run__bindgen_ty_1__bindgen_ty_18,
    pub eoi: kvm_run__bindgen_ty_1__bindgen_ty_19,
    pub hyperv: kvm_hyperv_exit,
    pub arm_nisv: kvm_run__bindgen_ty_1__bindgen_ty_20,
    pub msr: kvm_run__bindgen_ty_1__bindgen_ty_21,
    pub padding: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_1 {
    pub hardware_exit_reason: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_2 {
    pub hardware_entry_failure_reason: u64,
    pub cpu: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_3 {
    pub exception: u32,
    pub error_code: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_4 {
    pub direction: u8,
    pub size: u8,
    pub port: u16,
    pub count: u32,
    pub data_offset: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_5 {
    pub arch: kvm_debug_exit_arch,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_6 {
    pub phys_addr: u64,
    pub data: [u8; 8usize],
    pub len: u32,
    pub is_write: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_7 {
    pub nr: u64,
    pub args: [u64; 6usize],
    pub ret: u64,
    pub longmode: u32,
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_8 {
    pub rip: u64,
    pub is_write: u32,
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_9 {
    pub icptcode: u8,
    pub ipa: u16,
    pub ipb: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_10 {
    pub trans_exc_code: u64,
    pub pgm_code: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_11 {
    pub dcrn: u32,
    pub data: u32,
    pub is_write: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_12 {
    pub suberror: u32,
    pub ndata: u32,
    pub data: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_13 {
    pub gprs: [u64; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_14 {
    pub nr: u64,
    pub ret: u64,
    pub args: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_15 {
    pub subchannel_id: u16,
    pub subchannel_nr: u16,
    pub io_int_parm: u32,
    pub io_int_word: u32,
    pub ipb: u32,
    pub dequeued: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_16 {
    pub epr: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_17 {
    pub type_: u32,
    pub flags: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_18 {
    pub addr: u64,
    pub ar: u8,
    pub reserved: u8,
    pub fc: u8,
    pub sel1: u8,
    pub sel2: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_19 {
    pub vector: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_20 {
    pub esr_iss: u64,
    pub fault_ipa: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_21 {
    pub error: u8,
    pub pad: [u8; 7usize],
    pub reason: u32,
    pub index: u32,
    pub data: u64,
}
impl Default for kvm_run__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_run__bindgen_ty_2 {
    pub regs: kvm_sync_regs,
    pub padding: [::std::os::raw::c_char; 2048usize],
}
impl Default for kvm_run__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_run {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_coalesced_mmio_zone {
    pub addr: u64,
    pub size: u32,
    pub __bindgen_anon_1: kvm_coalesced_mmio_zone__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_coalesced_mmio_zone__bindgen_ty_1 {
    pub pad: u32,
    pub pio: u32,
}
impl Default for kvm_coalesced_mmio_zone__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_coalesced_mmio_zone {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_coalesced_mmio {
    pub phys_addr: u64,
    pub len: u32,
    pub __bindgen_anon_1: kvm_coalesced_mmio__bindgen_ty_1,
    pub data: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_coalesced_mmio__bindgen_ty_1 {
    pub pad: u32,
    pub pio: u32,
}
impl Default for kvm_coalesced_mmio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_coalesced_mmio {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct kvm_coalesced_mmio_ring {
    pub first: u32,
    pub last: u32,
    pub coalesced_mmio: __IncompleteArrayField<kvm_coalesced_mmio>,
}
impl Default for kvm_coalesced_mmio_ring {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_translation {
    pub linear_address: u64,
    pub physical_address: u64,
    pub valid: u8,
    pub writeable: u8,
    pub usermode: u8,
    pub pad: [u8; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_s390_mem_op {
    pub gaddr: u64,
    pub flags: u64,
    pub size: u32,
    pub op: u32,
    pub buf: u64,
    pub __bindgen_anon_1: kvm_s390_mem_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_s390_mem_op__bindgen_ty_1 {
    pub ar: u8,
    pub sida_offset: u32,
    pub reserved: [u8; 32usize],
}
impl Default for kvm_s390_mem_op__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_s390_mem_op {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_interrupt {
    pub irq: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_dirty_log {
    pub slot: u32,
    pub padding1: u32,
    pub __bindgen_anon_1: kvm_dirty_log__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_dirty_log__bindgen_ty_1 {
    pub dirty_bitmap: *mut ::std::os::raw::c_void,
    pub padding2: u64,
}
impl Default for kvm_dirty_log__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_dirty_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_clear_dirty_log {
    pub slot: u32,
    pub num_pages: u32,
    pub first_page: u64,
    pub __bindgen_anon_1: kvm_clear_dirty_log__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_clear_dirty_log__bindgen_ty_1 {
    pub dirty_bitmap: *mut ::std::os::raw::c_void,
    pub padding2: u64,
}
impl Default for kvm_clear_dirty_log__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_clear_dirty_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_signal_mask {
    pub len: u32,
    pub sigset: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_tpr_access_ctl {
    pub enabled: u32,
    pub flags: u32,
    pub reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vapic_addr {
    pub vapic_addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_mp_state {
    pub mp_state: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_psw {
    pub mask: u64,
    pub addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_interrupt {
    pub type_: u32,
    pub parm: u32,
    pub parm64: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_io_info {
    pub subchannel_id: u16,
    pub subchannel_nr: u16,
    pub io_int_parm: u32,
    pub io_int_word: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_ext_info {
    pub ext_params: u32,
    pub pad: u32,
    pub ext_params2: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_pgm_info {
    pub trans_exc_code: u64,
    pub mon_code: u64,
    pub per_address: u64,
    pub data_exc_code: u32,
    pub code: u16,
    pub mon_class_nr: u16,
    pub per_code: u8,
    pub per_atmid: u8,
    pub exc_access_id: u8,
    pub per_access_id: u8,
    pub op_access_id: u8,
    pub flags: u8,
    pub pad: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_prefix_info {
    pub address: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_extcall_info {
    pub code: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_emerg_info {
    pub code: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_stop_info {
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_mchk_info {
    pub cr14: u64,
    pub mcic: u64,
    pub failing_storage_address: u64,
    pub ext_damage_code: u32,
    pub pad: u32,
    pub fixed_logout: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_s390_irq {
    pub type_: u64,
    pub u: kvm_s390_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_s390_irq__bindgen_ty_1 {
    pub io: kvm_s390_io_info,
    pub ext: kvm_s390_ext_info,
    pub pgm: kvm_s390_pgm_info,
    pub emerg: kvm_s390_emerg_info,
    pub extcall: kvm_s390_extcall_info,
    pub prefix: kvm_s390_prefix_info,
    pub stop: kvm_s390_stop_info,
    pub mchk: kvm_s390_mchk_info,
    pub reserved: [::std::os::raw::c_char; 64usize],
}
impl Default for kvm_s390_irq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_s390_irq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_irq_state {
    pub buf: u64,
    pub flags: u32,
    pub len: u32,
    pub reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_guest_debug {
    pub control: u32,
    pub pad: u32,
    pub arch: kvm_guest_debug_arch,
}
pub const kvm_ioeventfd_flag_nr_datamatch: ::std::os::raw::c_uint = 0;
pub const kvm_ioeventfd_flag_nr_pio: ::std::os::raw::c_uint = 1;
pub const kvm_ioeventfd_flag_nr_deassign: ::std::os::raw::c_uint = 2;
pub const kvm_ioeventfd_flag_nr_virtio_ccw_notify: ::std::os::raw::c_uint = 3;
pub const kvm_ioeventfd_flag_nr_fast_mmio: ::std::os::raw::c_uint = 4;
pub const kvm_ioeventfd_flag_nr_max: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_ioeventfd {
    pub datamatch: u64,
    pub addr: u64,
    pub len: u32,
    pub fd: i32,
    pub flags: u32,
    pub pad: [u8; 36usize],
}
impl Default for kvm_ioeventfd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_enable_cap {
    pub cap: u32,
    pub flags: u32,
    pub args: [u64; 4usize],
    pub pad: [u8; 64usize],
}
impl Default for kvm_enable_cap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_ppc_pvinfo {
    pub flags: u32,
    pub hcall: [u32; 4usize],
    pub pad: [u8; 108usize],
}
impl Default for kvm_ppc_pvinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_ppc_one_page_size {
    pub page_shift: u32,
    pub pte_enc: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_ppc_one_seg_page_size {
    pub page_shift: u32,
    pub slb_enc: u32,
    pub enc: [kvm_ppc_one_page_size; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_ppc_smmu_info {
    pub flags: u64,
    pub slb_size: u32,
    pub data_keys: u16,
    pub instr_keys: u16,
    pub sps: [kvm_ppc_one_seg_page_size; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_ppc_resize_hpt {
    pub flags: u64,
    pub shift: u32,
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_irq_routing_irqchip {
    pub irqchip: u32,
    pub pin: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_irq_routing_msi {
    pub address_lo: u32,
    pub address_hi: u32,
    pub data: u32,
    pub __bindgen_anon_1: kvm_irq_routing_msi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_irq_routing_msi__bindgen_ty_1 {
    pub pad: u32,
    pub devid: u32,
}
impl Default for kvm_irq_routing_msi__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_irq_routing_msi {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_irq_routing_s390_adapter {
    pub ind_addr: u64,
    pub summary_addr: u64,
    pub ind_offset: u64,
    pub summary_offset: u32,
    pub adapter_id: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_irq_routing_hv_sint {
    pub vcpu: u32,
    pub sint: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_irq_routing_entry {
    pub gsi: u32,
    pub type_: u32,
    pub flags: u32,
    pub pad: u32,
    pub u: kvm_irq_routing_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_irq_routing_entry__bindgen_ty_1 {
    pub irqchip: kvm_irq_routing_irqchip,
    pub msi: kvm_irq_routing_msi,
    pub adapter: kvm_irq_routing_s390_adapter,
    pub hv_sint: kvm_irq_routing_hv_sint,
    pub pad: [u32; 8usize],
}
impl Default for kvm_irq_routing_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_irq_routing_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct kvm_irq_routing {
    pub nr: u32,
    pub flags: u32,
    pub entries: __IncompleteArrayField<kvm_irq_routing_entry>,
}
impl Default for kvm_irq_routing {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_x86_mce {
    pub status: u64,
    pub addr: u64,
    pub misc: u64,
    pub mcg_status: u64,
    pub bank: u8,
    pub pad1: [u8; 7usize],
    pub pad2: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_xen_hvm_config {
    pub flags: u32,
    pub msr: u32,
    pub blob_addr_32: u64,
    pub blob_addr_64: u64,
    pub blob_size_32: u8,
    pub blob_size_64: u8,
    pub pad2: [u8; 30usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_irqfd {
    pub fd: u32,
    pub gsi: u32,
    pub flags: u32,
    pub resamplefd: u32,
    pub pad: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_clock_data {
    pub clock: u64,
    pub flags: u32,
    pub pad: [u32; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_config_tlb {
    pub params: u64,
    pub array: u64,
    pub mmu_type: u32,
    pub array_len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_dirty_tlb {
    pub bitmap: u64,
    pub num_dirty: u32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct kvm_reg_list {
    pub n: u64,
    pub reg: __IncompleteArrayField<u64>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_one_reg {
    pub id: u64,
    pub addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_msi {
    pub address_lo: u32,
    pub address_hi: u32,
    pub data: u32,
    pub flags: u32,
    pub devid: u32,
    pub pad: [u8; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_arm_device_addr {
    pub id: u64,
    pub addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_create_device {
    pub type_: u32,
    pub fd: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_device_attr {
    pub flags: u32,
    pub group: u32,
    pub attr: u64,
    pub addr: u64,
}
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_20: kvm_device_type = 1;
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_42: kvm_device_type = 2;
pub const kvm_device_type_KVM_DEV_TYPE_XICS: kvm_device_type = 3;
pub const kvm_device_type_KVM_DEV_TYPE_VFIO: kvm_device_type = 4;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2: kvm_device_type = 5;
pub const kvm_device_type_KVM_DEV_TYPE_FLIC: kvm_device_type = 6;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V3: kvm_device_type = 7;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_ITS: kvm_device_type = 8;
pub const kvm_device_type_KVM_DEV_TYPE_XIVE: kvm_device_type = 9;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_PV_TIME: kvm_device_type = 10;
pub const kvm_device_type_KVM_DEV_TYPE_MAX: kvm_device_type = 11;
pub type kvm_device_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_vfio_spapr_tce {
    pub groupfd: i32,
    pub tablefd: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_ucas_mapping {
    pub user_addr: u64,
    pub vcpu_addr: u64,
    pub length: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_enc_region {
    pub addr: u64,
    pub size: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_pv_sec_parm {
    pub origin: u64,
    pub length: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_s390_pv_unp {
    pub addr: u64,
    pub size: u64,
    pub tweak: u64,
}
pub const pv_cmd_id_KVM_PV_ENABLE: pv_cmd_id = 0;
pub const pv_cmd_id_KVM_PV_DISABLE: pv_cmd_id = 1;
pub const pv_cmd_id_KVM_PV_SET_SEC_PARMS: pv_cmd_id = 2;
pub const pv_cmd_id_KVM_PV_UNPACK: pv_cmd_id = 3;
pub const pv_cmd_id_KVM_PV_VERIFY: pv_cmd_id = 4;
pub const pv_cmd_id_KVM_PV_PREP_RESET: pv_cmd_id = 5;
pub const pv_cmd_id_KVM_PV_UNSHARE_ALL: pv_cmd_id = 6;
pub type pv_cmd_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_pv_cmd {
    pub cmd: u32,
    pub rc: u16,
    pub rrc: u16,
    pub data: u64,
    pub flags: u32,
    pub reserved: [u32; 3usize],
}
pub const sev_cmd_id_KVM_SEV_INIT: sev_cmd_id = 0;
pub const sev_cmd_id_KVM_SEV_ES_INIT: sev_cmd_id = 1;
pub const sev_cmd_id_KVM_SEV_LAUNCH_START: sev_cmd_id = 2;
pub const sev_cmd_id_KVM_SEV_LAUNCH_UPDATE_DATA: sev_cmd_id = 3;
pub const sev_cmd_id_KVM_SEV_LAUNCH_UPDATE_VMSA: sev_cmd_id = 4;
pub const sev_cmd_id_KVM_SEV_LAUNCH_SECRET: sev_cmd_id = 5;
pub const sev_cmd_id_KVM_SEV_LAUNCH_MEASURE: sev_cmd_id = 6;
pub const sev_cmd_id_KVM_SEV_LAUNCH_FINISH: sev_cmd_id = 7;
pub const sev_cmd_id_KVM_SEV_SEND_START: sev_cmd_id = 8;
pub const sev_cmd_id_KVM_SEV_SEND_UPDATE_DATA: sev_cmd_id = 9;
pub const sev_cmd_id_KVM_SEV_SEND_UPDATE_VMSA: sev_cmd_id = 10;
pub const sev_cmd_id_KVM_SEV_SEND_FINISH: sev_cmd_id = 11;
pub const sev_cmd_id_KVM_SEV_RECEIVE_START: sev_cmd_id = 12;
pub const sev_cmd_id_KVM_SEV_RECEIVE_UPDATE_DATA: sev_cmd_id = 13;
pub const sev_cmd_id_KVM_SEV_RECEIVE_UPDATE_VMSA: sev_cmd_id = 14;
pub const sev_cmd_id_KVM_SEV_RECEIVE_FINISH: sev_cmd_id = 15;
pub const sev_cmd_id_KVM_SEV_GUEST_STATUS: sev_cmd_id = 16;
pub const sev_cmd_id_KVM_SEV_DBG_DECRYPT: sev_cmd_id = 17;
pub const sev_cmd_id_KVM_SEV_DBG_ENCRYPT: sev_cmd_id = 18;
pub const sev_cmd_id_KVM_SEV_CERT_EXPORT: sev_cmd_id = 19;
pub const sev_cmd_id_KVM_SEV_NR_MAX: sev_cmd_id = 20;
pub type sev_cmd_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_cmd {
    pub id: u32,
    pub data: u64,
    pub error: u32,
    pub sev_fd: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_launch_start {
    pub handle: u32,
    pub policy: u32,
    pub dh_uaddr: u64,
    pub dh_len: u32,
    pub session_uaddr: u64,
    pub session_len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_launch_update_data {
    pub uaddr: u64,
    pub len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_launch_secret {
    pub hdr_uaddr: u64,
    pub hdr_len: u32,
    pub guest_uaddr: u64,
    pub guest_len: u32,
    pub trans_uaddr: u64,
    pub trans_len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_launch_measure {
    pub uaddr: u64,
    pub len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_guest_status {
    pub handle: u32,
    pub policy: u32,
    pub state: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_sev_dbg {
    pub src_uaddr: u64,
    pub dst_uaddr: u64,
    pub len: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_assigned_pci_dev {
    pub assigned_dev_id: u32,
    pub busnr: u32,
    pub devfn: u32,
    pub flags: u32,
    pub segnr: u32,
    pub __bindgen_anon_1: kvm_assigned_pci_dev__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_assigned_pci_dev__bindgen_ty_1 {
    pub reserved: [u32; 11usize],
}
impl Default for kvm_assigned_pci_dev__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_assigned_pci_dev {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvm_assigned_irq {
    pub assigned_dev_id: u32,
    pub host_irq: u32,
    pub guest_irq: u32,
    pub flags: u32,
    pub __bindgen_anon_1: kvm_assigned_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kvm_assigned_irq__bindgen_ty_1 {
    pub reserved: [u32; 12usize],
}
impl Default for kvm_assigned_irq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kvm_assigned_irq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_assigned_msix_nr {
    pub assigned_dev_id: u32,
    pub entry_nr: u16,
    pub padding: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_assigned_msix_entry {
    pub assigned_dev_id: u32,
    pub gsi: u32,
    pub entry: u16,
    pub padding: [u16; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_hyperv_eventfd {
    pub conn_id: u32,
    pub fd: i32,
    pub flags: u32,
    pub padding: [u32; 3usize],
}
