# Copyright (c) 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# =============================================================================
# WHAT IS THIS FILE?
# =============================================================================
#
# This is the master GN build configuration. This file is loaded after the
# build args (args.gn) for the build directory and after the toplevel ".gn"
# file (which points to this file as the build configuration).
#
# This file will be executed and the resulting context will be used to execute
# every other file in the build. So variables declared here (that don't start
# with an underscore) will be implicitly global.

# =============================================================================
# PLATFORM SELECTION
# =============================================================================
#
# There are two main things to set: "os" and "cpu". The "toolchain" is the name
# of the GN thing that encodes combinations of these things.
#
# Users typically only set the variables "target_os" and "target_cpu" in "gn
# args", the rest are set up by our build and internal to GN.
#
# There are three different types of each of these things: The "host"
# represents the computer doing the compile and never changes. The "target"
# represents the main thing we're trying to build. The "current" represents
# which configuration is currently being defined, which can be either the
# host, the target, or something completely different (like nacl). GN will
# run the same build file multiple times for the different required
# configuration in the same build.
#
# This gives the following variables:
#  - host_os, host_cpu, host_toolchain
#  - target_os, target_cpu, default_toolchain
#  - current_os, current_cpu, current_toolchain.
#
# Note the default_toolchain isn't symmetrical (you would expect
# target_toolchain). This is because the "default" toolchain is a GN built-in
# concept, and "target" is something our build sets up that's symmetrical with
# its GYP counterpart. Potentially the built-in default_toolchain variable
# could be renamed in the future.
#
# When writing build files, to do something only for the host:
#   if (current_toolchain == host_toolchain) { ...

if (target_os == "") {
  target_os = host_os
}

if (target_cpu == "") {
  if (target_os == "android") {
    # If we're building for Android, we should assume that we want to
    # build for ARM by default, not the host_cpu (which is likely x64).
    # This allows us to not have to specify both target_os and target_cpu
    # on the command line.
    target_cpu = "arm"
  } else {
    target_cpu = host_cpu
  }
}

if (current_cpu == "") {
  current_cpu = target_cpu
}
if (current_os == "") {
  current_os = target_os
}

# =============================================================================
# BUILD FLAGS
# =============================================================================
#
# This block lists input arguments to the build, along with their default
# values.
#
# If a value is specified on the command line, it will overwrite the defaults
# given in a declare_args block, otherwise the default will be used.
#
# YOU SHOULD ALMOST NEVER NEED TO ADD FLAGS TO THIS FILE. GN allows any file in
# the build to declare build flags. If you need a flag for a single component,
# you can just declare it in the corresponding BUILD.gn file.
#
# - If your feature is a single target, say //components/foo, you can put
#   a declare_args() block in //components/foo/BUILD.gn and use it there.
#   Nobody else in the build needs to see the flag.
#
# - Defines based on build variables should be implemented via the generated
#   build flag header system. See //build/buildflag_header.gni. You can put
#   the buildflag_header target in the same file as the build flag itself. You
#   should almost never set "defines" directly.
#
# - If your flag toggles a target on and off or toggles between different
#   versions of similar things, write a "group" target that forwards to the
#   right target (or no target) depending on the value of the build flag. This
#   group can be in the same BUILD.gn file as the build flag, and targets can
#   depend unconditionally on the group rather than duplicating flag checks
#   across many targets.
#
# - If a semi-random set of build files REALLY needs to know about a define and
#   the above pattern for isolating the build logic in a forwarding group
#   doesn't work, you can put the argument in a .gni file. This should be put
#   in the lowest level of the build that knows about this feature (which should
#   almost always be outside of the //build directory!).
#
# Other flag advice:
#
# - Use boolean values when possible. If you need a default value that expands
#   to some complex thing in the default case (like the location of the
#   compiler which would be computed by a script), use a default value of -1 or
#   the empty string. Outside of the declare_args block, conditionally expand
#   the default value as necessary.
#
# - Use a name like "use_foo" or "is_foo" (whatever is more appropriate for
#   your feature) rather than just "foo".
#
# - Write good comments directly above the declaration with no blank line.
#   These comments will appear as documentation in "gn args --list".
#
# - Don't call exec_script inside declare_args. This will execute the script
#   even if the value is overridden, which is wasteful. See first bullet.

declare_args() {
  # Set to enable the official build level of optimization. This has nothing
  # to do with branding, but enables an additional level of optimization above
  # release (!is_debug). This might be better expressed as a tri-state
  # (debug, release, official) but for historical reasons there are two
  # separate flags.
  is_official_build = false

  # Whether we're a traditional desktop unix.
  is_desktop_linux = current_os == "linux"

  # Set to true when compiling with the Clang compiler. Typically this is used
  # to configure warnings.
  is_clang =
      current_os == "mac" || current_os == "ios" || current_os == "chromeos" ||
      current_os == "fuchsia" || current_os == "android" ||
      current_os == "win" ||
      (current_os == "linux" && current_cpu != "s390x" &&
       current_cpu != "s390" && current_cpu != "ppc64" &&
       current_cpu != "ppc" && current_cpu != "mips" && current_cpu != "mips64")

  # Allows the path to a custom target toolchain to be injected as a single
  # argument, and set as the default toolchain.
  custom_toolchain = ""

  # This should not normally be set as a build argument.  It's here so that
  # every toolchain can pass through the "global" value via toolchain_args().
  host_toolchain = ""

  # DON'T ADD MORE FLAGS HERE. Read the comment above.
}

declare_args() {
  # Debug build. Enabling official builds automatically sets is_debug to false.
  is_debug = !is_official_build
}

declare_args() {
  # Component build. Setting to true compiles targets declared as "components"
  # as shared libraries loaded dynamically. This speeds up development time.
  # When false, components will be linked statically.
  #
  # For more information see
  # https://chromium.googlesource.com/chromium/src/+/master/docs/component_build.md
  is_component_build = true
    #is_debug && current_os != "ios"
}

assert(!(is_debug && is_official_build), "Can't do official debug builds")

# ==============================================================================
# TOOLCHAIN SETUP
# ==============================================================================
#
# Here we set the default toolchain, as well as the variable host_toolchain
# which will identify the toolchain corresponding to the local system when
# doing cross-compiles. When not cross-compiling, this will be the same as the
# default toolchain.
#
# We do this before anything else to make sure we complain about any
# unsupported os/cpu combinations as early as possible.

if (host_toolchain == "") {
  # This should only happen in the top-level context.
  # In a specific toolchain context, the toolchain_args()
  # block should have propagated a value down.
  # TODO(dpranke): Add some sort of assert here that verifies that
  # no toolchain omitted host_toolchain from its toolchain_args().

  if (host_os == "linux") {
    if (target_os != "linux") {
      # TODO(dpranke) - is_clang normally applies only to the target
      # build, and there is no way to indicate that you want to override
      # it for both the target build *and* the host build. Do we need to
      # support this?
      host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
    } else if (is_clang) {
      host_toolchain = "//build/toolchain/linux:clang_$host_cpu"
    } else {
      host_toolchain = "//build/toolchain/linux:$host_cpu"
    }
  } else if (host_os == "mac") {
    host_toolchain = "//build/toolchain/mac:clang_$host_cpu"
  } else if (host_os == "win") {
    # On Windows always use the target CPU for host builds. On the
    # configurations we support this will always work and it saves build steps.
    if (is_clang) {
      host_toolchain = "//build/toolchain/win:win_clang_$target_cpu"
    } else {
      host_toolchain = "//build/toolchain/win:$target_cpu"
    }
  } else if (host_os == "aix") {
    host_toolchain = "//build/toolchain/aix:$host_cpu"
  } else {
    assert(false, "Unsupported host_os: $host_os")
  }
}

_default_toolchain = ""

if (target_os == "android") {
  assert(host_os == "linux" || host_os == "mac",
         "Android builds are only supported on Linux and Mac hosts.")
  _default_toolchain = "//build/toolchain/android:android_clang_$target_cpu"
} else if (target_os == "chromeos" || target_os == "linux") {
  # See comments in build/toolchain/cros/BUILD.gn about board compiles.
  if (is_clang) {
    _default_toolchain = "//build/toolchain/linux:clang_$target_cpu"
  } else {
    _default_toolchain = "//build/toolchain/linux:$target_cpu"
  }
} else if (target_os == "fuchsia") {
  _default_toolchain = "//build/toolchain/fuchsia:$target_cpu"
} else if (target_os == "ios") {
  _default_toolchain = "//build/toolchain/mac:ios_clang_$target_cpu"
} else if (target_os == "mac") {
  assert(host_os == "mac", "Mac cross-compiles are unsupported.")
  _default_toolchain = host_toolchain
} else if (target_os == "win") {
  # On Windows we use the same toolchain for host and target by default.
  # Beware, win cross builds have some caveats, see docs/win_cross.md
  # TODO(thakis): See if we want to make 32-bit builds on mac hosts work.
  assert(host_os != "mac" || target_cpu == "x64",
         "Mac hosts can only build 64-bit chrome/win, https://crbug.com/794838")
  if (is_clang) {
    _default_toolchain = "//build/toolchain/win:win_clang_$target_cpu"
  } else {
    _default_toolchain = "//build/toolchain/win:$target_cpu"
  }
} else if (target_os == "winuwp") {
  # Only target WinUWP on for a Windows store application and only
  # x86, x64 and arm are supported target CPUs.
  assert(target_cpu == "x86" || target_cpu == "x64" || target_cpu == "arm" ||
         target_cpu == "arm64")
  _default_toolchain = "//build/toolchain/win:uwp_$target_cpu"
} else if (target_os == "aix") {
  _default_toolchain = "//build/toolchain/aix:$target_cpu"
} else {
  assert(false, "Unsupported target_os: $target_os")
}

# If a custom toolchain has been set in the args, set it as default. Otherwise,
# set the default toolchain for the platform (if any).
if (custom_toolchain != "") {
  set_default_toolchain(custom_toolchain)
} else if (_default_toolchain != "") {
  set_default_toolchain(_default_toolchain)
}

# =============================================================================
# OS DEFINITIONS
# =============================================================================
#
# We set these various is_FOO booleans for convenience in writing OS-based
# conditions.
#
# - is_android, is_chromeos, is_ios, and is_win should be obvious.
# - is_mac is set only for desktop Mac. It is not set on iOS.
# - is_posix is true for mac and any Unix-like system (basically everything
#   except Windows).
# - is_linux is true for desktop Linux and ChromeOS, but not Android (which is
#   generally too different despite being based on the Linux kernel).
#
# Do not add more is_* variants here for random lesser-used Unix systems like
# aix or one of the BSDs. If you need to check these, just check the
# current_os value directly.

if (current_os == "win" || current_os == "winuwp") {
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = false
  is_win = true
} else if (current_os == "mac") {
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = false
  is_mac = true
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "android") {
  is_android = true
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "chromeos") {
  is_android = false
  is_chromeos = true
  is_fuchsia = false
  is_ios = false
  is_linux = true
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "nacl") {
  # current_os == "nacl" will be passed by the nacl toolchain definition.
  # It is not set by default or on the command line. We treat is as a
  # Posix variant.
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = true
  is_posix = true
  is_win = false
} else if (current_os == "fuchsia") {
  is_android = false
  is_chromeos = false
  is_fuchsia = true
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = false
  is_win = false
} else if (current_os == "ios") {
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = true
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "linux") {
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = true
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
} else if (current_os == "aix") {
  is_android = false
  is_chromeos = false
  is_fuchsia = false
  is_ios = false
  is_linux = false
  is_mac = false
  is_nacl = false
  is_posix = true
  is_win = false
}

# =============================================================================
# SOURCES FILTERS
# =============================================================================
#
# These patterns filter out platform-specific files when assigning to the
# sources variable. The magic variable |sources_assignment_filter| is applied
# to each assignment or appending to the sources variable and matches are
# automatically removed.
#
# Note that the patterns are NOT regular expressions. Only "*" and "\b" (path
# boundary = end of string or slash) are supported, and the entire string
# must match the pattern (so you need "*.cc" to match all .cc files, for
# example).

# DO NOT ADD MORE PATTERNS TO THIS LIST, see set_sources_assignment_filter call
# below.
sources_assignment_filter = []

if (!is_win) {
  sources_assignment_filter += [
    "*_win.cc",
    "*_win.h",
    "*_win_unittest.cc",
    "*\bwin/*",
    "*.def",
    "*.rc",
  ]
}
if (!is_mac) {
  sources_assignment_filter += [
    "*_mac.h",
    "*_mac.cc",
    "*_mac.mm",
    "*_mac_unittest.h",
    "*_mac_unittest.cc",
    "*_mac_unittest.mm",
    "*\bmac/*",
    "*_cocoa.h",
    "*_cocoa.cc",
    "*_cocoa.mm",
    "*_cocoa_unittest.h",
    "*_cocoa_unittest.cc",
    "*_cocoa_unittest.mm",
    "*\bcocoa/*",
  ]
}
if (!is_ios) {
  sources_assignment_filter += [
    "*_ios.h",
    "*_ios.cc",
    "*_ios.mm",
    "*_ios_unittest.h",
    "*_ios_unittest.cc",
    "*_ios_unittest.mm",
    "*\bios/*",
  ]
}
if (!is_mac && !is_ios) {
  sources_assignment_filter += [ "*.mm" ]
}
if (!is_linux) {
  sources_assignment_filter += [
    "*_linux.h",
    "*_linux.cc",
    "*_linux_unittest.h",
    "*_linux_unittest.cc",
    "*\blinux/*",
  ]
}
if (!is_android) {
  sources_assignment_filter += [
    "*_android.h",
    "*_android.cc",
    "*_android_unittest.h",
    "*_android_unittest.cc",
    "*\bandroid/*",
  ]
}
if (!is_chromeos) {
  sources_assignment_filter += [
    "*_chromeos.h",
    "*_chromeos.cc",
    "*_chromeos_unittest.h",
    "*_chromeos_unittest.cc",
    "*\bchromeos/*",
  ]
}

# DO NOT ADD MORE PATTERNS TO THIS LIST, see set_sources_assignment_filter call
# below.

# Actually save this list.
#
# These patterns are executed for every file in the source tree of every run.
# Therefore, adding more patterns slows down the build for everybody. We should
# only add automatic patterns for configurations affecting hundreds of files
# across many projects in the tree.
#
# Therefore, we only add rules to this list corresponding to platforms on the
# Chromium waterfall.  This is not for non-officially-supported platforms
# (FreeBSD, etc.) toolkits, (X11, GTK, etc.), or features. For these cases,
# write a conditional in the target to remove the file(s) from the list when
# your platform/toolkit/feature doesn't apply.
set_sources_assignment_filter(sources_assignment_filter)

# =============================================================================
# TARGET DEFAULTS
# =============================================================================
#
# Set up the default configuration for every build target of the given type.
# The values configured here will be automatically set on the scope of the
# corresponding target. Target definitions can add or remove to the settings
# here as needed.
#
# WHAT GOES HERE?
#
# Other than the main compiler and linker configs, the only reason for a config
# to be in this list is if some targets need to explicitly override that config
# by removing it. This is how targets opt-out of flags. If you don't have that
# requirement and just need to add a config everywhere, reference it as a
# sub-config of an existing one, most commonly the main "compiler" one.

# Holds all configs used for running the compiler.
default_compiler_configs = [
  "//build/config:feature_flags",
  "//build/config/compiler:afdo",
  "//build/config/compiler:afdo_optimize_size",
  "//build/config/compiler:compiler",
  "//build/config/compiler:clang_stackrealign",
  "//build/config/compiler:compiler_arm_fpu",
  "//build/config/compiler:compiler_arm_thumb",
  "//build/config/compiler:chromium_code",
  "//build/config/compiler:default_include_dirs",
  "//build/config/compiler:default_optimization",
  "//build/config/compiler:default_stack_frames",
  "//build/config/compiler:default_symbols",
  "//build/config/compiler:no_exceptions",
  #"//build/config/compiler:no_rtti",
  "//build/config/compiler:rtti",
  "//build/config/compiler:runtime_library",
  "//build/config/compiler:thin_archive",
  "//build/config/coverage:default_coverage",
  "//build/config/sanitizers:default_sanitizer_flags",
]

if (is_win) {
  default_compiler_configs += [
    "//build/config/win:default_crt",
    "//build/config/win:lean_and_mean",
    "//build/config/win:nominmax",
    "//build/config/win:unicode",
    "//build/config/win:winver",
    "//build/config/win:vs_code_analysis",
  ]
}

if (is_posix) {
  if (current_os != "aix") {
    default_compiler_configs +=
        [ "//build/config/gcc:symbol_visibility_hidden" ]
  }
}

if (is_fuchsia) {
  default_compiler_configs += [ "//build/config/gcc:symbol_visibility_hidden" ]
}

if (is_android) {
  default_compiler_configs +=
      [ "//build/config/android:default_cygprofile_instrumentation" ]
}

if (is_win) {
  default_compiler_configs +=
      [ "//build/config/win:default_cygprofile_instrumentation" ]
}

if (is_clang && !is_nacl) {
  default_compiler_configs += [
    "//build/config/clang:find_bad_constructs",
    "//build/config/clang:extra_warnings",
  ]
}

# Debug/release-related defines.
if (is_debug) {
  default_compiler_configs += [ "//build/config:debug" ]
} else {
  default_compiler_configs += [ "//build/config:release" ]
}

# Static libraries and source sets use only the compiler ones.
set_defaults("static_library") {
  configs = default_compiler_configs
}
set_defaults("source_set") {
  configs = default_compiler_configs
}

# Compute the set of configs common to all linked targets (shared libraries,
# loadable modules, executables) to avoid duplication below.
if (is_win) {
  # Many targets remove these configs, so they are not contained within
  # //build/config:executable_config for easy removal.
  _linker_configs = [
    "//build/config/win:default_incremental_linking",

    # Default to console-mode apps. Most of our targets are tests and such
    # that shouldn't use the windows subsystem.
    "//build/config/win:console",
  ]
} else if (is_mac) {
  _linker_configs = [ "//build/config/mac:strip_all" ]
} else {
  _linker_configs = []
}

# Executable defaults.
default_executable_configs = default_compiler_configs + [
                               "//build/config:default_libs",
                               "//build/config:executable_config",
                             ] + _linker_configs
set_defaults("executable") {
  configs = default_executable_configs
}

# Shared library and loadable module defaults (also for components in component
# mode).
default_shared_library_configs = default_compiler_configs + [
                                   "//build/config:default_libs",
                                   "//build/config:shared_library_config",
                                 ] + _linker_configs
if (is_android) {
  # Strip native JNI exports from shared libraries by default. Binaries that
  # want this can remove this config.
  default_shared_library_configs +=
      [ "//build/config/android:hide_all_but_jni_onload" ]
}
set_defaults("shared_library") {
  configs = default_shared_library_configs
}
set_defaults("loadable_module") {
  configs = default_shared_library_configs

  # loadable_modules are generally used by other libs, not just via JNI.
  if (is_android) {
    configs -= [ "//build/config/android:hide_all_but_jni_onload" ]
  }
}

# ==============================================================================
# COMPONENT SETUP
# ==============================================================================

# Defines a component, which equates to a shared_library when
# is_component_build == true and a static_library otherwise.
#
# Use static libraries for the static build rather than source sets because
# many of of our test binaries link many large dependencies but often don't
# use large portions of them. The static libraries are much more efficient to
# link in this situation since only the necessary object files are linked.
#
# The invoker can override the type of the target in the non-component-build
# case by setting static_component_type to either "source_set" or
# "static_library". If unset, the default will be used.
template("component") {
  if (is_component_build) {
    _component_mode = "shared_library"
  } else if (defined(invoker.static_component_type)) {
    assert(invoker.static_component_type == "static_library" ||
           invoker.static_component_type == "source_set")
    _component_mode = invoker.static_component_type
  } else if (is_android || !defined(invoker.sources)) {
    # When there are no sources defined, use a source set to avoid creating
    # an empty static library (which generally don't work).
    #
    # When we changed components to default from source sets to static
    # libraries, an Android benchmark regressed slightly
    # (https://crbug.com/619593). We don't have a good theory on why this might
    # be since theoretically it should be the same. It could be something as
    # silly as random code locality luck.
    #
    # There seems to be no build-time performance hit to using source sets on
    # Android (the normal reason for defaulting to static libraries), so we
    # make the default on Android to be source set.
    #
    # If it's been a long time since this was added and you're skeptical,
    # please feel free to remove the Android exception and see if any
    # benchmarks obviously regress. If not, it would be great to standardize
    # with the rest of the platforms.
    _component_mode = "source_set"
  } else {
    _component_mode = "static_library"
  }
  target(_component_mode, target_name) {
    # Explicitly forward visibility, implicitly forward everything else.
    # Forwarding "*" doesn't recurse into nested scopes (to avoid copying all
    # globals into each template invocation), so won't pick up file-scoped
    # variables. Normally this isn't too bad, but visibility is commonly
    # defined at the file scope. Explicitly forwarding visibility and then
    # excluding it from the "*" set works around this problem.
    # See http://crbug.com/594610
    forward_variables_from(invoker, [ "visibility" ])
    forward_variables_from(invoker, "*", [ "visibility" ])

    # All shared libraries must have the sanitizer deps to properly link in
    # asan mode (this target will be empty in other cases).
    if (!defined(deps)) {
      deps = []
    }
    deps += [ "//build/config:exe_and_shlib_deps" ]
  }
}

# Component defaults
set_defaults("component") {
  if (is_component_build) {
    configs = default_shared_library_configs
    if (is_android) {
      configs -= [ "//build/config/android:hide_all_but_jni_onload" ]
    }
  } else {
    configs = default_compiler_configs
  }
}

template("swift_module") {  
  swift_version = "4.2"

  if (invoker._is_shared_library) {
    _target_type = "shared_library"
  }

  if (invoker._is_executable) {
    _target_type = "executable"
  }

  if (invoker._is_static_library) {
    _target_type = "static_library"
  }

  target(_target_type, target_name) {
    
    #testonly = true
    # Explicitly forward visibility, implicitly forward everything else.
    # Forwarding "*" doesn't recurse into nested scopes (to avoid copying all
    # globals into each template invocation), so won't pick up file-scoped
    # variables. Normally this isn't too bad, but visibility is commonly
    # defined at the file scope. Explicitly forwarding visibility and then
    # excluding it from the "*" set works around this problem.
    # See http://crbug.com/594610
    forward_variables_from(invoker, [ "visibility" ])
    forward_variables_from(invoker, "*", [ "visibility" ]) 

    #config = []
    configs -= [
      "//build/config/compiler:runtime_library"
    ]

    if (!defined(cflags_swift)) {
      cflags_swift = []
    }

    if (!defined(defines)) {
      defines = []
    }

    defines -= [
      defines
    ]

    defines = [
      "SWIFT_PACKAGE"
    ]

    if (!defined(include_dirs)) {
      include_dirs = []
    }
 
    full_out_dir = rebase_path(target_out_dir)

    cflags_swift += [
      "-module-name",
      target_name, 
      "-incremental",
      "-emit-dependencies", 
      "-emit-module", 
      "-emit-module-path",
      "$full_out_dir/$target_name.swiftmodule",
      "-output-file-map",
      "$full_out_dir/$target_name/output-file-map.json",
      "-enable-batch-mode",
      #"-num-threads",
      #"1", 
      "-swift-version", 
      swift_version, 
      "-j1",
      #"-module-cache-path $full_out_dir/$target_name/ModuleCache",
      #"-parseable-output",
      #"-color-diagnostics"
    ]

    if (is_debug) {
      defines += [
        "DEBUG"
      ]
      cflags_swift += [
        "-Onone",
        "-g"
      ]
    } else {
      cflags_swift += [
        "-O",
      ]
    }

    if (is_linux) {
      if (current_cpu == "x64") {
        cflags_swift += [
          "-target",
          "x86_64-unknown-linux-gnu",
          "-Xcc",
          "-D__GLIB_H_INSIDE__",
          "-Xcc",
          "-DGLIB_COMPILATION"
        ]
      }
    }

    if (!invoker._is_executable) {
      cflags_swift += [
        "-parse-as-library"
      ]
    }

    if (!defined(invoker.swift_library_path)) {
      _swift_library_root = "/usr/local/swift/usr/lib"
    } else {
      _swift_library_root = invoker.swift_library_path
    }

    _swift_static_library_path = _swift_library_root + "/swift_static"
    _swift_library_path = _swift_library_root + "/swift"
    #_output_dir = rebase_path(target_out_dir) + "/../third_party/icu"

    if (is_linux) {
      _swift_static_library_path = _swift_static_library_path + "/linux"
      _swift_library_path = _swift_library_path + "/linux"
    }

    _processor_tag = "none"
    _swift_library_target_path = ""

    if (target_cpu == "x64") {
      _processor_tag = "x86_64"
      _target_triple = "x86_64-unknown-"
      _swift_library_target_path = _swift_library_path + "/" + _processor_tag
      _swift_rt_path = _swift_library_target_path + "/swiftrt.o"
      if (is_linux) {
        _target_triple += "linux"
      }
    }

    if (!defined(ldflags)) {
      ldflags = []
    }
    
    ldflags += [
      "-L$_swift_static_library_path",
      "-L$_swift_library_path",
      "-L$_swift_library_target_path",
      "-lFoundation", 
      "-lswiftCore",
      "-lswiftSwiftOnoneSupport",
      "-lswiftImageInspectionShared",
      "-lCoreFoundation",
      "-lpthread",
      "-latomic",
      #"-licui18n",
      #"-licuuc",
      "-licudataswift",
      "-licui18nswift",
      "-licuucswift",
      "-ldl",
      "-luuid",
      "-std=c++11",
      "-stdlib=libstdc++",
      #"-lcurl",
      #"-lxml2",
      #"-lboringssl",
    ]

    if (is_linux) {
      ldflags += ["-lswiftGlibc"]
      ldflags += ["-L/usr/lib/$_processor_tag-linux-gnu"]
      # for UI stuff
      ldflags += [
        "-lXext",
        "-lXrender",
        "-lX11",
        "-lXi",
        "-lXrandr",
        #"-lgmodule-2.0",
        #"-lgobject-2.0",
        #"-lgthread-2.0",
        #"-lgio-2.0",
        #"-Wl,-Bstatic",
        #"-lglib-2.0"
      ]
      include_dirs += [
        "/usr/lib/x86_64-linux-gnu/glib-2.0/include/",
        "/usr/include/glib-2.0/"
      ]
      if (defined(use_glib)) {
        use_glib = false
      }
    }

    if (defined(_swift_rt_path)) {
      ldflags += [_swift_rt_path ]
    }

    if (!defined(deps)) {
      deps = []
    }

    if (target_name != "Dispatch") {
      deps += [
        "//third_party/libdispatch:Dispatch"
      ]
    }
    # All shared libraries must have the sanitizer deps to properly link in
    # asan mode (this target will be empty in other cases).
    if (_target_type == "executable" || _target_type == "shared_library") {
      deps += [ 
        "//build/config:exe_and_shlib_deps", 
        #":autolink-extract" 
      ]
    }
    if (_target_type == "executable" || _target_type == "shared_library") {
      ldflags += [
        "-ldispatch"
      ]  
    }
  }
}

template("swift_shared") {
  _is_shared_library = true
  _is_static_library = false
  _is_executable = false

  swift_module(target_name){
    forward_variables_from(invoker, [ "visibility" ])
    forward_variables_from(invoker, "*", [ "visibility" ])
    output_name = target_name
  }
}

template("swift_static") {
  _is_shared_library = false
  _is_static_library = true
  _is_executable = false

  swift_module(target_name){
    forward_variables_from(invoker, [ "visibility" ])
    forward_variables_from(invoker, "*", [ "visibility" ])
  }
}


template("swift_executable") {
  _is_shared_library = false
  _is_static_library = false
  _is_executable = true

  swift_module(target_name){
    forward_variables_from(invoker, [ "visibility" ])
    forward_variables_from(invoker, "*", [ "visibility" ])

    output_name = target_name
  }
}

import("//build/config/sanitizers/sanitizers.gni")


template("swift_protobuf") {
  assert(defined(invoker.sources), "Need sources for proto_library")
  proto_sources = invoker.sources

  set_sources_assignment_filter([])

  if (host_os == "win") {
    host_executable_suffix = ".exe"
  } else {
    host_executable_suffix = ""
  }

  if (defined(invoker.proto_in_dir)) {
    proto_in_dir = invoker.proto_in_dir
    #has_nested_dirs = false
    #foreach(proto_source, proto_sources) {
    #  if (get_path_info(proto_source, "dir") != proto_in_dir) {
    #    has_nested_dirs = true
    #  }
    #}
  } else {
    proto_in_dir = get_path_info(proto_sources[0], "dir")
    #has_nested_dirs = false

    # Sanity check, |proto_in_dir| should be defined to allow sub-directories.
    foreach(proto_source, proto_sources) {
      assert(get_path_info(proto_source, "dir") == proto_in_dir,
             "Please define |proto_in_dir| to allow nested directories.")
    }
  }

  proto_in_dir = rebase_path(proto_in_dir, ".")

  if (defined(invoker.proto_out_dir)) {
    proto_out_dir = invoker.proto_out_dir
  } else {
    # Absolute path to the directory of current BUILD.gn file excluding "//".
    proto_out_dir = rebase_path(".", "//")
    if (proto_in_dir != ".") {
      proto_out_dir += "/$proto_in_dir"
    }
  }
  
  swift_out_dir = "$root_gen_dir/" + proto_out_dir
  #rel_swift_out_dir = rebase_path(get_path_info(proto_sources[0], "dir"), root_out_dir)#rebase_path(swift_out_dir, "//") #rebase_path(swift_out_dir, root_build_dir)
  
  #rel_swift_out_dir = rebase_path(get_path_info(proto_sources[0], "dir"), root_gen_dir)
  rel_swift_out_dir = rebase_path(swift_out_dir, root_build_dir)#rebase_path(get_path_info(proto_sources[0], "dir"), root_build_dir)

  protos = rebase_path(invoker.sources, proto_in_dir)
  protogens = []

  # List output files.
  foreach(proto, protos) {
    proto_dir = get_path_info(proto, "dir")
    proto_name = get_path_info(proto, "name")
    proto_path = proto_dir + "/" + proto_name

    protogens += [
      "$swift_out_dir/$proto_path.proto.swift",
    ]
  }

  action_name = "${target_name}Gen"
  source_set_name = target_name

  action(action_name) {
    #testonly = true
    visibility = [ ":$source_set_name" ]
    script = "//tools/protoc_wrapper/protoc_wrapper.py"
    sources = proto_sources

    outputs = get_path_info(protogens, "abspath") 
    #outputs = rebase_path(protogens)

    #print(rebase_path(protogens))

    #args = input_protos
    args = protos

    protoc_label = "//third_party/protobuf:protoc($host_toolchain)"
    protoc_path = get_label_info(protoc_label, "root_out_dir") + "/protoc" +
                  host_executable_suffix
    args += [
      # Wrapper should never pick a system protoc.
      # Path should be rebased because |root_build_dir| for current toolchain
      # may be different from |root_out_dir| of protoc built on host toolchain.
      "--protoc",
      "./" + rebase_path(protoc_path, root_build_dir),
      "--proto-in-dir",
      rebase_path(proto_in_dir, root_build_dir),
      "--swift-out-dir",
      rel_swift_out_dir,
      "--import-dir",
      rebase_path("//kit/proto", root_build_dir)
    ]

    if (defined(invoker.import_dirs)) {
      foreach(path, invoker.import_dirs) {
        args += [ "--import-dir=" + rebase_path(path, root_build_dir) ]
      }
    }

    inputs = [
      protoc_path,
    ]

    deps = [
      protoc_label,
      "//kit/swift/Base",
      "//kit/swift/Net"
    ]

    if (defined(invoker.deps)) {
      # The deps may have steps that have to run before running protoc.
      deps += invoker.deps
    }

  }
  swift_static(target_name) {
      #testonly = true
      forward_variables_from(invoker,
                           [
                             "defines",
                             "testonly",
                             "visibility"
                           ])
      
      sources = get_target_outputs(":$action_name")

      if (defined(invoker.extra_configs)) {
        configs += invoker.extra_configs
      }

      public_configs = [ "//third_party/protobuf:using_proto" ]
      
      print(target_name)
      print(action_name)
      print(sources)
      public_deps = [ 
        ":$action_name",
        "//kit/swift/ThirdParty/ProtocolBuffers"
      ]

      deps = [
        ":$action_name",
        "//runtime/MumbaShims",
        "//kit/swift/ThirdParty/Libevent",
        "//kit/swift/PosixShim",
        "//kit/swift/Base",
        "//kit/swift/Net",
        "//kit/swift/Engine",
        "//kit/swift/Data",
        "//kit/swift/Channel",
        "//kit/swift/Graphics",
        "//kit/swift/Web",
        "//kit/swift/Compositor",
        "//kit/swift/Gpu",
        "//kit/swift/GL",
        "//kit/swift/Service",
        "//kit/swift/Route",
        "//kit/swift/_C",
        "//kit/swift/Javascript",
        "//kit/swift/ThirdParty/CGRPCZlib"
      ]
  }
}

template("mumba_app") {
  assert(defined(invoker.deps), "Need deps as executable input")
  
  action_name = target_name
  
  output_dir = root_out_dir

  # this is very bad.. another way would be to mix
  # app with shared_library or executable in one take

  foreach(dep_name, invoker.deps) { 
    #if (is_executable || is_shared_library) {
      input_file = rebase_path(output_dir + "/lib" + get_label_info(dep_name, "name") + ".so")
    #}
  }

  inputs = [input_file]
  
  if (host_os == "win") {
    host_executable_suffix = ".exe"
  } else {
    host_executable_suffix = ""
  }

  if (defined(invoker.app_name)) {
    output_file = rebase_path(output_dir + "/" + invoker.app_name + ".app")
  } else {
    output_file = rebase_path(output_dir + "/" + target_name + ".app")
  }


  action(action_name) {

    forward_variables_from(invoker,
                           [
                             "defines",
                             #"testonly",
                             "visibility",
                             "deps"
                           ])

    mumba_path = root_out_dir + "/mumba" +
                     host_executable_suffix
    #testonly = true
    script = "//tools/mumba_wrapper/mumba_wrapper.py"
    args = [
      "--mumba",
      "./" + rebase_path(mumba_path, "//tools/mumba_wrapper"),
      "--command",
      "pack",
      "--subcommand",
      "app",
      "--out_app",
      output_file,
      "--input_executable",
      input_file
    ]
    outputs = [
      output_file,
    ]
  }

}

template("mumba_bundle") {
  #action_name = "${target_name}_bundle_gen"
  action_name = target_name
  output_dir = root_out_dir
  output_file = output_dir + target_name + ".mumba"

   if (host_os == "win") {
    host_executable_suffix = ".exe"
  } else {
    host_executable_suffix = ""
  }

  input_dir = invoker.input_dir

  action(action_name) {
    forward_variables_from(invoker,
                           [
                             "defines",
                             #"testonly",
                             "visibility",
                             "deps"
                           ])
    #testonly = true
    mumba_path = root_out_dir + "/mumba" +
                     host_executable_suffix
    script = "//tools/mumba_wrapper/mumba_wrapper.py"
    args = [
      "--mumba",
      "./" + rebase_path(mumba_path, "//tools/mumba_wrapper"),
      "--command",
      "bundle",
      "--subcommand",
      "create",
      input_dir,
      output_file      
    ]
    outputs = [
      output_file
    ]
  }
}